## Настройка и расширение системы сборки

Файл `ymake.core.conf` является основным конфигурационным файлом системы сборки `ymake` и играет ключевую роль в управлении процессом сборки проектов. 

Он описывает макросы, модули, мультимодули, глобальные переменные, системные заголовки и другие аспекты конфигурации сборки. 

Используя декларативный язык `DSL` (Domain-Specific Language), файл позволяет гибко настраивать правила для различных платформ, устанавливать шаблоны сборочных команд, определять их свойства и зависимости, а также управлять входами и результатами команд, связывая их в граф.

Конфигурационный файл `ymake.core.conf` предоставляет следующие возможности:
- Устанавливать правила настройки переменных для разных платформ и параметров.
- Описывать макросы, их параметры и поведение.
- Определять шаблоны сборочных команд с их дополнительными свойствами, такими как отображаемое имя или требуемые ресурсы.
- Указывать входные и выходные данные для связывания команд в граф.
- Применять макросы в зависимости от расширений файлов.
- Задавать свойства модулей и связывать их с командами и между собой.
- Устанавливать правила для модулей: их свойства и команды зависят от платформы и параметров.
- Определять варианты мультимодулей и их зависимости.

### Правила настройки переменных
При описании модуля некоторые переменные можно сделать глобальными. Для этого используется свойство `.GLOBAL` у модуля. Для обращения к глобальной переменной нужно добавить суффикс `_GLOBAL` к её имени.

Пример:
```
module MY_MOD {
    .CMD=builder --list $MY_VAR_GLOBAL --extra $ANOTHER_VAR_GLOBAL
    .GLOBAL=MY_VAR ANOTHER_VAR
    ...

    SET(MY_VAR_GLOBAL $MODDIR)
    SET(ANOTHER_VAR_GLOBAL VERBOSE)
}
```
Во время конфигурации модуля глобальные переменные ведут себя как локальные. Можно получать только те значения, которые установлены в текущем модуле.  
Однако, на этапе выполнения (рендера) глобальная переменная собирает все значения, установленные во всех модулях, от которых зависит текущий модуль. Значения собираются в обратном порядке обхода графа зависимостей: от корня к листьям.  
Т.е. значения из корневых узлов будут в конце списка, а из листовых - в начале.

**Пример зависимости:**
```

  ┌─────► lib-mid1──────┐
  │                     ▼
main                  lib-leaf
  │                     ▲
  └─────► lib-mid2──────┘

```
Для конечного модуля `main` сборочные команды будут выглядеть так:

```bash
# lib-leaf
builder --list lib-leaf --extra VERBOSE

# lib-mid1
builder --list lib-leaf lib-mid1 --extra VERBOSE VERBOSE

# lib-mid2
builder --list lib-leaf lib-mid2 --extra VERBOSE VERBOSE

# main
builder --list lib-leaf lib-mid1 lib-mid2 main --extra VERBOSE VERBOSE VERBOSE VERBOSE

```
Разворачивание глобальных переменных происходит на этапе рендера. Это означает, что модификаторы `input` и `output` на глобальных переменных не добавят дополнительные зависимые ребра в граф. Однако, можно использовать фильтры и форматеры (например, `suf`, `pre`, `join`, `ext`) для обработки значений.

Пример использования:
```bash
${pre=arc/;suf=/bin:MY_VAR_GLOBAL}
```

В проекте также существуют предопределенные глобальные переменные, такие как `PEERS`.

Для глобальных ресурсов действуют особые правила. Если глобальный ресурс определён в нескольких модулях, все определения должны быть идентичны.  
При несовпадении значений это приводит к ошибке конфигурации.

Пример глобального ресурса:
```
{resource:RESOURCES_URIS_GLOBAL}
```

В рендере глобального ресурса используется только одно значение, последующие объявления игнорируются.

Глобальные переменные и ресурсы облегчают распространение параметров и настроек между модулями, что упрощает управление сложными зависимостями и конфигурациями проекта.

### Основные принципы по написанию макросов.

Макросы используются для создания повторно используемых блоков кода, которые выполняют определенные задачи, такие как настройка модулей, установка переменных, отключение функциональности и многое другое. 

Условно макросы можно разделить на две группы:

1. Макросы, задающие свойства: Эти макросы вызывают другие макросы и в итоге формируют переменные, которые будут использованы в командах других макросов или модуля. Кроме того, такие макросы могут добавлять зависимости или устанавливать свойства модуля.
2. Макросы, описывающие команды: Эти макросы описывают команды, которые должны быть исполнены в процессе сборки. Макрос формирует команду, которая встраивается в сборочный граф своего модуля за счёт связывания своих результатов с входами других команд (потребителей) и, возможно, своих входов с результатами других команд (источников). Такие макросы и формируют сборочный граф, который исполняется в процессе сборки.

Определение макроса осуществляется посредством ключевого слова `macro`, за которым следует имя макроса. Макрос может также принимать параметры, которые указываются в скобках сразу после его имени.

Пример:
```plaintext
macro MY_MACRO(PARAM1, PARAM2) {
   // Код макроса
 }
```
Установка переменных и вызов функций внутри макроса осуществляется следующим образом: переменные устанавливаются при помощи функции `SET`, а для выполнения определённых действий можно вызывать другие функции.

Пример:
```plaintext
   macro SET_VARIABLES() {
       SET(VAR1 "value1")
       SET(VAR2 "value2")
   }
```
Условия в макросах могут быть заданы для выполнения действий в зависимости от значений переменных. Эти условия определяются с помощью ключевого слова `when` и проверяются на истинность.

Правила (триггеры) задают значения переменных на основе других переменных. Условные выражения в языке конфигурации не исполняются в последовательности их написания, а активируются при изменении значения соответствующего условия. Поэтому вместо конструкции `if/then/else` используется синтаксис `when/elsewhen/otherwise`.

Пример:
```plaintext
   macro CONDITIONAL_SET(CONDITION) {
       when ($CONDITION == "yes") {
           SET(VAR "value1")
       }
       otherwise {
           SET(VAR "value2")
       }
   }
```
Отключение функциональности в макросах осуществляется с использованием функции `DISABLE` для отключения определённых функций или зависимостей, а включение осуществляется с помощью функции `ENABLE`.

Пример:
   ```plaintext
### @usage: WERROR()
### Consider warnings as errors in the current module.
### In the bright future will be removed, since WERROR is the default.
### Priorities: NO_COMPILER_WARNINGS > NO_WERROR > WERROR_MODE > WERROR.
macro WERROR() {
    ENABLE(WERROR)
}

### @usage: NO_WERROR()
### Override WERROR() behavior
### Priorities: NO_COMPILER_WARNINGS > NO_WERROR > WERROR_MODE > WERROR.
macro NO_WERROR() {
    DISABLE(WERROR)
}
```
Макросы могут использовать глобальные переменные и атрибуты, которые влияют на поведение всего проекта.

Пример:
```plaintext
   macro SET_GLOBAL_ATTRIBUTES() {
       .GLOBAL=_AARS _PROGUARD_RULES
   }
```
### Основные принципы по написанию модулей.

Модуль фактически представляет собой макрос, задающий правила сборки команды.

Модули определяют различные компоненты проекта, такие как библиотеки, исполняемые файлы, тесты и другие. 

Модуль определяется с использованием ключевого слова `module` и имени модуля. Он может наследовать свойства и поведение от другого модуля, указываемого после двоеточия. Это позволяет избежать дублирования общих свойств между модулями. 

Например, модули `PROGRAM` и `DLL` наследуются от модуля `_LINK_UNIT`, который задает общие свойства, связанные с возможностью линковки библиотек.

Свойства наследника могут либо переопределять свойства предка, либо объединяться, в зависимости от конкретного свойства. При этом макросы модуля предка будут вызываться раньше, чем макросы модуля наследника.

Пример:
```plaintext
module MY_LIBRARY: _LIBRARY {
       // Код модуля
}
```
Внутри модуля можно устанавливать переменные с помощью функции `SET` и вызывать другие функции для выполнения определенных действий. Модули могут содержать условия, зависящие от значений переменных. Модуль может иметь локальные переменные, которые могут изменить поведение как его собственной команды, так и других команд, связанных с его сборкой. На основе переменных также могут быть определены условные правила поведения модуля.

Пример:
```plaintext
module MY_LIBRARY: _LIBRARY {
  when ($CONDITION == "yes") {
       SET(MODULE_TYPE LIBRARY)
       SET(MODULE_LANG CPP)
   }
}
```
Модуль позволяет устанавливать различные атрибуты, которые определяют его функциональные возможности и свойства. 
Эти атрибуты могут включать глобальные переменные и другие параметры, которые оказывают влияние на поведение и работу всего проекта.

Пример:
```plaintext
module MY_LIBRARY: _LIBRARY {
    .GLOBAL=_AARS _PROGUARD_RULES
    .SEM=CPP_LIBRARY_SEM
    .DEFAULT_NAME_GENERATOR=ThreeDirNames
    SET(MODULE_TYPE LIBRARY)
    SET(MODULE_LANG CPP)
}
```
Список доступных макросов и модулей непрерывно растет. 
Для поддержания актуальности, на основе комментариев и описаний автоматически генерируется документация, содержащая информацию обо всех доступных на данный момент макросах и модулях.

### Плагины

Ядро системы сборки поддерживает расширение функциональности с помощью плагинов на `Python` и `C++`. Несмотря на то, что код на `Python` обрабатывается медленнее по сравнению с встроенным `DSL`, он позволяет обойти некоторые ограничения встроенного языка.

С помощью `Python` можно:
- Писать макросы, задающие свойства и описывающие команды.
- Обрабатывать файлы по расширениям, как команды, так и парсинг зависимостей.

Код для плагинов на `Python` размещается в директории `build/plugins`. Реализации макросов представляют собой функции `Python` вида `on<имя_макроса>`. Например, реализация макроса `PY_SRCS` будет представлена функцией `onPY_SRCS`.

Плагины на `Python` загружаются во время выполнения сборки и интерпретируются ядром системы сборки, в которое встроен интерпретатор `Python`. Это означает, что любые изменения в плагинах, как и в конфигурации, не требуют релиза системы сборки.

Система сборки также поддерживает расширение с помощью плагинов на `C++`. Эти плагины встроены в ядро системы сборки, но реализуются не в основной логике ядра, а как отдельные сущности, вызываемые через интерфейс плагинов.

Преимущества плагинов на `C++` является высокая скорость выполнения.

Недостаток в том, что плагины на `C++` требуют релизного цикла. Из-за того, что они встроены в ядро, их релиз происходит вместе с ним. При локальной разработке и тестировании таких плагинов необходимо пересобирать ядро системы сборки (программа `devtools/ymake/bin`).

Например, макрос `RESOURCE` реализован с использованием плагина на `C++`.

Плагины применяются в макросах, которые могут принимать параметры для настройки поведения. При использовании плагинов необходимо учитывать их зависимости от других модулей или библиотек, которые должны быть указаны с помощью `PEERDIR`. Также важно корректно указывать путь к плагину и его имя в макросе, чтобы система сборки могла правильно их использовать.

### Скрипты.

Скрипты в системе сборки — это ключевой элемент для реализации специфичных сборочных команд проекта.
Они помогают справиться с задачами, которые не покрываются стандартными инструментами сборки, и предоставляют дополнительные возможности для адаптации и расширения функциональности сборочного процесса.

Скрипты размещаются в директории `build/scripts`. 
Это централизованное место хранения, где находятся все нужные скрипты для управления сборкой проекта.

Для написания скриптов используется два языка:

- `C++`: Если важна высокая производительность и интеграция с проектом.
- `Python`: Идеален для быстрого прототипирования и написания небольших скриптов.

Вызов скриптов в системе сборки осуществляется с помощью макросов. 
Макросы описывают команды, которые нужно выполнить во время сборки, и помогают встроить эти команды в сборочные графы модулей. Это достигается связыванием результатов выполнения одних команд с входами других (потребителей) и, возможно, входов с результатами других команд (источников).

Скрипты поддерживают передачу различных параметров, что позволяет гибко настраивать команды под конкретные задачи сборки. Параметры передаются через макросы и могут включать пути к файлам, опции компиляции, флаги и другие важные данные.

**Пример макроса для вызова скрипта**

```make
macro CUSTOM_BUILD_STEP(Param1, Param2) {
    .CMD=YMAKE_PYTHON ${input:“build/scripts/my_build_script.py”} ${input:Param1} ${output:Param2}
}
```
- {input:"build/scripts/my_build_script.py"} — путь к вашему скрипту.
- {input:Param1} и {output:Param2} — параметры, передаваемые в скрипт.

### Ошибка UnkStatm

Ошибка `UnkStatm` возникает в случае вызова неизвестного макроса в файле сборки проекта `ya.make`. В файлах описания сборки запрещено использовать макросы, имена которых начинаются с символа подчеркивания. Макросы, которые можно использовать в сборке, описаны в `ymake.core.conf` или в плагинах `build/plugins`.
