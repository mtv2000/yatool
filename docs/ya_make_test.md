# Опции тестирования
## Запуск тестов
* Опция `-t` используется в командной строке с целью запуска тестов в системах сборки. Эта опция может иметь несколько уточняющих модификаторов, которые позволяют более гранулярно контролировать, какие именно тесты будут запущены. В зависимости от системы сборки или тестовой инфраструктуры, семантика и реализация этих опций может немного отличаться, но базовая концепция остаётся схожей.

 `-t` — Запустить SMALL тесты
Опция `-t` без дополнительных модификаторов указывает системе выполнить запуск тестов, классифицированных как SMALL. 

SMALL тесты обычно включают в себя легковесные тесты, такие как unit-тесты, которые быстро выполняются и не требуют сложной конфигурации окружения или внешних зависимостей. Запуск исключительно SMALL тестов позволяет быстро получить обратную связь о качестве кода без значительного увеличения времени сборки или тестирования и выполняются не более 1 минуты

`-tt` — Запустить SMALL и MEDIUM тесты
Использование двойного модификатора `-tt` расширяет диапазон запускаемых тестов, добавляя к SMALL тестам ещё и те, что классифицированы как MEDIUM. 

MEDIUM тесты могут включать в себя более тяжёлые или затратные по времени проверки по сравнению с SMALL, например, интеграционные тесты и end-to-end тесты. Такая комбинация позволяет выполнить более широкое тестирование без значительного увеличения времени и ресурсов, хоть и с меньшей скоростью обратной связи, чем при запуске только SMALL тестов. Обычно выполняются не более 10 минут.

 `-ttt` — Запустить SMALL, MEDIUM и LARGE тесты
При добавлении третьего модификатора `-ttt` система будет запускать тесты всех размеров: SMALL, MEDIUM и LARGE.

LARGE тесты — это самые затратные по времени и ресурсам тесты. Их выполнение может занимать значительное время, обычно не более 1 часа, но позволяет максимально полно убедиться в качестве и стабильности продукта.

Строгого соответствия между размером тестов (SMALL, MEDIUM, LARGE) и типом тестов (unit, интеграционные, end to end) нет. В первую очередь нужно ориентироваться на максимальное время исполнения каждого теста.

* Опция `-A` или `--run-all-tests` используется для запуска всех доступных тестов в контексте заданной среды сборки или тестирования. Этот флаг тоже, что и `-ttt`

Основное предназначение этой опции — обеспечить комплексную проверку всего проекта путем выполнения всех заранее подготовленных и доступных тестов.
 
* Опция `-L` или `--list-tests` предоставляет функциональность для вывода списка доступных тестов  без их фактического запуска.

Инструмент полезен для получения обзора тестового покрытия проекта, а также для выборочного запуска конкретных тестов при необходимости.

Опция поддерживает выбор размера тестов, а также все параметры фильтрации.

`ya make -AL --regular-tests devtools/examples/tutorials/python`

После выполнения этой команды пользователь получит на стандартный вывод список тестов, доступных для запуска. 

* Опция `--test-threads=TEST_THREADS` используется в контексте автоматизированного тестирования программного обеспечения для управления количеством потоков, которые могут выполнять тесты параллельно.

Значение `TEST_THREADS`, указываемое в качестве параметра опции, определяет максимальное количество тестов, которые будут запущены одновременно. 

На серверах непрерывной интеграции или локальных машинах с ограниченными аппаратными ресурсами может быть целесообразно ограничить число параллельно выполняемых тестов, чтобы избежать излишней нагрузки на систему и потому по умолчанию в параллель запускается не больше 2х тестов.

* Опция `--fail-fast`  указывает инструменту тестирования прервать процесс выполнения тестов сразу же после обнаружения первого провального (непройденного) теста.

Такой подход используется для экономии времени при разработке и диагностике ошибок. Позволяет разработчикам быстро получить информацию о проблемах в коде, не дожидаясь завершения полного цикла тестирования.

`ya make -A --fail-fast devtools/examples/tutorials/python`

При запуске команда останавливает процесс после первого же провального теста и возвращает статус ошибки. Это значит, что оставшиеся тесты не будут запущены, и команда прекращает свою работу, предоставляя пользователю информацию о проваленном тесте.

* Опция `--add-peerdirs-tests=PEERDIRS_TEST_TYPE` представляет собой настройку в инструментах сборки и тестирования, которая определяет, какие тесты из зависимостей (обозначаются через механизм PEERDIR) следует включать в текущую сессию тестирования. Опция позволяет настроить процесс тестирования, выбирая, в какой степени тесты зависимостей должны учитываться при запуске. 

 Параметры `PEERDIRS_TEST_TYPE`:
 - `none`: Тесты из зависимостей не включаются автоматически. Единственные тесты, которые будут запущены, — это те, что явно указаны в текущей цели тестирования. Это поведение по умолчанию, исходя из предположения, что разработчик хочет запустить только тесты, непосредственно связанные с текущим компонентом или изменениями.
 - `gen`: Включаются только тесты, сгенерированные автоматически (например, для проверки API или контрактов интерфейсов) из зависимостей, указанных через `PEERDIR`. Применяется для проверки того, что изменения в текущем компоненте не нарушили ожидаемые правила использования взаимодействующих с ним компонентов.
 - `all`: Включаются все доступные тесты из зависимостей, создающее самое широкое покрытие. Режим полезен при проведении комплексного тестирования перед важными релизами или для проверки интеграции на уровне всего проекта.

* Опция `--split-factor=TESTING_SPLIT_FACTOR` является конфигурационным параметром,  позволяет управлять степенью параллелизма тестов, переопределяя значение параметра `SPLIT_FACTOR`.
* 
`SPLIT_FACTOR` определяет, как тесты могут быть разбиты на более мелкие группы (или “чанки”) для параллельного выполнения.

`SPLIT_FACTOR` является числовым параметром, который указывает величину, на которую могут быть разделены тесты для исполнения в параллельных потоках или процессах. 

Например, если для набора из 100 тестов установлен `SPLIT_FACTOR` равный 10 (значение по умолчанию), эти тесты могут быть разбиты на 10 групп по 10 тестов для параллельного выполнения.

`ya make -tt --split-factor=5`

Эта команда указывает системе тестирования разбить тесты на части таким образом, чтобы каждая часть могла быть исполнена в 5 параллельных потоков или “чанков”, что может привести к ускорению процесса тестирования за счет параллелизма.

* Опция `--test-prepare` предлагает  механизм для подготовки всего необходимого окружения для проведения тестов без их непосредственного запуска. Эта функциональность особенно полезна в контекстах, где требуется предварительная настройка тестового окружения, включая установку зависимостей, конфигурацию данных и создание вспомогательных сервисов, которые могут быть необходимы для успешного выполнения тестов.

Разработчики могут использовать эту опцию для конфигурации локального тестового окружения перед запуском тестов вручную.

После запуска команды `ya make -A --test-prepare` в директории с тестом будет лежать тестовый бинарный файл.
При обычных запусках, этот бинарный файл запускает тестовое окружение, в которое передается нужные параметры и путь до контекстного файла. 

Использование `--test-prepare` разделяет процесс подготовки тестов и их исполнение, что приводит к повышению управляемости тестового процесса.

* Опция `--no-src-changes` устанавливает директиву системе сборки не производить никаких изменений в исходных файлах проекта, гарантируя, что код и структура проекта останутся неизменными после выполнения операции. 

При выполнении тестов некоторые инструменты могут требовать временных изменений в коде или конфигурациях.
Опция `--no-src-changes` гарантирует, что все инструментальные изменения будут проведены с согласия разработчика и позволяет избежать неожиданных последствий в результате автоматизированных операций с кодом.

## Фильтрация
* Опция `-X` или `--last-failed-tests` позволяет автоматически запустить только те тесты, которые были неудачными (то есть “упали” или “провалились”) при последнем выполнении. Эта возможность значительно упрощает процесс исправления ошибок для разработчиков, позволяя быстро перепроверять решения проблем, не тратя время на повторный запуск уже пройденных успешно тестов.

Когда тесты запускаются с использованием данной опции, система тестирования ищет в своей истории о тестах, которые не прошли в последний раз. Затем, из большого пула тестов, выбираются только те, что были помечены как неудачные, и выполняются снова.

Указание дополнительных фильтров (например с помощью -F) расширяет множество тестов, которое будет запущено. Обычно это требуется, когда вы хотите следить за корректным статусом некоторых тестов, помимо перезапуска упавших от предыдущего прогона.

* Опция `-F=TESTS_FILTERS` или `--test-filter=TESTS_FILTERS` используется для тонкой фильтрации и выборочного запуска тестов в рамках большого тестового набора. Позволяет запускать только определённое подмножество тестов, которые соответствуют конкретным критериям.

Фильтры для тестов задаются в виде строк с использованием [специальных символов и паттернов](https://docs.python.org/3/library/fnmatch.html), таких как астериск (`*`) для обозначения любого количества символов и скобок (`[]`) для указания части имени теста или группы тестов. 

Астериск (`*`) служит шаблоном соответствия любому количеству символов в имени теста. Это позволяет выборочно запускать тесты, имена которых начинаются, заканчиваются или содержат определённые фрагменты.

Примеры: 
 - `-F=*DataTest` запустит все тесты, имена которых завершаются на `DataTest`.
 - `-F=Auth*` запустит все тесты, имена которых начинаются с `Auth`.
 - `-F=*Util*` запустит все тесты, содержащие `Util` в любом месте имени.
Шаблоны взяты в одинарные кавычки для того чтобы shell не развернул фильтр в список файлов, которому может соответствовать шаблон.

Использование скобок (`[]`)

Скобки (`[]`) используются для указания конкретных частей имени теста, которые должны быть соответствующим образом фильтрованы. Это может быть полезно для более точечного указания тестов по их порядковым номерам в рамках определённых групп или для реализации других механизмов выборки.

 Пример:
`-F="[X/Y] chunk"`, `--test-filter="[X/Y] chunk"` — фильтрация тестов по chunk'ам. Внутри `[]` можно использовать `*` для фильтрации.

Применение дать возможность разработчикам или тестировщикам эффективно управлять исполнением только тех тестов, которые актуальны для текущей задачи или для заданного контекста разработки.

* Опции `--style` и `--regular-tests` предоставляют возможность гибко управлять запуском тестов в процессе разработки программного обеспечения, фильтруя тесты на основе их типа: либо тесты стиля кода, либо обычные пользовательские тесты.

 `--style` Запуск тестов стиля кода

Опция `--style` используется для запуска тестов, направленных на проверку соответствия кода установленным стандартам и правилам оформления (стиль, линтинг). Это включает в себя автоматическую проверку форматирования кода, правильности использования синтаксиса и прочих аспектов стиля кодирования. 

При этом, с помощью флага `--strip-skipped-test-deps`, также происходит исключение зависимостей для пропущенных тестов, что оптимизирует процесс выполнения проверки стиля.

Поддерживаемые тесты стиля:
 - `classpath.clash`, `clang_tidy`, `eslint`, `gofmt`, `govet`, `java.style`, `ktlint`, `py2_flake8`, `flake8`, `black`, `ruff` Это инструменты для различных языков программирования (Java, C\+\+, JavaScript, Go, Kotlin, Python и т.д.), каждый из которых предназначен для автоматической проверки соответствия кода заранее определённым стилистическим стандартам и правилам.

`--regular-tests` Запуск пользовательских тестов

В противоположность опции `--style`, флаг `--regular-tests` позволяет запустить только те тесты, которые непосредственно проверяют функционал программного продукта, не затрагивая стилевые проверки. 

Поддерживаемые обычные тесты

`fuzz`, `g_benchmark`, `go_bench`, `go_test`, `gtest`, ` `java`, `jest`, `py2test`, `py3test`, `unittest` и [другие] (https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_typetest.md) - представляют собой различные форматы и фреймворки тестирования для проверки функционала на многих языках программирования, включая С\+\+, Go, Java, Python, JavaScript и т.д.

* Опция `--test-size=TEST_SIZE_FILTERS` используется для запуска тестов, которые соответствуют определённым критериям размера. Эта возможность позволяет более точно контролировать объём и длительность тестирования путём выборочного запуска тестов на основе их классификации по размеру.

Размер тестов обычно определяется исходя из их сложности, времени выполнения и требуемых ресурсов:
 - **SMALL**: Тесты, требующие минимум времени и ресурсов для выполнения. Это обычно unit-тесты, которые проверяют функциональность в изоляции от внешних зависимостей.
 - **MEDIUM**: Тесты, занимающие больше времени и ресурсов, чем small-тесты, и могут включать в себя интеграционные тесты, тестирующие взаимодействие между различными частями системы.
 - **LARGE**: Самые затратные по времени и ресурсам тесты, включая системные, функциональные и E2E-тесты, охватывающие множество компонентов или всю систему в целом.

Используя `--test-size=TEST_SIZE_FILTERS`, можно указать, какие именно тесты следует выполнить. Например, параметр может использоваться для запуска только small-тестов в ранних этапах разработки для быстрой проверки изменений, или для выборочного запуска large-тестов перед релизом продукта.

* Опция `--test-type=TEST_TYPE_FILTERS` предназначена для выполнения фильтрации и выборочного запуска тестов в зависимости от их типа. Эта возможность  полезна в сценариях, когда требуется сосредоточить внимание на конкретном аспекте тестирования, например, при необходимости провести только функциональные тесты или только тесты производительности, не затрагивая другие виды тестов. 

Типом теста называется выполнение проверок с использованием одного конкретного инструмента, например, фреймворка pytest для Python или утилиты проверки форматирования кода go fmt для Golang. Полный список типов тестов приведен в [таблице](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_typetest.md)

* Опция `--test-tag=TEST_TAGS_FILTER` предоставляет возможность запускать конкретные тесты, отмеченные определёнными тегами. 

Теги  используются для категоризации и объединения тестов по различным признакам или характеристикам.

--test-tag=TEST_TAGS_FILTER — запускать только сюиты с определёнными тегами. 

Предположим, что в проекте имеются тесты, относящиеся к разработке новой функциональности и отмеченные тегом `feature/new-ui`. Если разработка этой функциональности идёт активно, и требуется часто запускать именно эти тесты, то команда может выглядеть следующим образом: `ya make -A --test-tag=feature/new-ui`
Такая команда запустит только те тесты, которые отмечены тегом `feature/new-ui`, позволяя сосредоточиться именно на текущей задаче.
Перед именами тегов можно использовать `+` для включения тега в фильтр и `-` для исключения. Таким образом `--test-tag tag1+tag2-tag3` запустит все тесты, у которых есть `tag1`, `tag2` и нет `tag3`. Фильтр `--test-tag -tag3` запустит все тесты без тега tag3. Фильтр `--test-tag ya:anytag` запустит все тесты со всеми тегами.

* Опция `--test-filename=TEST_FILES_FILTER` предоставляет возможность фильтрации и запуска тестов на основе имён файлов, содержащих тестовые сценарии.

Параметр актуален только для тестовых фреймворков, таких как `pytest` и `hermione`, которые поддерживают управление выполнением тестов на уровне отдельных файлов, другие тестовые фреймоврки не предоставляют такой информации.

При использовании `--test-filename=TEST_FILES_FILTER`, система тестирования будет искать тесты только среди тех, что расположены в файлах, имена которых соответствуют переданному шаблону, значительно сокращает объём тестов, подлежащих выполнению, и позволяет сфокусироваться на конкретной части кодовой базы или функциональности.

Примеры использования:
Отбор и запуск тестов, находящихся в файлах с определённым префиксом или постфиксом наименования: `ya make -A --test-filename=prefix_.py` 
Запуск тестов из конкретного набора файлов, имена которых точно указаны: `ya make -A --test-filename=test_module1.py`

* Опция `--test-size-timeout=TEST_SIZE_TIMEOUTS` предназначена для настройки продолжительности тайм-аутов для различных категорий тестов в зависимости от их размера.
Тесты классифицируются на несколько категорий (“small”, “medium”, “large”) на основе их ожидаемой продолжительности выполнения и ресурсных требований.
По умолчанию, тайм-аут теста для каждого размера в секундах (small=60, medium=600, large=3600)

Опция `--test-size-timeout` позволяет явно указать максимально допустимое время выполнения для каждой из этих категорий.

Формат значения `TEST_SIZE_TIMEOUTS`  следует шаблону `small=SECONDS, medium=SECONDS, large=SECONDS`, где `SECONDS` задаёт максимально допустимое время выполнения в секундах для тестов соответствующего размера.

Этот пример `–test-size-timeout=small=30,medium=300,large=1800` устанавливает тайм-ауты в 30 секунд для small-тестов, в 300 секунд для medium-тестов и в 1800 секунд для large-тестов.
## Отчет в консоли
* Опция `-P` или `--show-passed-tests` предназначена для вывода детальной информации о тестах, которые были успешно пройдены во время текущего запуска тестового набора. 

В стандартном режиме выполнения тестов сконцентрировано на сообщениях о неудачных тестах, поскольку именно они требуют внимания разработчиков для диагностики и исправления обнаруженных проблем. 

Успешно пройденные тесты часто остаются без дополнительного внимания, и результаты их выполнения выводятся в общем виде, например, в виде общего количества пройденных тестов.

Запуск тестов с отображением результата каждого пройденного теста может выглядеть так:
`ya make -A -P` или `ya make -A --show-passed-tests`

* Опция `--inline-diff`влияет на форматирование и представление различий (diff) между ожидаемыми и фактическими результатами, которые возникают при неудачном прохождении теста.

Включение `--inline-diff` обеспечивает более детальное и удобочитаемое отображение этих различий прямо в выводе в терминале, предоставляя построчное сравнение с подсветкой конкретных изменений или различий.

* Опция `--show-metrics` предназначена для отображения метрик тестирования в консоли в процессе выполнения тестов. 

Метрики тестирования могут включать в себя различную информацию, такую как время выполнения теста, использование памяти, количество запросов к базе данных, производительность API и другие значимые данные, которые помогают оценить не только корректность работы программного обеспечения, но и его эффективность.

При использовании этой опции, после завершения каждого теста или группы тестов, в выводе в консоль будут показаны собранные метрики для них. 

Чтобы увидеть метрики для успешно пройденных тестов, необходимо также использовать опцию `-P` (`--show-passed-tests`). Это связано с тем, что по умолчанию  в консоль выводиться информацию только о проваленных тестах, ограничивая вывод для успешных тестов общим итогом их количества. 

Опция `-P` показывает детальную информацию о каждом выполненном тесте, включая успешно пройденные, и, соответственно, когда используется вместе с `--show-metrics`, позволяет видеть собранные метрики и для успешных тестов.

`ya make -A -P --show-metrics` -  при выполнении каждого теста в консоль выводились детали по пройденным и не пройденным тестам, а также метрики, связанные с каждым из этих тестов.

* Опция `--disable-flake8-migrations` является настройкой, используемой в контексте тестирования и проверки кода с помощью утилиты `flake8`.

Все python-файлы, используемые в сборке и тестах, подключаемые через `ya.make` в секциях `PY_SRCS` и `TEST_SRCS`, автоматически проверяются линтером `flake8`. 

Он помогает идентифицировать ошибки стиля, сложности кода и потенциальные баги, проверяя код на соответствие рекомендациям PEP 8 и другим общепринятым стандартам написания кода.

`flake8` предоставляет возможность исключения или временного отключения определённых проверок (линтов), которые могут быть не всегда релевантны или предпочтительны для конкретных проектов или стадий разработки. Функциональность “миграций `flake8`” (также известная как “включение или отключение проверок `flake8`”) позволяет поэтапно вводить или исключать различные проверки для облегчения процесса адаптации кодовой базы к строгим стандартам.

Опция `--disable-flake8-migrations` используется для явного указания инструмента `flake8` игнорировать все настройки миграций (`flake8` migrations), которые могли быть определены разработчиками или командой проекта для поэтапного введения или отключения конкретных правил проверки. Эта опция “включает все проверки `flake8`”, тем самым применяя полный набор доступных проверок стиля и качества кода без исключения. 

В процессе разработки или при подготовке кода к финальной проверке перед слиянием в основную ветку проекта, разработчик может использовать эту опцию для гарантии того, что весь код полностью соответствует стандартам и рекомендациям.

 `ya make -A --disable-flake8-migrations path/to/module.py` 

Эта команда выполнит `flake8` проверку для файла `module.py`, применив ко всему коду полный набор правил без учёта ранее заданных миграций.

* Опция `--disable-jstyle-migrations` предназначена для использования в среде разработки Java и управляет применением проверок стиля кода.

Цель данной опции — включение всех доступных проверок стиля для Java кода, игнорируя любые ранее заданные “миграции” или исключения. 
В контексте стилевых проверок “миграции” часто используются для поэтапного внедрения новых стандартов стиля кодирования или для временного отключения определённых правил в процессе рефакторинга или при внесении значительных изменений в кодовую базу.

Для включения всех стилевых проверок Java в процессе тестирования или проверки кода, разработчик может добавить эту опцию в командную строку используемого инструмента анализа кода или сборки, например: `ya make -A --disable-jstyle-migrations`

## Канонизация
Канонизация тестов - это процесс объединения и стандартизации различных версий тестовых случаев, чтобы устранить возможные дубликаты и противоречия. Она также включает в себя подтверждение того, что каждый тестовый случай соответствует установленным стандартам и правилам создания тестов. 

* Опция `-Z` или `--canonize-tests` предназначена для канонизации результатов выполнения тестов.

Канонизация позволяет зафиксировать текущие результаты выполнения теста в качестве правильных (эталонных), с которыми в дальнейшем будет сравниваться вывод теста при его повторных запусках.

Тесты описываются в ya.make файлах в макросе `RUN`, где можно указать путь до файла с эталонными данными с помощью `CANONIZE_LOCALLY`:
```
OWNER(g:some-group)

EXECTEST() # Объявляем Exec-тест

RUN( # Команда, которую хотим выполнить
    cat input.txt
CANONIZE_LOCALLY ${TEST_CASE_ROOT}/test.out # Путь до файла с эталонными данными (будет сохранен в подкаталог canondata)
CANONIZE_DIR_LOCALLY ${TEST_CASE_ROOT}/dir # Путь до директории с эталонными данными (будет сохранен в подкаталог canondata)
)

DATA( # Тестовые данные (здесь лежит input.txt)
    path/devtools/ya/test/tests/exectest/data
)

# Текущий каталог для теста (каталог с input.txt)
TEST_CWD(path/devtools/ya/test/tests/exectest/data)

END()
```
В режиме ` -Z (--canonize-tests)` вместо сравнения данных с эталонными, сами эталонные данные будут заменены.  В локальное рабочее пространство будут внесены все необходимые изменения.

* Опция `--canon-diff=TEST_DIFF` используется для того, чтобы сравнить канонические данные тестов между различными состояниями кодовой базы. Это позволяет разработчикам и тестировщикам увидеть, как изменения в коде повлияли на результаты тестов, и помогает выявить регрессии или непреднамеренные эффекты от внесенных изменений.

Возможные значения для `TEST_DIFF` включают `rev1:rev2`, `HEAD`, и `PREV.
 * `--canon-diff=rev1:rev2`: Сравнить канонические данные между ревизиями `rev1` и `rev2`.
 * `--canon-diff=HEAD`: Сравнить текущие канонические данные с данными последней ревизии в текущей ветке.
 * `--canon-diff=PREV`: Сравнить канонические данные текущего состояния с данными состояния перед последним коммитом.

Для того, чтобы посмотреть, как менялся канонический результат теста, нужно прогнать конкретный тест в режиме `--canon-diff` командой `ya make -t --canon-diff PREV`.

Можно передать имя теста через параметр `-F(--test-filter)`, для этого можно сначала вывести список тестов в текущей папке `path/ya make -t --canon-diff HEAD -L`

* Опция `--canonize-via-http` предназначена для использования в процессе канонизации тестов, когда необходимо загрузить большие объемы канонических данных. Опция указывает системе, что для загрузки этих данных следует использовать протокол HTTP.

## Отладка
* Опция `--pdb` используется в контексте выполнения тестов, написанных на Python, и предназначена для автоматического запуска отладчика Python (pdb - Python Debugger) в случае возникновения ошибок во время выполнения теста.

Это позволяет разработчикам немедленно перейти к отладке проблемы, не прерывая процесс тестирования.

Чтобы передать управление `pdb` в произвольном месте, можно написать в коде `import pdb; pdb.set_trace()`, для `Python 3` можно использовать более короткий вариант `breakpoint()`.

Для активации `pdb` при возникновении ошибок, добавьте `--pdb` к команде запуска: `ya make -ttt --pdb`

Если во время выполнения произойдет ошибка, выполнение тестов остановится, и вы автоматически войдете в интерактивную сессию `pdb`. В этой сессии можно будет использовать команды `pdb`, такие как `list` для просмотра кода, `where` для просмотра стека вызовов, `next` и `step` для шагов выполнения кода, и `print` для вывода значений переменных.

* Опция `--gdb` позволяет автоматически запустить Python-тесты в среде GNU Debugger (GDB), когда это необходимо.
При этом `GDB` получит управление перед запуском тестов, а `pdb` только при срабатывании проверки.

Пример использования `ya make -ttt --gdb`

* Опция `--dlv` используется для запуска тестов для языка программирования Go и позволяет автоматически запустить тесты в отладчике `Delve` (dlv).

`Delve` является отладчиком для Go программ, предоставляющим возможности для пошагового выполнения кода, просмотра состояния переменных, управления точками останова и других действий, необходимых для детального анализа выполнения программы и поиска ошибок.

* Опция `--test-debug` предназначена для использования в процессе тестирования программного обеспечения, обеспечивая разработчикам расширенные возможности для отладки тестов. Эта опция включает ряд параметров, оптимизирующих процесс запуска тестов для удобства отладки, и предоставляет дополнительную информацию, полезную при диагностике проблем.

При использовании опции `--test-debug`, система тестирования автоматически применяет несколько дополнительных параметров к процессу выполнения тестов:

 1. **–test-threads=1**: Устанавливает количество потоков (threads) для выполнения тестов равным 1. Это означает, что все тесты будут выполняться последовательно, один за другим. Последовательное выполнение упрощает процесс отладки, поскольку исключает возможные проблемы, связанные с параллельным выполнением тестов, такие как состояние гонки (race condition).
 2. **–test-disable-timeout**: Отключает тайм-ауты для тестов. Это позволяет избежать автоматического прерывания теста по истечении времени выполнения, что важно при отладке, когда разработчику может потребоваться больше времени для анализа состояния программы или выполнения дополнительных действий в отладчике.
 3. **–retest**: Принудительно повторно выполняет все тесты, даже если они не были изменены. Это гарантирует, что при каждом использовании `--test-debug` тесты будут запущены, независимо от результатов предыдущих запусков.
 4. **–test-stderr**: Перенаправляет стандартный поток ошибок (stderr) тестов в стандартный вывод (stdout) или делает его видимым в выводе тестов. Это обеспечивает, что все сообщения об ошибках, предупреждения и другая диагностическая информация, выводимая тестами, будут непосредственно доступны для анализа.

Помимо вышеупомянутых настроек, опция `--test-debug` также печатает идентификатор процесса (PID) каждого запущенного теста. Эта информация может быть полезна для прикрепления отладчика к конкретному процессу теста для детального анализа его выполнения в реальном времени.

* Опция `--dlv-args=DLV_ARGS` предназначена для использования в контексте запуска Go юнит-тестов в отладчике `Delve` (dlv) и позволяет передать дополнительные аргументы командной строки непосредственно в `Delve`.

Когда вы используете `--dlv` для запуска тестов в `Delve`, `--dlv-args=DLV_ARGS` позволяет уточнить поведение `Delve`, добавив специфические для отладчика параметры. Это может включать в себя настройки логирования, управления сессией отладки, опции для точек останова и другие возможности `Delve`, которые могут быть полезны для конкретной задачи отладки.

* Опция `--test-retries=TESTS_RETRIES` предоставляет возможность автоматически повторять выполнение тестов, которые завершились неудачно, указанное количество раз (по умолчанию: 1).

Эта функциональность чрезвычайно полезна в ситуациях, когда тесты могут иногда завершаться сбоем из-за нестабильных условий окружающей среды, временных проблем с сетью, ресурсами системы или другими внешними факторами, не связанными напрямую с логикой тестируемого программного обеспечения.

При запуске тестов с использованием этой опции, система тестирования выполнит все указанные тесты и отслеживает те из них, которые завершились неудачно. 

Если какой-либо тест не прошел успешно, система автоматически попытается повторить его выполнение. Количество повторений для каждого неудачного теста задается значением `TESTS_RETRIES`. Например, если указано `--test-retries=2`, то каждый тест, который не прошел, будет автоматически повторен до двух раз в дополнение к его первоначальному запуску.

Предположим, вы работаете над проектом и хотите автоматически повторять неудачные тесты до трех раз в случае их сбоя. Для этого вы можете использовать следующую команду: `ya make -A --test-retries=3`

Эта команда запустит тестовый набор и, в случае неудачи любого теста, попытается повторить его выполнение до трех раз. Если тест проходит успешно в одной из попыток, он считается пройденным и система переходит к следующему тесту.

* Опция `--test-stderr`  предназначена для того, чтобы выводить стандартный поток ошибок (stderr) тестов непосредственно в консоль в реальном времени. Это позволяет разработчикам и тестировщикам наблюдать за всеми сообщениями об ошибках, предупреждениями и другой важной диагностической информацией, генерируемой тестами, без необходимости ожидания завершения всего набора тестов или изучения лог-файлов после их выполнения.

`ya make -t --test-stderr` - команда активирует вывод stderr тестов в консоль, позволяя вам наблюдать за возможными сообщениями об ошибках в режиме реального времени.

* Опция `--test-stdout` позволяет выводить стандартный поток вывода (stdout) тестов непосредственно в консоль в реальном времени. Это дает возможность разработчикам и тестировщикам наблюдать за всеми сообщениями, логами и другой информацией, генерируемой тестами, сразу же во время их выполнения.

Когда тесты запускаются с использованием этой опции, система тестирования перенаправляет все, что тесты пишут в стандартный поток вывода (stdout), непосредственно в консоль или терминал, из которого были запущены тесты.

Допустим, вы работаете над проектом и хотите запустить тесты, при этом видеть результаты выполнения тестов (вывод тестов) в консоли в реальном времени. Использование опции `--test-stdout` может выглядеть так: `ya make -ttt --test-stdout`

Эта команда заставит тестовую систему выводить в консоль все сообщения из stdout каждого теста, позволяя вам отслеживать ход выполнения тестов и немедленно реагировать на возникающие проблемы или ошибки.

* Опция `--test-disable-timeout` позволяет отключить механизм тайм-аута для тестов.

Это означает, что тесты не будут автоматически прерваны системой тестирования, если они превышают определенное время выполнения. 

В обычных условиях, `ya make` имеет настройку тайм-аута, чтобы ограничить максимальное время выполнения каждого теста. Это предотвращает “зависание” тестов и обеспечивает более эффективное использование ресурсов тестовой среды. Тайм-аут может быть задан глобально для всего набора тестов или индивидуально для каждого теста.

При использовании опции `--test-disable-timeout`, механизм тайм-аута отключается, и тесты могут выполняться неограниченное время. 

Опция `--test-disable-timeout` предназначена для использования толтко в локальной среде разработки и не рекомендуется к использованию при распределенном выполнении тестов (`--dist`).

Также эта опция несовместима с опцией `--cache-tests`, которая предполагает кеширование результатов тестов для ускорения последующих запусков.
 
* Опция `--test-binary-args=TEST_BINARY_ARGS` обеспечивает возможность передачи произвольных аргументов командной строки непосредственно в исполняемый файл теста (тестовый бинарный файл). Это позволяет настраивать поведение тестов на более глубоком уровне, используя механизмы, предусмотренные в самом тестовом приложении.

При запуске тестов с использованием этой опции, указанные аргументы (`TEST_BINARY_ARGS`) будут переданы в исполняемый файл теста как аргументы командной строки. Тестовое приложение может затем обрабатывать эти аргументы согласно своей внутренней логике, позволяя влиять на различные аспекты его выполнения.

Предположим, что ваше тестовое приложение поддерживает аргумент командной строки `--config`, который позволяет указать путь к файлу конфигурации. Вы хотите запустить тесты с использованием конкретного конфигурационного файла. Для этого вы можете использовать следующую команду: `ya make -A --test-binary-args=“–config=/path/to/config/file”`

В этом примере, аргумент `--config=/path/to/config/file` будет передан непосредственно в исполняемый файл теста, позволяя тестам использовать указанный файл конфигурации.

* Опция `--dump-test-environment` позволяет получить детальный снимок содержимого корня сборки теста, организованного в формате дерева, и записать эту информацию в файл `run_test.log` перед фактическим выполнением обертки теста.

При запуске тестов с этой опцией, система тестирования автоматически генерирует представление файловой структуры корневого каталога сборки теста в виде дерева. Это представление включает в себя все файлы, директории и их вложенные элементы, доступные в момент запуска теста. Сгенерированная информация затем записывается в файл `run_test.log`, который можно использовать для последующего анализа.

Допустим, вы столкнулись с проблемой, когда тест неожиданно не проходит из-за отсутствия определенного файла конфигурации в среде выполнения. Чтобы диагностировать эту проблему, вы можете запустить тесты с опцией `--dump-test-environment`, чтобы получить полное представление о содержимом корня сборки.

После выполнения тестов вы можете открыть файл `run_test.log` и изучить структуру директорий и файлов, доступных во время тестирования. Это поможет вам определить, отсутствует ли необходимый файл конфигурации или возможно он расположен в неправильном месте.

* Опция `--no-random-ports` используется для запуска сетевых тестов, которым требуются конкретные порты для их выполнения.

Использование опции `--no-random-ports` позволяет явно указать системе тестирования использовать порты, заданные разработчиком. 

Это дает разработчикам контроль над сетевыми настройками тестовой среды и упрощает интеграцию тестов с определенными сетевыми условиями или конфигурациями.

* Опция `--disable-test-graceful-shutdown` используется для управления поведением тестового процесса в случае возникновения тайм-аута. Эта опция указывает системе тестирования, что в случае превышения заданного времени выполнения теста, тестовый процесс (узел теста) должен быть немедленно прекращен (“убит”) без попытки его “мягкой” остановки или корректного завершения.

Когда тест превышает заданное время выполнения (тайм-аут), система пытается корректно завершить тестовый процесс, давая ему возможность освободить занятые ресурсы, закрыть открытые соединения и корректно завершить работу. 

Это называется “мягким” завершением работы или “graceful shutdown”. Однако, в некоторых случаях, такое поведение может быть не предпочтительным или неэффективным, например, если процесс теста “завис” и не реагирует на попытки его корректного завершения.

Использование опции `--disable-test-graceful-shutdown` отключает механизм “мягкого” завершения работы тестового процесса. Вместо этого, в случае возникновения тайм-аута, система тестирования немедленно отправляет сигнал на принудительное завершение процесса, что обычно приводит к его мгновенному прекращению.

## Среда выполнения
* Опция `--test-param=TEST_PARAMS` предоставляет возможность передачи произвольных параметров непосредственно в тесты, передавая в них параметры из командной строки.

При использовании этой опции, вы можете передать один или несколько параметров в формате `name=val`, где `name` — это имя параметра, а `val` — его значение. Эти параметры будут доступны внутри тестов, позволяя изменять их поведение в зависимости от переданных значений.

Пример использования: `ya make -t --test-param db_endpoint=localhost:1234`

* Опция `--autocheck-mode` предназначена для запуска тестов в локальной среде с набором ограничений, характерных для среды autocheck.

Включение `--autocheck-mode` автоматически активирует несколько ключевых ограничений и настроек:

 1. **–private-ram-drive**: Создает изолированный RAM-диск для каждого теста, что позволяет избежать взаимного влияния тестов друг на друга из-за файловой системы и гарантирует, что файлы, созданные или измененные одним тестом, не будут видны или доступны другим тестам. Это способствует повышению изоляции и надежности тестов.

 2. **–private-net-ns**: Использует изолированное сетевое пространство имен для каждого теста, обеспечивая, таким образом, что сетевые операции, выполняемые в рамках одного теста, не влияют на другие тесты. Это особенно важно для тестов, которые предполагают взаимодействие с сетью или определенные сетевые настройки.

* Опция `--private-ram-drive`  создавает для каждого тестового узла частный RAM-диск. 

При активации этой опции система сборки автоматически создает виртуальный диск в оперативной памяти (RAM-диск) для каждого узла тестирования, который его запрашивает. Все операции чтения и записи в рамках теста производятся на этом RAM-диске. Поскольку оперативная память обеспечивает значительно более высокую скорость чтения и записи данных по сравнению с традиционными жесткими дисками или даже SSD, использование RAM-диска может существенно сократить время, необходимое для выполнения операций ввода-вывода, и, как следствие, ускорить выполнение тестов.

* Опция `--private-net-ns` предназначена для создания изолированного сетевого пространства имен (network namespace) для каждого запускаемого теста.

Особенностью создаваемого сетевого пространства имен является поддержка `localhost`, что позволяет тестам взаимодействовать с сервисами, запущенными на локальной машине, но при этом изолировать их сетевые взаимодействия друг от друга.

## Расчет UID теста

* Опция `--cache-tests` позволяет сохранять результаты успешно выполненных тестов в кеше и при последующих запусках тестов избегать повторного выполнения тех, результаты которых уже присутствуют в кеше и считаются актуальными.

Когда эта опция активирована, система тестирования выполняет следующие действия:

 1. **Проверка Кеша**: Перед выполнением теста система проверяет наличие его результатов в кеше.
 2. **Пропуск Тестов**: Если результаты теста уже присутствуют в кеше и считаются валидными (то есть код, связанный с тестом, не был изменен с момента последнего успешного выполнения), тест пропускается.
 3. **Выполнение и Кеширование**: Тесты, для которых в кеше нет актуальных результатов, выполняются, а их результаты после успешного завершения сохраняются в кеше для использования в будущих запусках.

Все style-тесты по умолчанию кешируются, что эквивалентно команде `ya make - ttt --style --cache-tests`. 
Это значит, что при перезапуске `ya make` без изменения исходного кода style-тесты не будут перезапускаться, а вернут результат из кеша. Это сделано для ускорения локального прогона style-тестов, которые являются быстрыми и стабильными. Для принудительного перезапуска тестов нужно добавить ключ `--retest`.

* Опция `--retest` предназначена для принудительного повторного выполнения всех тестов, игнорируя любые результаты, которые могли быть сохранены в кеше от предыдущих запусков. Это значит, что независимо от того, был ли тест успешно выполнен ранее и его результат сохранен в кеше, при использовании этой опции система тестирования выполнит тест заново.

Когда тесты запускаются с использованием опции `--retest`, механизм кеширования результатов тестов игнорируется. Система тестирования будет вести себя так, как если бы она запускалась в первый раз, без доступа к предыдущим результатам. Все тесты в наборе запускаются заново, и их результаты обновляются в соответствии с текущим состоянием кодовой базы и тестовой среды.

## Зависимости тестов

* Опция `-b` или `--build-all`  указывает системе сборки собрать все цели, которые могут быть достигнуты через директивы `RECURSE` в `ya.make` файле, даже если эти цели не требуются непосредственно для запуска текущих тестов.

При вызове системы сборки с опцией `-b` или `--build-all`, система анализирует `ya.make` файлы на предмет директив `RECURSE`, прослеживая все возможные пути сборки до каждого компонента проекта.

Это включает в себя все библиотеки, программы, тесты и прочие цели, которые можно собрать. В результате, процесс сборки охватывает весь проект в полном объеме, не ограничиваясь только требуемыми для тестирования компонентами.

Предположим, у вас есть проект со множеством модулей, и вы хотите убедиться, что недавно внесенные изменения не поломали сборку других не связанных напрямую с тестами компонентов. Вызывая команду: `ya make -t -b` вы инициируете полную сборку проекта, что позволит обнаружить и предотвратить возможные проблемы. 

* Опция `--build-only-test-deps`  позволяет оптимизировать процесс сборки, фокусируясь исключительно на тех компонентах системы, которые необходимы для выполнения заданных тестов. 

При запуске системы сборки с этой опцией, механизм сборки проанализирует зависимости тестов, которые были запрошены для выполнения. Включение только необходимых для тестов зависимостей позволяет исключить из сборочного процесса все лишнее, что не имеет отношения к текущему тестовому прогону.

Вместо того, чтобы следовать всем путям в директивах `RECURSE` и собирать весь проект полностью, система сборки сфокусирована только на той части проекта, которая действительно используется в тестах.

Предположим, разработчик внес изменения в модуль и хочет запустить только тесты, относящиеся к этому модулю, не собирая остальную часть проекта. В этом случае команда для сборки и тестирования будет выглядеть так:

 `ya make -t --build-only-test-deps path_to_tests`

Здесь `path_to_tests` – это идентификатор или путь к тестам, которые необходимо выполнить. Система сборки выполнит анализ, определит, какие компоненты проекта требуются для выполнения данного набора тестов, и соберет только их.

* Опция `--strip-skipped-test-deps` позволяет исключить из процесса сборки зависимости тех тестов, которые по тем или иным причинам будут пропущены. 

Это означает, что система сборки не будет тратить время и ресурсы на подготовку тестов и их зависимостей, которые итак не будут выполнены.

* Опция `--strip-idle-build-results` позволяет системе сборки удалить результаты сборки, которые в конечном итоге не используются непосредственно для запуска тестов. 

Когда вы запускаете систему сборки с включенной опцией `--strip-idle-build-results`, в процессе сборки система отслеживает, какие именно результата сборки требуются для успешного выполнения заданных тестов. По завершении процесса сборки, вся информация о “лишних” узлах, которые не связаны с запуском тестов — удаляется.

* Опция `--no-strip-idle-build-results` указывает сохранить все результаты сборки, включая те, которые не нужны для прямого запуска тестов. Эта опция является противоположностью к `--strip-idle-build-results`, о которой шла речь ранее.

Применяется при полной сборке проекта (включая все модули и тесты) для проведения комплексной проверки перед релизом. В этом случае команда сборки может быть запущена с опцией `--no-strip-idle-build-results`, что гарантирует сохранение всех результатов сборки.

Синтаксис: `ya make -A --no-strip-idle-build-results`

## Отчеты в файлах

* Опция `--junit=JUNIT_PATH` предназначена для генерации отчёта о результатах выполнения тестов в формате JUnit.

При запуске тестов с указанием этой опции, система сборки выполняет все запрашиваемые тесты, а затем агрегирует информацию о прохождении каждого теста, результаты (удачные и неудачные исполнения), время выполнения и возможные сообщения об ошибках в один отчет в формате XML, соответствующем спецификации JUnit.

`JUNIT_PATH` здесь — это путь к файлу, куда будет записан сгенерированный отчет.

Предположим, что вы разрабатываете проект и используете систему сборки для запуска тестов. Вы хотите получить отчет о результатах тестирования в формате JUnit для интеграции с Jenkins. В этом случае вы можете добавить опцию в вашу команду запуска тестов следующим образом: `ya make -t --junit=/pat_to_your_project/test-results/results.xml`

После выполнения команды в указанном месте будет создан файл XML с отчетом о результатах тестирования в формате JUnit, который затем может быть импортирован в Jenkins или любую другую систему, поддерживающую анализ JUnit отчетов.

## Выходные данные теста

* Опция `--no-test-outputs`  используется для контроля над сохранением выводов тестов, а именно файлов и данных, которые тесты могут генерировать в процессе их выполнения. 

Опция `--no-test-outputs` представляет собой директиву системе сборки, указывающую не сохранять вышеупомянутые файлы и данные, созданные во время тестирования. 

 `ya make -t --no-test-outputs` - в этом случае система сборки выполнит все запрашиваемые тесты, но не сохранит никаких файлов, созданных в процессе их выполнения.

* Опция `--dir-outputs-in-nodes`  обеспечивает поддержку директорий в качестве выходных данных узлов сборки. Это означает, что при включении этой опции система сборки может обрабатывать целые директории как результат выполнения задачи сборки, а не только отдельные файлы.

В обычном режиме работы системы сборки каждый узел (или задача сборки) генерирует один или несколько файлов в качестве выходных данных. 

`ya make --dir-outputs-in-nodes /path/to/source/images/directory /path/to/destination/optimized/images/directory`

В этом случае система сборки обработает генерацию оптимизированных изображений, рассматривая всю директорию `/path/to/destination/optimized/images/directory` как выходной результат работы узла, а не каждый файл по отдельности.

* Опция `--test-node-output-limit=TEST_NODE_OUTPUT_LIMIT` используется для установления ограничения на максимальный размер файлов вывода, которые генерируются в процессе выполнения тестов.

Это позволяет контролировать объём данных, сохраняемых после работы тестов, важно для управления использованием дискового пространства, особенно в условиях ограниченных ресурсов или при работе с большим количеством тестов.

При выполнении теста система сборки отслеживает размер файлов вывода, генерируемых каждым тестовым узлом. Если объём данных превышает установленный лимит `TEST_NODE_OUTPUT_LIMIT`, указанный в байтах, система может обрезать эти файлы до указанного размера или же не сохранять часть вывода, превышающую этот лимит. В результате, для каждого теста сохраняется лишь наиболее важная часть вывода, позволяя снизить потребление ресурсов хранения.

* Опция `--test-keep-symlinks` разработана для управления сохранением символических ссылок, которые возникают в ходе выполнения тестов. При использовании этой опции система сборки не будет удалять символические ссылки из выходных данных теста, что может быть полезно в различных сценариях разработки и тестирования.

Символические ссылки (или симлинки) — это файлы, которые указывают на другие файлы или директории в файловой системе. Они могут использоваться в процессе тестирования для имитации определённых структур файловой системы, обращения к файлам без копирования реального содержимого или создания контролируемых условий тестовой среды.

При запуске тестов с этой опцией система сборки изменяет своё стандартное поведение таким образом, чтобы символические ссылки, созданные в процессе выполнения тестов, не удалялись после их завершения. Это означает, что вся структура директорий, файлы и симлинки, созданные или использованные тестами, будут сохранены в их исходном виде, давая возможность для последующего анализа или использования.

## Покрытие кода

Покрытие кода в системах сборки — это метрика, используемая для измерения степени, в которой исходный код программы испытан автоматическими тестами. Она выражается в процентах и показывает, какая часть кода была выполнена при запуске тестов, помогая определить не протестированные участки кода.

* Опция --coverage-verbose-resolve управляет выводом детальных отладочных логов во время процесса разрешения данных о покрытии, то есть на этапе, когда анализируются собранные данные о покрытии, обрабатываются файлы покрытия и готовится итоговый отчет о покрытии кода тестами.

* Опция `--merge-coverage` используется для объединения всех найденных данных о покрытии, обычно распределенных по разным файлам, в единый совокупный файл покрытия. Это позволяет агрегировать информацию о покрытии кода из разных источников или тестовых прогонов в один удобный для анализа документ.

* Опция `--coverage-report-path=COVERAGE_REPORT_PATH` используется для указания конкретного пути относительно каталога вывода (output directory), куда будет сохранен отчет о покрытии кода. 

* Опция `--enable-contrib-coverage` предназначена для расширения процесса сбора данных о покрытии кода в проектах, зависящих от внешних библиотек или компонентов, загруженных из каталога `contrib` в системе сборки. Эта опция влияет на то, как собираются эти внешние компоненты и какие дополнительные действия выполняются для генерации данных о покрытии кода этими компонентами.

* Опция `--fast-clang-coverage-merge` используется при сборке и запуске тестов с поддержкой покрытия кода, в частности, когда осуществляется сбор информации о покрытии `Clang source-based coverage`. Данная опция предназначена для оптимизации процесса мержа (объединения) профилей покрытия, собранных во время выполнения различных тестов или исполняемых файлов.

Опция `--fast-clang-coverage-merge` использует FUSE (Filesystem in Userspace) механизм для того, чтобы процедура обьединения происходила “на лету”, прямо во время выполнения тестов, что значительно ускоряет процесс. FUSE позволяет создавать виртуальные файловые системы, управляемые пользовательскими программами. В контексте объединения профилей покрытия это означает, что вместо физического создания промежуточных файлов профилей на диске, все операции с профилями происходят в памяти. Это позволяет минимизировать затраты на ввод/вывод и ускорить подготовку итогового отчета о покрытии.

* Опция `--sancov` представляет собой параметр системы сборки, который активирует сбор данных о покрытии кода при помощи инструментов санитайзеров (Sanitizers). 

Санитайзеры — это инструменты, обеспечивающие динамический анализ кода для выявления различных видов ошибок, таких как обращения за границы массивов, использование неинициализированной памяти и других.

При использовании опции `--sancov`, основное внимание уделяется построению отчетов о покрытии кода на основе анализа, проведенного данными инструментами.
Время тестов увеличивается в 1.5 раза.

* Опция `--coverage-exclude-regexp=COVERAGE_EXCLUDE_REGEXP`  позволяет явно указать регулярное выражение (regexp) на 
соответствующие типы файлов, которые следует исключить из отчета о покрытии кода. 

При активации этой опции и выполнении тестов с параллельным сбором данных о покрытии кода, система сборки применит заданное регулярное выражение для фильтрации типов файлов и они будут исключены из финального отчета о покрытии кода. 

* Опция `--coverage-prefix-filter=COVERAGE_PREFIX_FILTER` предназначена для фильтрации для создания отчета о покрытии, например, `devtools/ya` - если интересует покрытие только определенных участков репозитория.

* Опция `--coverage-report` используется для создания подробного отчёта о покрытии кода в формате HTML, который является визуальным и удобным средством для анализа покрытия кода тестами.

* Опция `--clang-coverage`  используется для активации сбора информации о покрытии кода (code coverage) для проектов с использованием компилятора Clang. (Автоматически увеличивает время выполнения в полтора раза)

* Опция `--java-coverage`  предназначена для сбора данных о покрытии кода в проектах на языке программирования Java.

Допустим, вы разрабатываете Java-проект и хотите убедиться в том, что ваши тесты покрывают достаточный объем кода. В этом случае вы бы использовали команду сборки с опцией `--java-coverage`, чтобы активировать сбор данных о покрытии:

`ya make -t --java-coverage`

После выполнения тестов система сборки сгенерирует отчет о покрытии кода, который вы можете просмотреть, чтобы оценить эффективность текущих тестов и определить области кода без достаточного покрытия.

* Опция `--go-coverage` в системе сборки применяется для сбора информации о покрытии кода в проектах, написанных на языке программирования Go. 

* Опция `--ts-coverage` в системе сборки служит для сбора информации о покрытии кода специально для проектов на TypeScript.

* Опция `--python-coverage` используется для сбора информации о покрытии кода для проектов, написанных на Python, в рамках процесса тестирования. 

Если, ваш проект содержит множество Python модулей, и вы хотели бы получить общее представление о покрытии кода тестами, запустите следующую команду в системе сборки: `ya make -t --python-coverage`

После выполнения тестов система сборки генерирует отчет о покрытии кода, который можно анализировать для дальнейших улучшений в тестовом покрытии.

## Fuzzing (методика фаззинга)

* Опция `--fuzzing` используется для активации процесса фаззинга, то есть автоматического тестирования приложения или его компонентов путем подачи на вход большого количества случайных, некорректных или неожиданных данных. 

Цель фаззинга - выявление ошибок, уязвимостей или нестабильностей в работе тестируемого кода, которые могут проявляться при непредвиденных условиях ввода.

* Опция `--fuzz-case=FUZZ_CASE_FILENAME` предназначена для указания конкретного тестового случая (case) или файла с данными, который будет использоваться при фаззинге тестируемого компонента или приложения. Эта опция предназначена для ситуаций, когда необходимо запустить фаззер с конкретным набором данных, а не позволять ему генерировать данные случайным образом, как это происходит в режиме стандартного фаззинга (`--fuzzing`).

* Опция `--fuzz-opts=FUZZ_OPTS` представляет собой  способ настройки процесса фаззинга за счет предоставления возможности напрямую передавать специальные параметры или опции в инструмент фаззинга. Эти параметры могут контролировать поведение фаззера, например, изменяя стратегию генерации данных, устанавливая ограничения времени или памяти на исполнение.

Запуск опции `--fuzz-opts="-max_total_time=7200"` стартует процесс фаззинга, который будет длиться 2 часа (7200 секунд). В течение этого времени фаззинг инструмент будет генерировать и тестировать случайные входные данные для поиска ошибок или необычного поведения в коде. Если будут найдены интересные случаи, они будут автоматически закоммичены в корпус соответствующего проекта, что позволит фиксировать и анализировать эти случаи для дальнейшей отладки и улучшения программы.

* Опция `--fuzz-minimization-only` запускает процедуру минимизации корпуса без фаззинга. Опцию следует использовать в паре с `--fuzzing`

* Опция `--fuzz-local-store` используется для сохранения результатов локально на машине, где выполняется тест.

* Опция `--fuzz-runs=FUZZ_RUNS` включает автоматическую генерацию входных данных для программы в целях обнаружения ошибок обработки этих данных.

`ya make -t --fuzzing --fuzz-runs=10000` - процесс фаззинга будет ограничен 10,000 индивидуальными запусками тестов (`--fuzz-runs=10000`).

* Опция `--fuzz-proof=FUZZ_PROOF` служит для выполнения особого этапа фаззинга — доказательства стабильности корпуса (corpus), т.е. подтверждения высокого уровня покрытия кода имеющимся корпусом.

Параметр `FUZZ_PROOF` задается в секундах и определяет продолжительность дополнительного этапа фаззинга, начиная с момента обнаружения последнего интересного (приводящего к новому поведению программы) случая тестовых данных.

Это означает, что если в течении указанных секунд с момента обнаружения последнего кейса (или с начала фаззинга, если не было найдено ни одного нового кейса в текущем запуске) будет найден хотя бы один новый - это приведёт к завершению фаззинга с ошибкой. Все найденные кейсы будут сохранены в корпусе.

`ya make -r --sanitize=address --sanitize-coverage=trace-div,trace-gep --fuzzing -A --fuzz-opts="-max_total_time=3600" --fuzz-proof=1800`

В этом случае будет запущена стандартная процедура расширения корпуса с ограничением времени фаззинга в 1 час (3600с). После её успешного окончания, ищется самый свежий кейс в полученном корпусе.

Если машинерия фаззинга обнаружит последний найденный кейс более 30 минут (1800с) назад, то считается что proof состоялся и фаззинг успешно завершается.

Если последний кейс был обнаружен 10 минут назад (для примера), то фаззинг будет перезапущен на дополнительные 20 минут в режиме fuzz proof с использованием всего текущего корпуса (включая новые найденные данные). Если тестовая машинерия обнаружит новый кейс во время работы в этом режиме, процесс фаззинга будет прерван, а все найденные кейсы сохранены - proof не состоялся, об этом сообщит ошибка в тесте.

`ya make -r --sanitize=address --sanitize-coverage=trace-div,trace-gep --fuzzing -A --fuzz-runs=1000000 --fuzz-proof=3600`
Аналогично работает fuzz proof режим при запуске фаззинга с ограничением суммарного количества прогонов целевой функции.

* Опция `--fuzz-minimize`  указывает инструменту фаззинга на необходимость выполнения процесса минимизации корпуса тестовых данных сразу после завершения основного этапа фаззинга. 

Ключевым элементом фаззинга является корпус тестов — набор данных, который используется фаззером для проверки программы. Корпус должен быть достаточно обширным и разнообразным, чтобы обеспечивать эффективное тестирование, но в то же время оптимизированным, чтобы не тратить ресурсы на проверку избыточных или повторяющихся тестов.

Минимизация корпуса — это процесс удаления из корпуса лишних тестов, которые не увеличивают покрытие кода, а также попыток уменьшить размер отдельных тестов без потери “интересности” для фаззера. Эта операция помогает ускорить последующие запуски фаззинга и упрощает анализ результатов.

Использование опции `--fuzz-minimize` гарантирует, что после каждого сеанса фаззинга будет автоматически выполнена минимизация корпуса тестов.

Опция `--fuzz-minimize`  позволяет не только увеличить эффективность тестирования за счет сокращения времени на прохождение корпуса, но и облегчает процесс нахождения и исправления ошибок благодаря более четкому и сжатому набору тестов.

##  Специфика тестов на Python

Основным фреймворком для написания тестов на Python является `pytest`. Поддерживаются Python 2 (макрос `PY2TEST`) и Python 3 (макрос `PY3TEST`).

* Опция `--test-log-level=TEST_LOG_LEVEL` является параметром командной строки для настройки уровня логирования в процессе выполнения тестов для языка Python. Этот параметр позволяет контролировать, какой объем сообщений лога будет выводиться в процессе тестирования, делая вывод информации более релевантным для текущих задач и предпочтений пользователя.

Уровни логирования определяют приоритет лог-сообщений и позволяют фильтровать вывод так, чтобы отображались только сообщения от установленного уровня и выше. Возможные значения `TEST_LOG_LEVEL` включают:
 - `debug`: самый низкий уровень, выводит наибольшее количество информации, включая отладочные сообщения.
 - `info`: отображает информационные сообщения, которые могут быть полезны для понимания хода выполнения программы, помимо предупреждений и ошибок.
 - `warning`: выводит предупреждения, которые указывают на потенциальные проблемы, требующие внимания, а также ошибки.
 - `error`: демонстрирует только сообщения об ошибках, которые указывают на непредвиденные проблемы в программе, требующие исправления.
 - `critical`: самый высокий уровень, отображает только критические ошибки, которые могут потребовать немедленного внимания.

* Опция `--test-traceback=TEST_TRACEBACK` позволяет настроить формат вывода трассировки стека (stack trace) при возникновении ошибок во время выполнения тестов. В зависимости от выбранной опции, трассировки могут быть представлены в различных форматах, что может упростить процесс отладки и ускорить нахождение причин сбоев.

Варианты значений параметра TEST_TRACEBACK:

 - `long`: Этот режим является наиболее подробным и выводит полную трассировку стека для каждой ошибки. Помимо стандартной информации о месте возникновения ошибки, `long` позволяет видеть контекст вызовов функций и цепочки вложенных вызовов, которые привели к ошибке.
 - `short`: По умолчанию используется этот формат. Он предоставляет сокращенную версию трассировки стека, фокусируясь на самом важном и исключая менее значимые детали. Обычно включает в себя информацию о месте возникновения непосредственной ошибки.
 - `line`: Отображает только одну строку для каждой ошибки, которая указывает на место в коде, где ошибка была обнаружена. Этот формат полезен для получения быстрого обзора ошибок без глубокой детализации.
 - `native`: Выводит трассировку стека в формате, стандартном для самого Python, без применения специфических для Pytest модификаций и улучшений. Может быть полезно для разработчиков, предпочитающих работать с трассировкой в “сыром” виде.
 - `no`: Полностью отключает вывод трассировки стека при возникновении ошибок в тестах. Этот режим может быть удобен при необходимости минимизировать количество информации в отчетах о тестировании.

* Опция `--profile-pytest` активирует процесс профилирования с помощью модуля `cProfile`, который является стандартным модулем профилирования в Python, и обрабатывает результаты для предоставления более детального и визуализированного представления данных о производительности тестов.

Использование `--profile-pytest` дает понимание временных затрат на различные участки кода в тестах. 

* Опция `--pytest-args=PYTEST_ARGS` позволяет пользователям передавать дополнительные аргументы и опции непосредственно в Pytest, расширяя стандартное поведение или настройки запуска тестов. 

Возможности, которые можно настроить с помощью `--pytest-args`:

  - Задание пути к тестам: можно указать конкретные файлы или директории для запуска;
  - Управление выводом: настроить уровень детализации выводимой информации (используйте -v для более подробного вывода и -q для менее подробного)
  - Маркировка тестов: запуск только тех тестов, которые отмечены определенными метками (`-m`), что позволяет гибко управлять наборами тестов;
  - Параллельное выполнение тестов: при наличии плагина `pytest-xdist`, можно распределить тесты на несколько процессов для их параллельного выполнения (`-n`);

## Специфика тестов Java

https://st.yandex-team.ru/DOCSUP-69420

Опция `--system-property=PROPERTIES` (или в сокращенной форме `-R=PROPERTIES`) используется в контексте запуска Java-приложений и тестов, чтобы установить одно или несколько системных свойств JVM (Java Virtual Machine) перед выполнением приложения или теста. Системные свойства в Java — это ключевые значения, которые можно использовать для конфигурации поведения JVM и приложения. Они могут влиять на работу стандартных классов Java и могут быть использованы для передачи конфигурационной информации в ваше приложение.

Формат опции:
–system-property=PROPERTIES
или
ПРОВЕРИТЬ

\-R=PROPERTIES
где `PROPERTIES` — это пары ключ-значение в формате `name=value`. Если требуется передать несколько системных свойств, опция может быть указана несколько раз с разными парами ключ-значение.

Пример использования:
–system-property=my.prop1=val1 --system-property=my.prop2=val2
или с использованием сокращенной формы:
\-R=my.prop1=val1 -R=my.prop2=val2
В этом примере перед запуском Java-приложения или теста устанавливаются два системных свойства: `my.prop1` со значением `val1` и `my.prop2` со значением `val2`.

Зачем это нужно:
\- **Конфигурация приложения**: Системные свойства могут использоваться для конфигурирования различных аспектов работы приложения, например, для указания путей к файлам конфигурации, настройки логирования и т.д.
\- **Тестирование**: В контексте тестирования, системные свойства могут использоваться для изменения поведения тестов, например, для включения или отключения определенных тестовых случаев на основе конфигурации или для указания различных параметров тестового окружения.
\- **Настройка JVM**: Системные свойства также могут использоваться для настройки работы самой JVM, например, для установки максимального размера кучи или настройки сборщика мусора.

Важно понимать, что системные свойства, установленные таким образом, будут доступны во всем приложении через вызов `System.getProperty("name")`, где `"name"` — это ключ системного свойства. Это делает их удобным средством для передачи конфигурационной информации в приложение в момент его запуска.


Опция `--system-properties-file=PROPERTIES_FILES` представляет собой механизм, используемый при запуске Java-приложений или тестов, для загрузки и установки системных свойств JVM из внешнего файла. Эта возможность особенно полезна, когда необходимо установить большое количество системных свойств или когда значения этих свойств должны быть легко изменяемы без перекомпиляции кода или перезапуска среды разработки.

**Формат опции:**
–system-properties-file=PROPERTIES_FILES
где `PROPERTIES_FILES` указывает на путь к файлу, содержащему системные свойства.

**Формат файла свойств:**
Файл, из которого загружаются системные свойства, обычно имеет простой текстовый формат, где каждая строка содержит одно свойство в формате `ключ=значение`. Комментарии могут быть добавлены, начиная строку с символа `#`. Например:
`# Это комментарий￼property1=value1￼property2=value2`

**Пример использования:**
Предположим, у вас есть файл `app.properties` со следующим содержимым:
app.config.path=/path/to/config
app.logging.level=DEBUG
Чтобы загрузить эти свойства при запуске приложения, используйте опцию:
–system-properties-file=app.properties

**Зачем это нужно:**
\- **Централизованная конфигурация**: Управление системными свойствами через внешний файл позволяет централизованно изменять конфигурацию приложения без необходимости изменения кода или команды запуска.
\- **Упрощение команды запуска**: Вместо того, чтобы указывать множество системных свойств через командную строку с использованием `-Dkey=value`, можно указать один файл, что делает команду запуска более читаемой и удобной для восприятия.
\- **Динамическая конфигурация**: Файл свойств может быть легко изменен администраторами системы или разработчиками для тонкой настройки поведения приложения в зависимости от среды выполнения, не требуя пересборки или перезапуска приложения.

**Важные моменты:**
\- При использовании этой опции важно убедиться, что файл свойств доступен по указанному пути в момент запуска приложения.
\- Системные свойства, загруженные из файла, будут доступны во всем приложении через `System.getProperty("key")`, что делает их удобным способом для передачи конфигурационной информации в приложение.


Опция `--jvm-args=JVM_ARGS` используется в системах сборки и исполнения, связанных с Java-приложениями, для передачи дополнительных аргументов непосредственно виртуальной машине Java (JVM) при её запуске. Эти аргументы позволяют настроить работу JVM, влияя на производительность, поведение сборщика мусора, использование памяти и другие важные аспекты исполнения Java-приложений.

**Формат опции:**
–jvm-args=JVM_ARGS
где `JVM_ARGS` — это строка, содержащая один или несколько аргументов, которые должны быть переданы JVM. Аргументы разделяются пробелами и могут включать в себя как стандартные опции JVM, так и специфичные для конкретной реализации JVM.

**Пример использования:**
–jvm-args=“-Xmx1024m -Xms512m -XX:\+UseG1GC”
В данном примере:
\- `-Xmx1024m` устанавливает максимальный размер кучи (heap) в 1024 мегабайта. Это предел, до которого может вырасти куча в процессе работы приложения.
\- `-Xms512m` задает начальный размер кучи в 512 мегабайт. JVM будет стартовать с кучей данного размера.
\- `-XX:+UseG1GC` включает использование сборщика мусора G1 (Garbage-First), который подходит для приложений с большим объемом памяти и требующих предсказуемого времени паузы на сборку мусора.

**Зачем это нужно:**
\- **Настройка производительности**: Оптимизация использования памяти и выбор подходящего сборщика мусора могут существенно повлиять на производительность Java-приложения.
\- **Отладка и профилирование**: Некоторые аргументы JVM активируют режимы отладки или профилирования, позволяя разработчикам анализировать выполнение приложения.
\- **Настройка безопасности**: Через аргументы JVM можно настроить параметры безопасности, например, ограничить доступ к определенным функциям.
\- **Управление ресурсами**: Указание ограничений на использование памяти предотвращает чрезмерное потребление ресурсов системы.

**Важные моменты:**
\- Необходимо с осторожностью использовать аргументы JVM, так как неправильные настройки могут привести к снижению производительности или даже к ошибкам в работе приложения.
\- Доступные аргументы и их эффекты могут различаться в зависимости от версии и реализации JVM. Следует ознакомиться с документацией конкретной версии JVM, которая используется в вашем проекте.


Опция `--hermione-config=HERMIONE_CONFIG` в системе сборки `ya make` используется для указания пути к файлу конфигурации для запуска тестов, использующих Hermione — инструмент для автоматизированного тестирования веб-приложений с помощью Selenium. Эта опция позволяет тонко настроить процесс тестирования, указав различные параметры исполнения тестов, включая настройки браузеров, таймауты, пути к тестам и многое другое.

**Hermione** — это популярный инструмент для автоматизации тестирования веб-приложений, который позволяет писать тесты на высоком уровне абстракции. Тесты, написанные для Hermione, могут выполняться в различных браузерах, позволяя разработчикам убедиться, что их веб-приложение работает корректно в разных средах.

**Формат опции:**
–hermione-config=путь/к/файлу/конфигурации

**Пример использования:**
ya make --hermione-config=./configs/hermione.conf.js
В этом примере команда `ya make` запустит тесты Hermione, используя конфигурационный файл `hermione.conf.js`, расположенный в директории `configs`.

**Содержание файла конфигурации:**
Файл конфигурации Hermione обычно представляет собой JavaScript файл, который экспортирует объект с настройками. В нем можно указать:

\- **browsers**: конфигурации для браузеров, в которых будут запускаться тесты;
\- **baseUrl**: базовый URL тестируемого веб-приложения;
\- **gridUrl**: URL Selenium Grid, через который будут запускаться браузеры;
\- **timeout**: таймауты для тестов;
\- **retry**: количество попыток перезапуска тестов в случае их неудачного выполнения;
\- **plugins**: настройки плагинов, расширяющих функциональность Hermione.

**Зачем это нужно:**
\- **Гибкость настроек**: Опция позволяет указать конкретный файл конфигурации для запуска тестов, что дает возможность иметь несколько разных конфигураций для разных сред или целей тестирования.
\- **Удобство управления**: Централизованное управление настройками тестирования через один файл конфигурации упрощает поддержку и обновление параметров тестирования.
\- **Множественные среды тестирования**: Можно легко переключаться между различными конфигурациями для запуска тестов в разных средах (разработка, тестирование, продакшн) без изменения кода тестов.

**Важные моменты:**
\- При использовании этой опции убедитесь, что указанный путь к файлу конфигурации корректен и файл доступен в момент запуска `ya make`.
\- Возможности и параметры конфигурации могут изменяться в зависимости от версии Hermione и подключенных плагинов, поэтому рекомендуется ознакомиться с документацией Hermione для понимания всех доступных настроек.

Опция `--hermione-browser=HERMIONE_BROWSERS` предназначена для использования в контексте запуска автоматизированных тестов веб-приложений с помощью инструмента Hermione. Эта опция позволяет ограничить выполнение тестов только выбранными браузерами, что полезно при необходимости запустить тесты в конкретной среде или при отладке проблем, связанных с определенным браузером.

**Hermione** — это инструмент для автоматизации тестирования веб-приложений, работающий поверх WebDriver и Selenium. Он позволяет писать тесты на JavaScript, которые могут выполняться в различных браузерах, имитируя действия пользователя.

 Формат опции:
–hermione-browser=HERMIONE_BROWSERS
где `HERMIONE_BROWSERS` — это строка, содержащая имя браузера или список имен браузеров, разделенных запятыми, в которых должны выполняться тесты.

 Пример использования:
ya make --hermione-browser=chrome
Эта команда запустит Hermione тесты только в браузере Chrome.

Если требуется запустить тесты в нескольких браузерах, можно указать их через запятую:
ya make --hermione-browser=chrome,firefox
Эта команда запустит тесты в браузерах Chrome и Firefox.

 Зачем это нужно:
1\. **Фокусировка на конкретном браузере**: При разработке веб-приложений часто возникают ситуации, когда функционал нужно протестировать в конкретном браузере из-за его специфики или известных проблем совместимости.
2\. **Экономия времени**: Запуск тестов только в одном или нескольких целевых браузерах может существенно сократить время, необходимое для прохождения тестового набора, особенно когда полный прогон всех тестов во всех поддерживаемых браузерах занимает много времени.
3\. **Отладка**: При поиске и исправлении ошибок, специфичных для определенного браузера, возможность запустить тесты только в этом браузере упрощает и ускоряет процесс отладки.

Важные моменты:
\- Убедитесь, что указанные браузеры настроены в конфигурационном файле Hermione и доступны для запуска тестов. Конфигурация браузеров включает в себя не только их названия, но и параметры запуска, версии и пути к драйверам.
\- Для эффективного использования этой опции важно иметь хорошо структурированные тесты, способные корректно выполняться в различных браузерах с учетом их особенностей.


Опция `--hermione-grep=HERMIONE_GREP` используется в контексте запуска автоматизированных тестов с помощью инструмента Hermione, который предназначен для тестирования веб-приложений. Эта опция позволяет запускать только те тесты, названия которых соответствуют указанному шаблону, используя механизм фильтрации посредством регулярных выражений или подстрок.

**Hermione** — это инструмент для автоматизации тестирования веб-приложений на основе Selenium WebDriver. Он позволяет писать тесты на JavaScript, которые могут взаимодействовать с веб-страницами так же, как это делает пользователь, обеспечивая тем самым высокую точность тестирования пользовательского интерфейса.

 Формат опции:
–hermione-grep=HERMIONE_GREP
где `HERMIONE_GREP` — это шаблон (регулярное выражение или просто подстрока), по которому будет производиться поиск среди названий тестов или групп тестов (тестовых сценариев).

Пример использования:
ya make --hermione-grep=“Логин”
Эта команда запустит все тесты Hermione, в названиях которых содержится слово “Логин”.

Если требуется более специфичный отбор тестов, можно использовать регулярные выражения:
ya make --hermione-grep=“\^Логин.\*успех\$”
Эта команда запустит тесты, названия которых начинаются со слова “Логин” и заканчиваются словом “успех”.

 Зачем это нужно:
\- **Фокусировка на конкретных тестах**: Позволяет запускать только те тесты, которые соответствуют определенному критерию, что особенно полезно при разработке или отладке тестов.
\- **Экономия времени**: Запуск только релевантных тестов экономит время, особенно когда общее количество тестов велико, а необходимо проверить только определенную функциональность.
\- **Упрощение интеграции с CI/CD**: Можно настроить разные пайплайны для запуска разных групп тестов в зависимости от контекста изменений в коде.


Опция `--hermione-test-path=HERMIONE_TEST_PATHS` предназначена для запуска автоматизированных тестов веб-приложений с использованием инструмента Hermione, ограничивая выполнение тестов только теми, что расположены в указанных файлах. Это позволяет более гибко управлять процессом тестирования, запуская тесты из конкретных файлов, что особенно удобно при разработке новых тестов или при необходимости провести тестирование только определенной части приложения.

Формат опции:
–hermione-test-path=HERMIONE_TEST_PATHS
где `HERMIONE_TEST_PATHS` — это один путь или список путей к файлам с тестами, разделенных запятыми. Пути должны быть указаны относительно текущей рабочей директории (cwd - current working directory).

Пример использования:
ya make -t --hermione-test-path=./tests/loginTest.js
Эта команда запустит выполнение тестов, расположенных в файле `loginTest.js`, который находится в директории `tests` относительно текущей рабочей директории.

Если необходимо запустить тесты из нескольких файлов, пути к этим файлам перечисляются через запятую:
ya make -t --hermione-test-path=./tests/loginTest.js,./tests/registrationTest.js
В этом случае будут выполнены тесты из двух файлов: `loginTest.js` и `registrationTest.js`.

\- **Точечное тестирование**: Позволяет запускать тесты из конкретных файлов, что удобно при разработке новых тестов или при отладке существующих.
\- **Экономия времени**: Запуск только определенных тестов экономит время, особенно когда полный прогон всех тестов занимает значительное количество времени.
\- **Гибкость**: Дает возможность гибко настраивать запуск тестов в зависимости от потребностей разработки или тестирования.


Опция `--hermione-set=HERMIONE_SETS` используется в контексте запуска тестов с помощью инструмента Hermione, который предназначен для автоматизированного тестирования веб-приложений. Эта опция позволяет ограничить выполнение тестов только теми, которые включены в определенный набор (или наборы), предварительно сконфигурированный в файле конфигурации Hermione.

**Hermione** позволяет группировать тесты в наборы (sets), чтобы можно было легко запускать различные подгруппы тестов в зависимости от текущих требований. Например, можно создать отдельные наборы для smoke-тестов, тестов регрессии, тестов определенной функциональности и т.д. Это особенно полезно в больших проектах с обширным набором тестов, где запуск всех тестов за один раз может быть нецелесообразным.

Формат опции:
–hermione-set=HERMIONE_SETS
где `HERMIONE_SETS` — это имя одного набора или список имен наборов, разделенных запятыми, которые должны быть выполнены.

 Пример использования:
ya make -t --hermione-set=smoke
Эта команда запустит выполнение только тех тестов Hermione, которые включены в набор `smoke`.

Если требуется запустить тесты из нескольких наборов, имена наборов перечисляются через запятую:
ya make --hermione-set=smoke,regression
В этом случае будут выполнены тесты, включенные в наборы `smoke` и `regression`.

 Как настроить наборы в Hermione:
Конфигурация наборов производится в файле конфигурации Hermione (обычно `hermione.conf.js` или аналогичном). Для определения наборов используется секция `sets` в конфигурационном объекте. Пример:

```
module.exports = {
    sets: {
        smoke: {
            files: [‘tests/smoke/.js’]
        },
        regression: {
            files: ['tests/regression/**/.js’]
        }
    },
    // Другие настройки конфигурации…
};
```


В этом примере определены два набора тестов: `smoke` и `regression`, каждый из которых содержит пути к тестовым файлам, входящим в соответствующий набор.

Зачем это нужно:
\- **Гибкость запуска тестов**: Позволяет запускать только те тесты, которые актуальны в данном контексте разработки или деплоя.
\- **Оптимизация времени тестирования**: Сокращает время, необходимое на прогон тестов, позволяя фокусироваться на конкретных аспектах приложения.
\- **Удобство управления**: Упрощает управление тестами, разделяя их на логические группы.

 Важные моменты:
\- Важно корректно настроить наборы в файле конфигурации Hermione, чтобы использование опции `--hermione-set` было эффективным.
\- При использовании этой опции следует учитывать, что тесты, не входящие в указанные наборы, не будут выполнены. Это необходимо учитывать, чтобы избежать пропуска важных проверок.


Опция `--hermione-gui` предназначена для запуска тестов, использующих инструмент Hermione, в графическом интерфейсе пользователя (GUI).

 Формат опции:
\--hermione-gui

Как это работает:
При запуске с опцией `--hermione-gui`, Hermione инициирует веб-сервер, который предоставляет графический интерфейс для управления процессом тестирования. Этот интерфейс позволяет выбирать конкретные тесты для запуска, просматривать результаты их выполнения и взаимодействовать с тестовым окружением в более удобной и наглядной форме, чем при работе через командную строку.

Пример использования:
ya make -t  --hermione-gui
После запуска команды в консоли появится URL, по которому доступен графический интерфейс Hermione. Открыв этот URL в браузере, вы увидите список доступных для запуска тестов и сможете управлять процессом тестирования непосредственно из браузера.

\- **Удобство и наглядность**: Графический интерфейс делает процесс настройки и запуска тестов более интуитивно понятным и удобным, особенно для новых пользователей или в ситуациях, когда необходимо быстро настроить выполнение определенных тестов.


Опция `--hermione-gui-auto-run` предназначена для использования в контексте запуска тестов с помощью инструмента Hermione в графическом интерфейсе пользователя (GUI). Эта опция автоматизирует процесс тестирования, позволяя автоматически запустить выбранные тесты сразу после того, как пользователь открывает веб-интерфейс Hermione в браузере.

Как это работает:
При запуске Hermione с опцией `--hermione-gui`, инструмент инициирует веб-сервер, который предоставляет доступ к графическому интерфейсу для управления тестами. Обычно, после открытия интерфейса в браузере, пользователю необходимо вручную выбрать и запустить тесты. Однако, если при запуске использовать дополнительно опцию `--hermione-gui-auto-run`, тесты будут запущены автоматически, минуя необходимость ручного взаимодействия для их старта.

 Пример использования:
ya make  -t --hermione-gui --hermione-gui-auto-run
После выполнения этой команды и открытия GUI Hermione в браузере, тесты начнут выполняться автоматически, без дополнительных действий со стороны пользователя.

Зачем это нужно:
\- **Ускорение процесса тестирования**: Эта опция позволяет сэкономить время, автоматически запуская тесты сразу после загрузки GUI, что особенно удобно при частом перезапуске тестов в процессе разработки или отладки.
\- **Упрощение демонстраций**: При демонстрации работы тестов или тестового окружения перед коллегами или клиентами, автоматический запуск тестов может сделать демонстрацию более плавной и впечатляющей.


\- Опция `--hermione-gui-auto-run` может быть не подходящей для сценариев, в которых требуется тщательный отбор или настройка тестов перед их выполнением.
\- Необходимо учитывать, что автоматический запуск большого количества тестов может привести к высокой нагрузке на тестируемую систему или тестовое окружение сразу после запуска GUI.


Опция `--hermione-gui-no-open` используется в контексте запуска автоматизированных тестов с помощью инструмента Hermione в графическом интерфейсе пользователя (GUI). Эта опция предназначена для сценариев, когда необходимо запустить веб-сервер для работы с GUI Hermione, но при этом избежать автоматического открытия окна браузера с интерфейсом Hermione сразу после запуска сервера.

 Как это работает:
По умолчанию, при запуске Hermione с опцией `--hermione-gui`, инструмент инициирует веб-сервер и автоматически открывает веб-страницу с GUI Hermione в браузере по умолчанию. Это удобно для непосредственной работы с тестами через графический интерфейс. Однако, в некоторых случаях может потребоваться только запуск сервера без автоматического открытия браузера — например, при запуске в средах, где нет графического интерфейса, или когда разработчик предпочитает самостоятельно управлять моментом открытия GUI в браузере. В таких ситуациях и используется опция `--hermione-gui-no-open`.

Пример использования:
ya make -t --hermione-gui --hermione-gui-no-open
После выполнения этой команды сервер для работы с GUI Hermione будет запущен, но окно браузера открываться не будет. Адрес веб-страницы для доступа к GUI, как правило, будет выведен в консоль, и разработчик сможет перейти по нему самостоятельно, когда посчитает нужным.

 Зачем это нужно:
\- **Запуск в средах без графического интерфейса**: Позволяет использовать Hermione GUI в средах без графической оболочки или в автоматизированных скриптах.
\- **Контроль за открытием GUI**: Дает разработчикам гибкость в управлении процессом тестирования, позволяя самостоятельно решать, когда именно открыть GUI в браузере.

После запуска сервера с опцией `--hermione-gui-no-open` важно обратить внимание на консольный вывод, чтобы получить URL для доступа к GUI, так как браузер не откроется автоматически.
Эта опция особенно полезна для сценариев автоматизации и тестирования в удаленных средах или в средах непрерывной интеграции, где пользовательский интерфейс может быть недоступен.


Опция `--hermione-gui-hostname=HERMIONE_GUI_HOSTNAME` используется при запуске автоматизированных тестов веб-приложений с помощью инструмента Hermione в графическом интерфейсе пользователя (GUI). Эта опция позволяет указать конкретный хост (hostname), на котором будет запущен веб-сервер для работы с GUI Hermione. Это может быть полезно в различных сценариях, например, когда требуется запустить GUI на определенном интерфейсе или адресе, доступном в сети.

 Как это работает:
По умолчанию, при запуске Hermione с опцией `--hermione-gui`, веб-сервер для GUI запускается на локальном хосте (`localhost`). Это означает, что доступ к GUI возможен только с той же машины, на которой запущен сервер. Опция `--hermione-gui-hostname` позволяет изменить это поведение, указав другой хост, на котором должен быть запущен сервер, делая GUI доступным по сети.

Пример использования:
ya make  -t --hermione-gui --hermione-gui-hostname=192.168.1.5
В этом примере сервер для работы с GUI Hermione будет запущен на хосте с IP-адресом `192.168.1.5`. Это означает, что к GUI можно будет получить доступ не только с локальной машины, но и с любого устройства в сети, которое может подключиться к этому IP-адресу.

 Зачем это нужно:
\- **Доступность в сети**: Позволяет сделать GUI Hermione доступным для других устройств в сети, что удобно для совместной работы над тестами или демонстрации результатов тестирования.
\- **Гибкость настройки**: Указание хоста для запуска сервера дает возможность запускать GUI на определенных сетевых интерфейсах или адресах, что может быть требованием безопасности или инфраструктуры.
\- **Удаленный доступ**: При запуске сервера GUI на публичном IP-адресе или виртуальной машине, к Hermione GUI можно получить доступ из любой точки мира, что упрощает удаленную работу и тестирование.


Опция `--hermione-gui-port=HERMIONE_GUI_PORT` используется в контексте запуска автоматизированных тестов с помощью инструмента Hermione в графическом интерфейсе пользователя (GUI). Эта опция позволяет указать конкретный сетевой порт, на котором будет запущен веб-сервер для доступа к GUI Hermione. Это дает возможность контролировать, через какой порт будет осуществляться взаимодействие с интерфейсом управления тестами.

Как это работает:
При запуске Hermione с опцией `--hermione-gui`, инструмент инициирует веб-сервер, который предоставляет доступ к графическому интерфейсу для управления тестами. Если порт не указан явно, используется порт по умолчанию (обычно это `8000` или первый доступный порт после него). Опция `--hermione-gui-port` позволяет явно задать порт, на котором будет запущен веб-сервер, обеспечивая таким образом гибкость настройки среды тестирования.

Пример использования:
ya make -t --hermione-gui --hermione-gui-port=8080
В этом примере веб-сервер для GUI Hermione будет запущен на порту `8080`. Это означает, что для доступа к графическому интерфейсу Hermione необходимо будет открыть в браузере URL `http://localhost:8080`.

Зачем это нужно:
\- **Избегание конфликтов портов**: Если порт по умолчанию уже используется другим приложением или сервисом, указание другого порта позволяет избежать конфликта.
\- **Настройка сетевой конфигурации**: В некоторых сетевых окружениях или при использовании контейнеризации (например, Docker) может потребоваться запускать веб-сервер на определенном порту, который разрешен фаерволом или настроен в правилах проброса портов.
\- **Удобство доступа**: Указание заранее известного порта упрощает доступ к GUI, особенно если Hermione используется разными членами команды или интегрировано в более крупную систему автоматизации тестирования.

 Важные моменты:
\- Перед указанием порта стоит убедиться, что он не занят другими приложениями и доступен для использования.
\- В некоторых операционных системах для использования портов с номером ниже `1024` может потребоваться повышение привилегий.
\- Если тесты запускаются в изолированной среде (например, в CI/CD пайплайне или на удаленном сервере), необходимо учитывать настройки сети и доступности порта извне этой среды.


Опция `--junit-args=JUNIT_ARGS` предназначена для использования в контексте запуска Java-тестов, основанных на фреймворке JUnit. Эта опция позволяет передать дополнительные аргументы непосредственно в JUnit-раннер, что дает возможность настроить процесс выполнения тестов более гибко.

 Как это работает:
JUnit поддерживает различные аргументы командной строки, которые могут влиять на выбор и поведение тестов, например, фильтрацию тестов по имени, ограничение времени выполнения и другие настройки. Опция `--junit-args` позволяет указать эти параметры при запуске тестов через систему сборки.

Формат опции:
\--junit-args=“аргумент1 аргумент2 … аргументN”
где каждый `аргумент` соответствует поддерживаемым JUnit аргументам командной строки.

 Пример использования:
Предположим, вы хотите запустить только те тесты, имена которых соответствуют определенному шаблону, и установить таймаут для каждого теста. В таком случае можно использовать следующую команду:
ya make -t --junit-args=“-Dtest=MyTest\* -Dtimeout=100”
В этом примере:
\- `-Dtest=MyTest*` указывает JUnit запускать только те тесты, имена которых начинаются на `MyTest`.
\- `-Dtimeout=100` устанавливает максимальное время выполнения каждого теста в 100 миллисекунд.

Зачем это нужно:
\- **Фильтрация тестов**: Вы можете запускать только определенную подгруппу тестов, что особенно полезно при большом наборе тестов или когда нужно сфокусироваться на конкретной проблеме.
\- **Настройка выполнения**: Настройте поведение JUnit, например, установив таймауты для тестов, что помогает избежать зависания тестов и ускоряет процесс разработки.


НЕ ОПИСЫВАЕМ

\--strict-inputs (устаревшее)
Включить строгий режим


ОБЩЕЕ не опция

Для импорта библиотек из maven репозиториев в аркадию используется команда `ya maven-import groupId:artifactId:version` (которая взаимодействует с maven). В результате выполнения команды нужная библиотека со всеми зависимостями появится в [contrib/java](https://a.yandex-team.ru/arc/trunk/arcadia/contrib/java) в виде модуля `JAVA_LIBRARY`, описанного в `groupId/artifactId/version/ya.make`(закоммитить нужно самостоятельно). После этого можно зависеть от этого модуля, используя `PEERDIR`.



Опция `--sonar` в системе сборки `ya make` предназначена для запуска анализа качества кода с помощью инструмента SonarQube. 

SonarQube — это платформа для непрерывного анализа и измерения качества кода, которая позволяет обнаруживать различные типы проблем в коде, такие как ошибки, уязвимости, “запахи кода” (code smells), и другие потенциальные проблемы, которые могут негативно сказаться на качестве, безопасности или производительности программного обеспечения.

 Как это работает:
При использовании опции `--sonar`, `ya make` инициирует процесс анализа кода, в ходе которого код проекта сканируется, и результаты сканирования отправляются в SonarQube сервер для дальнейшего анализа и отображения в его веб-интерфейсе. Это позволяет разработчикам и командам получить детальный отчет о качестве кода, включая выявленные проблемы и рекомендации по их устранению.

Пример использования:
Для использования этой опции необходимо иметь установленный и настроенный SonarQube сервер, а также сконфигурированный проект в SonarQube, к которому будет отправлен результат анализа. Пример команды для запуска анализа:
ya make -t --sonar
Эта команда запустит процесс анализа кода проекта и отправит результаты на SonarQube сервер.

 Зачем это нужно:
\- **Повышение качества кода**: Анализ с помощью SonarQube помогает выявлять и устранять проблемы в коде на ранних этапах разработки, что способствует повышению его качества и надежности.
\- **Обеспечение безопасности**: SonarQube способен обнаруживать потенциальные уязвимости и проблемы безопасности, что критически важно для создания безопасных приложений.
\- **Контроль технического долга**: Платформа позволяет оценивать и контролировать технический долг, предоставляя инструменты для его управления и планирования работ по его уменьшению.
\- **Улучшение процесса код-ревью**: Информация о проблемах кода, предоставляемая SonarQube, может быть использована при проведении код-ревью для более детальной оценки изменений.

 Важные моменты:
\- Для работы с опцией `--sonar` необходимо наличие доступа к SonarQube серверу и настроенного проекта в нем.
\- В зависимости от размера проекта и сложности кода, анализ может занимать значительное время.
\- Важно регулярно проводить анализ и работать над устранением выявленных проблем для поддержания высокого уровня качества кода.
\- Настройка SonarQube сервера и интеграция с проектом может потребовать дополнительных шагов конфигурации и подготовки, включая настройку ключа проекта, токенов доступа и других параметров.


Опция `--maven-export` в системе сборки `ya make` предназначена для экспорта артефактов Java проекта в репозиторий Maven.

Maven — это инструмент для автоматизации сборки проектов на Java, который широко используется в разработке для управления зависимостями, сборкой проекта и его документацией. Репозитории Maven используются для хранения и распространения библиотек и других артефактов, необходимых для сборки Java проектов.

Как это работает:
При использовании опции `--maven-export`, `ya make` выполняет сборку проекта и генерирует артефакты (например, .jar файлы), соответствующие стандартам Maven. Затем эти артефакты загружаются в указанный Maven репозиторий, делая их доступными для использования в других проектах как зависимости.

Как это работает:
Использование опции `--maven-export` инициирует процесс, в ходе которого артефакты проекта (например, скомпилированные JAR-файлы) подготавливаются и отправляются в указанный Maven репозиторий. Этот процесс включает в себя генерацию POM-файлов (Project Object Model), которые описывают проект и его зависимости, и самих артефактов в соответствии с требованиями Maven.

Пример использования:
Команда для сборки и экспорта артефактов в Maven репозиторий может выглядеть следующим образом:
ya make -t  --maven-export
Для успешного экспорта в Maven репозиторий необходимо также указать дополнительные параметры, такие как URL репозитория, идентификаторы группы и артефакта, версию и, при необходимости, учетные данные для аутентификации в репозитории. Эти параметры обычно настраиваются в конфигурационных файлах проекта или передаются через дополнительные опции командной строки.

Зачем это нужно:
\- **Управление зависимостями**: Экспорт артефактов проекта в Maven репозиторий позволяет другим проектам легко подключать и использовать эти артефакты как зависимости.
\- **Версионирование и распространение**: Maven репозитории поддерживают версионирование артефактов, что облегчает управление разными версиями библиотек и их распространение среди разработчиков и проектов.
\- **Автоматизация сборки**: Интеграция с Maven позволяет автоматизировать процесс сборки проектов, использующих экспортированные артефакты, и обеспечивает совместимость с широко распространенными инструментами и практиками разработки на Java.

Важные моменты:
\- Необходимо иметь доступ к Maven репозиторию, куда будут экспортироваться артефакты, и правильно настроить параметры для подключения к этому репозиторию.
\- Важно соблюдать правила именования и версионирования артефактов в соответствии со стандартами Maven, чтобы обеспечить их корректное использование в качестве зависимостей.
\- Экспорт в Maven репозиторий может потребовать дополнительных шагов для подготовки артефактов, таких как генерация POM-файлов и их настройка.

Использование опции `--maven-export` в `ya make` обеспечивает тесную интеграцию процессов сборки с экосистемой Maven, упрощая управление зависимостями и сборкой проектов на Java.

Наверное не надо было описывать, интеграция Аркадии с Мавен, уточнить


Скорее всего не описываем

Опция `--version=VERSION` в системе сборки `ya make` используется в контексте экспорта артефактов Java проекта в репозиторий Maven. Эта опция позволяет указать версию экспортируемых артефактов, что является ключевым аспектом управления зависимостями в Maven и обеспечивает корректное версионирование библиотек или приложений в процессе их разработки и деплоя.

Как это работает:
В Maven каждый артефакт (обычно это JAR-файл) идентифицируется уникальным сочетанием groupId, artifactId и версии. Версия артефакта позволяет отслеживать его изменения во времени, управлять совместимостью и обеспечивать стабильность сборки проектов, использующих эти артефакты как зависимости.

При использовании опции `--version=VERSION` с `ya make --maven-export`, вы явно указываете версию артефакта, которая будет использоваться при его экспорте в Maven репозиторий. Это позволяет контролировать, какая версия артефакта будет доступна для других проектов.

Пример использования:
ya make -t --maven-export --version=1.0.0
Эта команда экспортирует артефакты текущего проекта в Maven репозиторий, присваивая им версию `1.0.0`.

Зачем это нужно:
\- **Управление версиями**: Четкое указание версии артефакта важно для управления зависимостями в проектах, использующих Maven. Это позволяет разработчикам точно указывать, какие версии библиотек они хотят использовать, и избегать проблем с несовместимостью.
\- **Разработка и деплой**: Версионирование артефактов позволяет отличать стабильные релизы от версий в разработке (SNAPSHOT-версии) и управлять процессом разработки, тестирования и деплоя.
\- **История изменений**: Версии артефактов фиксируют историю изменений в коде, позволяя отслеживать, какие изменения были внесены между различными релизами.

Важные моменты:
\- **Семантическое версионирование**: Рекомендуется следовать принципам семантического версионирования (SemVer), где номер версии состоит из трех частей: MAJOR.MINOR.PATCH, что помогает другим разработчикам понимать, какие изменения были внесены в артефакт.
\- **SNAPSHOT-версии**: В Maven принято использовать суффикс `-SNAPSHOT` для версий артефактов, находящихся в активной разработке. Это сигнализирует о том, что версия может изменяться и не является стабильной.
\- **Консистентность версий**: Важно поддерживать консистентность версий артефактов внутри проекта и при их экспорте в Maven репозиторий, чтобы обеспечить корректную сборку и управление зависимостями.


Опция тестирования `-J=JAVAC_FLAGS` или в альтернативном формате `--javac-opts=JAVAC_FLAGS` для `ya make` предназначена для передачи дополнительных флагов и параметров непосредственно компилятору Java (`javac`) в процессе сборки Java-проектов. Это предоставляет разработчикам дополнительную гибкость при настройке процесса компиляции их Java кода, позволяя влиять на различные аспекты компиляции, такие как уровень предупреждений, оптимизации, обработка аннотаций и другие.

Формат опции:
\- В форме `-J=JAVAC_FLAGS` каждый из флагов `JAVAC_FLAGS` передается компилятору `javac` как есть.
\- В форме `--javac-opts=JAVAC_FLAGS` то же самое, но используется полная форма опции.

Пример использования:
Предположим, вы хотите включить в процессе компиляции проверку всех предупреждений компилятора, а также задать путь к аннотациям для JSR305. Вы можете указать это следующим образом:
ya make -t -J=“-Xlint:all -Xlint:-serial -encoding UTF-8”
или
ya make -t --javac-opts=“-Xlint:all -Xlint:-serial -encoding UTF-8”
В этом примере:
\- `-Xlint:all` включает все предупреждения компилятора.
\- `-Xlint:-serial` отключает предупреждения компилятора о `serialVersionUID` для сериализуемых классов (если, например, `-Xlint:all` был слишком “шумным”).
\- `-encoding UTF-8` указывает компилятору использовать UTF-8 как кодировку исходных файлов.

Зачем это нужно:
\- **Настройка компиляции**: Позволяет тонко настраивать процесс компиляции, что может быть необходимо для удовлетворения специфических требований проекта или для управления компромиссами между производительностью и безопасностью.

\- **Поддержка новых функций Java**: Когда вы хотите использовать новые функции языка Java или экспериментальные возможности, которые требуют добавления специфических флагов компилятора.

\- **Управление предупреждениями**: Позволяет включать или исключать определенные предупреждения, что упрощает нахождение потенциальных проблем в коде на ранних этапах разработки.

 Важные моменты:
\- Убедитесь, что флаги, которые вы передаете, совместимы с вашей версией компилятора `javac`. Некоторые флаги могут отсутствовать или работать по-разному в разных версиях.

\- Будьте внимательны при использовании флагов, которые могут значительно изменить поведение компилятора, так как это может привести к неожиданным результатам.

\- Эта опция предназначена для опытных разработчиков, которые хорошо знакомы со средствами и настройками компилятора Java.


Опция `--error-prone-flags=ERROR_PRONE_FLAGS` в контексте системы сборки `ya make` предназначена для настройки поведения Error Prone во время компиляции Java-кода. Error Prone — это плагин для компилятора Java (javac), который анализирует код на предмет распространенных ошибок программирования, которые традиционный компилятор Java не способен обнаружить. Этот инструмент помогает разработчикам находить и исправлять ошибки на ранних этапах процесса разработки, повышая тем самым качество кода и сокращая время, требуемое на отладку.

 Как это работает:
При включении Error Prone в процессе компиляции, он анализирует исходный код на предмет различных “шаблонов ошибок” — проблем в коде, которые часто приводят к ошибкам или нежелательному поведению программы. Error Prone может выдать предупреждения или ошибки для найденных проблематичных участков кода. С помощью опции `--error-prone-flags` разработчики могут настраивать, какие правила анализа будут применяться, отключать определенные правила, изменять уровень серьезности выдаваемых предупреждений и т.д.

Формат опции:
–error-prone-flags=“флаг1 флаг2 … флагN”
где каждый `флаг` задает конкретную настройку или параметр анализа Error Prone.

Пример использования:
ya make -t  --error-prone-flags=“-Xep:DeadException:WARN -XepDisableWarningsInGeneratedCode”
В этом примере:
\- `-Xep:DeadException:WARN` меняет уровень серьезности правила анализа `DeadException` на предупреждение (`WARN`). Это правило, например, может обнаруживать исключения, которые создаются, но не используются.
\- `-XepDisableWarningsInGeneratedCode` отключает вывод предупреждений Error Prone для сгенерированного кода. Это может быть полезно для сокращения “шума” в отчетах о компиляции, когда разработчик сосредоточен на анализе кода, написанного вручную.

Зачем это нужно:
\- **Повышение качества кода**: Использование Error Prone помогает обнаружить сложные для обнаружения ошибки на этапе компиляции, еще до выполнения тестов или запуска программы.
\- **Настройка анализа под специфику проекта**: Не все правила Error Prone могут быть актуальны или приемлемы для конкретного проекта. С помощью `--error-prone-flags` можно тонко настроить анализ, выбрав наиболее релевантные проверки.
\- **Управление “шумом”**: В некоторых случаях количество предупреждений от Error Prone может быть избыточным, особенно для больших проектов или при использовании генераторов кода. Эта опция позволяет уменьшить количество “ложных находок”.

Важные моменты:
\- Необходимо ознакомиться с документацией Error Prone, чтобы понять доступные флаги и правила, и корректно использовать их в контексте своего проекта.
\- Изменение уровня серьезности правил или отключение некоторых из них должно быть обосновано требованиями проекта или кодовой базой, чтобы не пропустить важные исправления в коде.
\- Включение Error Prone в сборку может незначительно увеличить время компиляции из-за дополнительного анализа кода.


Опция `--disable-run-script-generation` в системе сборки `ya make` используется специфически для проектов, написанных на Java, и предназначена для отключения автоматической генерации скриптов запуска, обычно именуемых `run.sh` для Unix-подобных систем или `run.bat` для Windows. Эти скрипты создаются в процессе сборки для упрощения процесса запуска Java приложений (`JAVA_PROGRAM`), обеспечивая быстрый и удобный способ запустить собранное приложение без необходимости вручную формировать команду `java -jar ...` с указанием всех необходимых аргументов и путей к зависимостям.

Как это работает:
В процессе сборки, когда собирается Java-проект типа `JAVA_PROGRAM`, система сборки `ya make` обычно генерирует скрипт запуска (`run.sh` или `run.bat`), который включает в себя всю необходимую информацию для запуска собранного JAR файла, включая пути к зависимостям и необходимые параметры JVM. Если же разработчик хочет отказаться от автоматического создания таких скриптов, он может использовать опцию `--disable-run-script-generation`.

 Пример использования:
ya make -t  --disable-run-script-generation
Использование этой команды приведет к тому, что в процессе сборки скрипты `run.sh` или `run.bat` не будут сгенерированы, даже если сборка завершится успешно.

Зачем это нужно:
\- **Кастомизация запуска**: В некоторых случаях разработчикам может потребоваться более глубокая кастомизация процесса запуска приложения, несовместимая с стандартным скриптом запуска.
\- **Сложные сценарии запуска**: Для приложений, требующих специальной предварительной настройки окружения, аргументов JVM, которые сложно представить стандартным скриптом.
\- **Интеграция и деплой**: В случаях, когда проект интегрируется в сложную систему деплоя или CI/CD, автоматические скрипты запуска могут быть не нужны или даже мешать.

\- При отключении генерации скриптов запуска ответственность за корректный запуск приложения полностью ложится на разработчика. Ему необходимо самостоятельно подготовить все необходимые скрипты или команды запуска.
\- Необходимо тщательно продумать и протестировать альтернативные способы запуска вашего приложения, чтобы убедиться в их корректности и отсутствии проблем при запуске в различных окружениях.
\- Эта опция может быть особенно полезна при разработке библиотек или компонент, которые встраиваются в другие приложения или сервисы и не предназначены для независимого запуска.


Опция `--sonar-project-filter=SONAR_PROJECT_FILTERS` в контексте использования системы сборки `ya make` ориентирована на работу с инструментом анализа качества кода SonarQube во время выполнения тестирования или анализа кода. 

Эта опция позволяет уточнить и ограничить анализ SonarQube только определенными проектами или подпроектами, которые соответствуют заданным критериям или фильтрам. Это особенно полезно в больших или многоуровневых проектах, где не требуется анализировать всю кодовую базу целиком, а лишь ее часть.

Как это работает:
При работе с SonarQube, весь кодовый проект или множество проектов могут быть проанализированы на наличие различных типов ошибок, проблем безопасности, “запахов” кода (code smells) и других потенциальных улучшений. Однако, если вам нужен анализ только специфической части кодовой базы, использование фильтра `--sonar-project-filter` дает возможность сузить область анализа до проектов или путей, соответствующих заданным шаблонам или критериям фильтрации.

Формат опции:
\--sonar-project-filter=“фильтр1 фильтр2 … фильтрN”
где каждый `фильтр` определяет паттерн или критерий, который будет использоваться для отбора проектов для анализа. Фильтры могут быть оформлены в виде простых строк, регулярных выражений или иных форматах, приемлемых системой сборки и инструментом SonarQube.

 Пример использования:
Предположим, вам нужно проанализировать только те проекты, путь которых содержит `frontend`, а также специфический модуль `authentication` в другом месте кодовой базы. В таком случае, ваша команда могла бы выглядеть следующим образом:
ya make -t --sonar --sonar-project-filter=“*frontend* *authentication*”
Здесь анализ SonarQube будет применен только к проектам, в путях которых встречается `frontend` или `authentication`.


Опция `--sonar-default-project-filter` предназначена для использования в системе сборки `ya make` в контексте подготовки проекта к анализу качества кода инструментом SonarQube.

 Эта опция позволяет установить значение по умолчанию для фильтра, который применяется к проектам или модулям в рамках анализа SonarQube, определяя таким образом, какие конкретные цели сборки (проекты или модули) будут анализироваться SonarQube. 

SonarQube — это автоматизированная система для контроля качества кода, которая помогает обнаруживать различные проблемы в исходном коде, такие как ошибки, уязвимости, “запахи кода” и другие потенциальные проблемы.

Пример использования:
Допустим, вы хотите, чтобы анализ SonarQube касался только определенных частей вашего проекта, например, модулей, имена которых содержат “auth” или “util”. В таком случае, команда может выглядеть следующим образом:
ya make --sonar --sonar-default-project-filter=“*auth*,*util*”
Эта команда подготовит проект к анализу в SonarQube, но фактический анализ будет проводиться только по тем частям кода, которые соответствуют установленным фильтрам.

 Как это работает:
\- При запуске анализа SonarQube с помощью `ya make --sonar`, инструмент анализирует код на предмет различных проблем и выдает соответствующие отчеты и метрики качества кода.
\- Опция `--sonar-default-project-filter` позволяет ограничить область анализа, указав фильтры (паттерны), которым должны соответствовать анализируемые проекты или модули. 

 Зачем это нужно:
\- **Фокусировка анализа**: Направление ресурсов SonarQube на анализ наиболее важных или измененных частей кода для ускорения процесса анализа и получения наиболее релевантных результатов.
\- **Управление ресурсами**: Эффективное использование вычислительных мощностей за счет исключения из анализа несущественных частей проекта или временно не актуальных модулей.
\- **Гибкость конфигурации**: Возможность задать разные конфигурации анализа для разных сценариев сборки, например, различая полный анализ и анализ только изменений.

 Важные моменты:
\- Необходимо тщательно выбирать фильтры, чтобы не пропустить важные для анализа части кода.
\- Следует учитывать, как изменения в кодовой базе могут влиять на соответствие целей сборки заданным фильтрам.
\- Для эффективного использования этой опции рекомендуется хорошо знать структуру проекта и логику именования его модулей.

Использование `--sonar-default-project-filter` обеспечивает более точный контроль над тем, какие части проекта подвергаются анализу качества кода при интеграции с SonarQube, тем самым улучшая эффективность анализа и позволяя разработчикам сфокусироваться на наиболее значимых аспектах кодовой базы.


НЕ ОПЦИЯ

Система SonarQube предоставляет функции для фильтрации проектов и управления ими. Если вам нужно задать фильтр по умолчанию для проектов в SonarQube, обычно это осуществляется через интерфейс настроек проекта в веб-интерфейсе. Вот как вы можете это сделать:

1. **Войдите в Веб-Интерфейс**: Войдите в ваш аккаунт SonarQube через браузер.

2. **Панель Администрирования**: Перейдите в раздел администрирования SonarQube.

3. **Фильтры**: Найдите раздел 'Фильтры' или 'Filters' в настройках.

4. **Создание/Настройка Фильтра**: Вы можете создать новый фильтр или настроить уже существующий, указав критерии для отображения проектов по умолчанию. Это может включать конфигурацию по ключевым словам, статусу качества, датам анализа и другим параметрам.

5. **Сохранение Фильтра**: После того, как вы настроите критерии, сохраните фильтр. Он будет применяться для отображения списка проектов в соответствии с заданными параметрами.

6. **Использование по Умолчанию**: Если вы хотите сделать созданный фильтр фильтром по умолчанию для всех пользователей, нужно убедиться, что существует такая опция в SonarQube и её можно активировать.


Опция `-N=SONAR_PROPERTIES` или в полной форме `--sonar-property=SONAR_PROPERTIES` в системе сборки `ya make` предназначена для настройки анализа кода инструментом SonarQube во время выполнения тестирования или любого другого процесса анализа, инициированного через `ya make`. 

Эта опция позволяет задать одно или несколько дополнительных свойств, которые будут переданы в SonarQube в качестве параметров конфигурации анализа.

SonarQube — это комплексное решение для непрерывного анализа качества кода, которое позволяет обнаруживать различные типы проблем в исходном коде, как ошибки, уязвимости, потенциальные оптимизации, “запахи кода” (code smells) и др.

Как это работает:
Во время запуска `ya make --sonar`, когда активируется анализ SonarQube, опция `--sonar-property` используется для передачи дополнительных параметров или настроек непосредственно в SonarQube. Это позволяет точно настроить или изменить поведение анализатора для текущего запуска.

Формат опции:
\-N=name\[=val\] или --sonar-property=name\[=val\]
Здесь:
\- `name` — имя свойства, которое вы хотите задать или изменить.
\- `val` — значение этого свойства. Если значение не указано, используется `"yes"` по умолчанию.

Можно указать несколько свойств, разделив их пробелами и используя кавычки для обертывания всей последовательности, или же повторяя опцию для каждого свойства отдельно.

Пример использования:
ya make --sonar --sonar-property=“sonar.exclusions=**/test/** sonar.language=java”
Эта команда укажет SonarQube исключить из анализа все файлы, находящиеся в директориях `test` любого уровня вложенности, и задать основной язык проекта как Java.

Или так:
ya make --sonar -N=sonar.exclusions=**/test/** -N=sonar.language=java

Почему это важно:
\- **Гибкость анализа**: Позволяет индивидуально настраивать анализ SonarQube под конкретные требования проекта, увеличивая его эффективность и релевантность результатов.
\- **Исключения и фильтрация**: Возможность исключать из анализа нерелевантные части кода уменьшает “шум” и сосредотачивает внимание на важных участках кода.
\- **Конфигурация на уровне запуска**: Не требует изменения основного файла конфигурации SonarQube для внесения временных или проектно-специфичных изменений.

Важные моменты:
\- **Понимание параметров**: Необходимо знать доступные свойства и их возможные значения для корректной конфигурации SonarQube.
\- **Документация SonarQube**: Желательно ознакомиться с официальной документацией SonarQube для понимания всех поддерживаемых свойств и их влияния на процесс анализа.
\- **Взаимосвязь параметров**: Некоторые параметры могут взаимодействовать друг с другом, что следует учитывать при их настройке.


Опция `--sonar-do-not-compile` в системе сборки `ya make` используется во время подготовки к анализу кода инструментом SonarQube и сообщает системе о пропуске этапа компиляции Java исходных кодов. При использовании данной опции не требуется компилировать Java файлы проекта перед его анализом SonarQube. Как следствие, свойство `-Dsonar.java.binaries`, обычно указывающее на расположение скомпилированных классов Java, не будет автоматически настроено в процессе запуска анализа.

Как это работает:
Обычно, для анализа качества кода SonarQube требует указания местоположения скомпилированных бинарных файлов Java классов, это делается через свойство `sonar.java.binaries`. Однако, в некоторых сценариях, особенно когда анализируется только статический код и не требуется проверка байт-кода, компиляцию можно пропустить. Опция `--sonar-do-not-compile` позволяет обойти шаг компиляции, уведомляя систему сборки и SonarQube о том, что бинарные файлы не будут использоваться в данном запуске анализа.

Пример использования:
ya make --sonar --sonar-do-not-compile
В данном случае, `ya make` запустит анализ SonarQube без предварительной компиляции Java кода, и свойство `-Dsonar.java.binaries` не будет установлено.

Зачем это нужно:
\- **Быстрота анализа**: Пропуск шага компиляции может значительно ускорить процесс анализа, особенно для больших проектов.
\- **Фокус на статическом анализе**: Если интерес представляет только статический анализ исходного кода (например, проверка стиля кодирования, наличие “запахов” кода и т.д.) без анализа байт-кода, компиляция не требуется.
\- **Проблемы с компиляцией**: В случае сложностей с компиляцией проекта или когда компиляция невозможна из-за внешних зависимостей, данная опция может обеспечить возможность анализа кода без необходимости решать все проблемы сборки.

Важные моменты:
\- **Ограниченный анализ**: Пропуск компиляции исключает возможность анализа байт-кода, что может уменьшить глубину и полноту анализа SonarQube.
\- **Настраиваемость SonarQube**: Необходимо учитывать, что для некоторых проверок или метрик SonarQube может потребоваться доступ к скомпилированным классам. В этом случае, такие проверки не будут выполнены.
\- **Конфигурация SonarQube**: При использовании данной опции могут потребоваться дополнительные настройки SonarQube для корректного анализа, включая настройку источников кода, путей к тестам и так далее.

Использование опции `--sonar-do-not-compile` дает гибкость в процессе анализа кода, позволяя сосредоточиться на статических аспектах качества кода без необходимости компиляции, но следует учитывать потенциальные ограничения и адаптировать настройки SonarQube под конкретные требования анализа.


Опция `--sonar-java-args=SONAR_JAVA_ARGS` в контексте системы сборки `ya make` используется для тонкой настройки параметров Java Virtual Machine (JVM), на которой будет запущен сканер SonarQube в процессе анализа кода. Эта опция позволяет передать дополнительные аргументы и свойства JVM непосредственно к процессу сканера SonarQube, тем самым влияя на его работу и поведение.

SonarQube — это платформа для непрерывного анализа качества кода, которая помогает разработчикам находить и исправлять различные проблемы в коде на ранних стадиях разработки. Сканер SonarQube является ключевым компонентом этой системы, анализирующим исходный код на соответствие заранее установленным правилам и стандартам качества.

Как это работает:
При запуске сканера SonarQube через `ya make`, JVM, на которой выполнится сканер, можно настроить, передав дополнительные параметры для оптимизации работы JVM, управления использованием памяти, режимом сборки мусора и другими аспектами выполнения Java-приложений.

 Формат опции:
–sonar-java-args=“аргумент1 аргумент2 … аргументN”
где `аргументы` — это строки, содержащие параметры запуска JVM, такие как параметры памяти (например, `-Xmx512m`), свойства системы (например, `-Dproperty=value`) и другие флаги командной строки JVM.

 Пример использования:
ya make --sonar-java-args=“-Xmx512m -XX:\+UseG1GC -Dsonar.verbose=true”
В этом примере:
\- `-Xmx512m` устанавливает максимальный размер кучи (heap) для JVM в 512 мегабайт, что может быть полезно для анализа больших проектов.
\- `-XX:+UseG1GC` включает сборщик мусора G1, который может улучшить производительность сканера в некоторых случаях.
\- `-Dsonar.verbose=true` включает режим подробных сообщений для сканера SonarQube, что может быть полезно для диагностики проблем с анализом.

 Зачем это нужно:
\- **Оптимизация производительности**: Настройка параметров JVM позволяет оптимизировать производительность сканера SonarQube, особенно при работе с крупными проектами.
\- **Управление потреблением ресурсов**: Адекватное управление использованием памяти и настройка сборки мусора могут помочь избежать проблем с производительностью или сбоями из-за нехватки ресурсов.
\- **Диагностика и отладка**: Включение подробного логирования и других параметров может помочь в разрешении проблем с анализом кода.

 Важные моменты:
\- Необходимо ознакомиться с документацией по доступным параметрам JVM для выбора корректных аргументов в зависимости от используемой версии Java.
\- Стоит быть осторожным с увеличением лимитов памяти, так как это может повлиять на общую производительность системы, особенно при ограниченных ресурсах.
\- Изменения, вносимые через `--sonar-java-args`, могут иметь широкие последствия для работы сканера SonarQube и должны быть тщательно протестированы.


Опция `--get-deps=GET_DEPS` в контексте системы сборки `ya make` используется для компиляции и сбора всех зависимостей текущего проекта и их последующего копирования в указанную директорию. Это особенно полезно для сценариев, когда требуется собрать все необходимые зависимости в одном месте на цели распространения кода, архивации или создания изолированной среды для деплоя или тестирования.

Как это работает:
Когда вы работаете над проектом, особенно в большом и сложном, он может зависеть от множества внешних библиотек, модулей или других проектов. `ya make` с опцией `--get-deps` позволяет автоматически определить все эти зависимости, скомпилировать их при необходимости, и собрать выходные файлы (например, JAR для Java) в одной целевой директории.

Это упрощает управление зависимостями, предоставляя полный набор всех необходимых ресурсов для работы проекта, что является ключевым фактором для обеспечения его переносимости и корректной работы в различных средах исполнения.

 Формат опции:
\--get-deps=путь/к/целевой/директории
где `путь/к/целевой/директории` — это путь к директории, в которую будут скопированы все найденные и собранные зависимости.

 Пример использования:
ya make -t --get-deps=./dependencies
В этом примере все зависимости проекта будут собраны и помещены в директорию `./dependencies` относительно текущего расположения в файловой системе.

Зачем это нужно:
\- **Создание архивов зависимостей**: Упрощение процесса сбора всех внешних и внутренних зависимостей проекта в одном месте для архивации или распространения.
\- **Деплой и развертывание**: Предоставление полного набора необходимых зависимостей для деплоя проекта в новой среде или на другой машине, где нет доступа к общим системам управления зависимостями.
\- **Изоляция среды**: Создание полностью изолированной среды, содержащей все необходимые зависимости, для тестирования или других нужд разработки.

 Важные моменты:
\- **Производительность**: Процесс сбора всех зависимостей может занять значительное время, особенно для крупных проектов с большим числом зависимостей.
\- **Актуальность зависимостей**: Следует убедиться, что все собранные зависимости актуальны и соответствуют требуемым версиям, определенным в проекте.
\- **Управление дубликатами**: При сборе зависимостей в одну директорию может возникнуть проблема дублирования файлов, особенно если разные зависимости включают одни и те же библиотеки или модули.

Опция  кажется уже встречалась, перепроверить было ли в контексте тестирования

Опция `-s` или в расширенной форме `--sources` в контексте системы сборки `ya make` используется для создания JAR-файлов, которые содержат не только скомпилированный байт-код Java классов, но и исходный код этих классов. Эта опция применяется в процессе компиляции и сборки Java-проектов и является особенно полезной для библиотек, которые будут использоваться другими проектами или разработчиками.

Как это работает:
При сборке Java-проектов `ya make` по умолчанию создает JAR-файлы, содержащие скомпилированные классы. Опция `-s` или `--sources` указывает системе сборки также включать в JAR-файл исходный код соответствующих классов. Результатом работы является JAR-файл (или файлы), где в одном архиве совместно расположены и скомпилированный байт-код, и исходные Java-файлы.

Пример использования:
ya make -t -s
или
ya make -t --sources
Эта команда проинструктирует `ya make` собрать проект таким образом, что в результате созданы JAR-файлы будут содержать как скомпилированные классы, так и исходный код.

Зачем это нужно:
\- **Документация и изучение кода**: JAR-файлы с исходным кодом упрощают понимание и изучение кода библиотек, так как разработчики могут просматривать исходный код непосредственно в своей среде разработки (например, в IDE как IntelliJ IDEA или Eclipse), не покидая контекста работы.
\- **Удобство отладки**: Наличие исходного кода в JAR-файлах делает процесс отладки более эффективным, поскольку разработчики могут прослеживать выполнение кода через исходные файлы, лучше понимая логику работы и быстрее находя ошибки.
\- **Лицензирование и распространение**: Для некоторых видов лицензий на программное обеспечение требуется предоставление исходного кода вместе с бинарными файлами, что также упрощается за счет создания JAR-файлов с исходниками.

Важные моменты:
\- **Размер файлов**: Стоит учитывать, что JAR-файлы, содержащие и исходный код, и скомпилированные классы, будут иметь больший размер по сравнению с обычными JAR-файлами, что может повлиять на время скачивания и использования дискового пространства.
\- **Безопасность**: При распространении JAR-файлов с исходным кодом важно учитывать потенциальные риски безопасности и приватности, связанные с предоставлением исходников.
\- **Компромисс между доступностью исходного кода и его защитой**: При работе над закрытыми или коммерческими проектами может потребоваться найти баланс между доступностью кода для отладки и необходимостью его защиты.

Использование опции `-s` или `--sources` обеспечивает добавленную стоимость к JAR-файлам за счет включения исходного кода, упрощая процессы отладки, изучения и соблюдения лицензионных требований.
