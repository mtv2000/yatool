# Опции тестирования
## Запуск тестов
* Опция `-t` используется в командной строке с целью запуска тестов в системах сборки. Эта опция может иметь несколько уточняющих модификаторов, которые позволяют более гранулярно контролировать, какие именно тесты будут запущены. В зависимости от системы сборки или тестовой инфраструктуры, семантика и реализация этих опций может немного отличаться, но базовая концепция остаётся схожей.

 `-t` — Запустить SMALL тесты
Опция `-t` без дополнительных модификаторов указывает системе выполнить запуск тестов, классифицированных как SMALL. 

SMALL тесты обычно включают в себя легковесные тесты, такие как unit-тесты, которые быстро выполняются и не требуют сложной конфигурации окружения или внешних зависимостей. Запуск исключительно SMALL тестов позволяет быстро получить обратную связь о качестве кода без значительного увеличения времени сборки или тестирования и выполняются не более 1 минуты

`-tt` — Запустить SMALL и MEDIUM тесты
Использование двойного модификатора `-tt` расширяет диапазон запускаемых тестов, добавляя к SMALL тестам ещё и те, что классифицированы как MEDIUM. 

MEDIUM тесты могут включать в себя более тяжёлые или затратные по времени проверки по сравнению с SMALL, например, интеграционные тесты и end-to-end тесты. Такая комбинация позволяет выполнить более широкое тестирование без значительного увеличения времени и ресурсов, хоть и с меньшей скоростью обратной связи, чем при запуске только SMALL тестов. Обычно выполняются не более 10 минут.

 `-ttt` — Запустить SMALL, MEDIUM и LARGE тесты
При добавлении третьего модификатора `-ttt` система будет запускать тесты всех размеров: SMALL, MEDIUM и LARGE.

LARGE тесты — это самые затратные по времени и ресурсам тесты. Их выполнение может занимать значительное время, обычно не более 1 часа, но позволяет максимально полно убедиться в качестве и стабильности продукта.

Строгого соответствия между размером тестов (SMALL, MEDIUM, LARGE) и типом тестов (unit, интеграционные, end to end) нет. В первую очередь нужно ориентироваться на максимальное время исполнения каждого теста.

* Опция `-A` или `--run-all-tests` используется для запуска всех доступных тестов в контексте заданной среды сборки или тестирования. Этот флаг тоже, что и `-ttt`

Основное предназначение этой опции — обеспечить комплексную проверку всего проекта путем выполнения всех заранее подготовленных и доступных тестов.
 
* Опция `-L` или `--list-tests` предоставляет функциональность для вывода списка доступных тестов  без их фактического запуска.

Инструмент полезен для получения обзора тестового покрытия проекта, а также для выборочного запуска конкретных тестов при необходимости.

Опция поддерживает выбор размера тестов, а также все параметры фильтрации.

`ya make -AL --regular-tests devtools/examples/tutorials/python`

После выполнения этой команды пользователь получит на стандартный вывод список тестов, доступных для запуска. 

* Опция `--test-threads=TEST_THREADS` используется в контексте автоматизированного тестирования программного обеспечения для управления количеством потоков, которые могут выполнять тесты параллельно.

Значение `TEST_THREADS`, указываемое в качестве параметра опции, определяет максимальное количество тестов, которые будут запущены одновременно. 

На серверах непрерывной интеграции или локальных машинах с ограниченными аппаратными ресурсами может быть целесообразно ограничить число параллельно выполняемых тестов, чтобы избежать излишней нагрузки на систему и потому по умолчанию в параллель запускается не больше 2х тестов.

* Опция `--fail-fast`  указывает инструменту тестирования прервать процесс выполнения тестов сразу же после обнаружения первого провального (непройденного) теста.

Такой подход используется для экономии времени при разработке и диагностике ошибок. Позволяет разработчикам быстро получить информацию о проблемах в коде, не дожидаясь завершения полного цикла тестирования.

`ya make -A --fail-fast devtools/examples/tutorials/python`

При запуске команда останавливает процесс после первого же провального теста и возвращает статус ошибки. Это значит, что оставшиеся тесты не будут запущены, и команда прекращает свою работу, предоставляя пользователю информацию о проваленном тесте.

* Опция `--add-peerdirs-tests=PEERDIRS_TEST_TYPE` представляет собой настройку в инструментах сборки и тестирования, которая определяет, какие тесты из зависимостей (обозначаются через механизм PEERDIR) следует включать в текущую сессию тестирования. Опция позволяет настроить процесс тестирования, выбирая, в какой степени тесты зависимостей должны учитываться при запуске. 

 Параметры `PEERDIRS_TEST_TYPE`:
 - `none`: Тесты из зависимостей не включаются автоматически. Единственные тесты, которые будут запущены, — это те, что явно указаны в текущей цели тестирования. Это поведение по умолчанию, исходя из предположения, что разработчик хочет запустить только тесты, непосредственно связанные с текущим компонентом или изменениями.
 - `gen`: Включаются только тесты, сгенерированные автоматически (например, для проверки API или контрактов интерфейсов) из зависимостей, указанных через `PEERDIR`. Применяется для проверки того, что изменения в текущем компоненте не нарушили ожидаемые правила использования взаимодействующих с ним компонентов.
 - `all`: Включаются все доступные тесты из зависимостей, создающее самое широкое покрытие. Режим полезен при проведении комплексного тестирования перед важными релизами или для проверки интеграции на уровне всего проекта.

* Опция `--split-factor=TESTING_SPLIT_FACTOR` является конфигурационным параметром,  позволяет управлять степенью параллелизма тестов, переопределяя значение параметра `SPLIT_FACTOR`.
* 
`SPLIT_FACTOR` определяет, как тесты могут быть разбиты на более мелкие группы (или “чанки”) для параллельного выполнения.

`SPLIT_FACTOR` является числовым параметром, который указывает величину, на которую могут быть разделены тесты для исполнения в параллельных потоках или процессах. 

Например, если для набора из 100 тестов установлен `SPLIT_FACTOR` равный 10 (значение по умолчанию), эти тесты могут быть разбиты на 10 групп по 10 тестов для параллельного выполнения.

`ya make -tt --split-factor=5`

Эта команда указывает системе тестирования разбить тесты на части таким образом, чтобы каждая часть могла быть исполнена в 5 параллельных потоков или “чанков”, что может привести к ускорению процесса тестирования за счет параллелизма.

* Опция `--test-prepare` предлагает  механизм для подготовки всего необходимого окружения для проведения тестов без их непосредственного запуска. Эта функциональность особенно полезна в контекстах, где требуется предварительная настройка тестового окружения, включая установку зависимостей, конфигурацию данных и создание вспомогательных сервисов, которые могут быть необходимы для успешного выполнения тестов.

Разработчики могут использовать эту опцию для конфигурации локального тестового окружения перед запуском тестов вручную.

После запуска команды `ya make -A --test-prepare` в директории с тестом будет лежать тестовый бинарный файл.
При обычных запусках, этот бинарный файл запускает тестовое окружение, в которое передается нужные параметры и путь до контекстного файла. 

Использование `--test-prepare` разделяет процесс подготовки тестов и их исполнение, что приводит к повышению управляемости тестового процесса.

* Опция `--no-src-changes` устанавливает директиву системе сборки не производить никаких изменений в исходных файлах проекта, гарантируя, что код и структура проекта останутся неизменными после выполнения операции. 

При выполнении тестов некоторые инструменты могут требовать временных изменений в коде или конфигурациях.
Опция `--no-src-changes` гарантирует, что все инструментальные изменения будут проведены с согласия разработчика и позволяет избежать неожиданных последствий в результате автоматизированных операций с кодом.

## Фильтрация
* Опция `-X` или `--last-failed-tests` позволяет автоматически запустить только те тесты, которые были неудачными (то есть “упали” или “провалились”) при последнем выполнении. Эта возможность значительно упрощает процесс исправления ошибок для разработчиков, позволяя быстро перепроверять решения проблем, не тратя время на повторный запуск уже пройденных успешно тестов.

Когда тесты запускаются с использованием данной опции, система тестирования ищет в своей истории о тестах, которые не прошли в последний раз. Затем, из большого пула тестов, выбираются только те, что были помечены как неудачные, и выполняются снова.

Указание дополнительных фильтров (например с помощью -F) расширяет множество тестов, которое будет запущено. Обычно это требуется, когда вы хотите следить за корректным статусом некоторых тестов, помимо перезапуска упавших от предыдущего прогона.

* Опция `-F=TESTS_FILTERS` или `--test-filter=TESTS_FILTERS` используется для тонкой фильтрации и выборочного запуска тестов в рамках большого тестового набора. Позволяет запускать только определённое подмножество тестов, которые соответствуют конкретным критериям.

Фильтры для тестов задаются в виде строк с использованием [специальных символов и паттернов](https://docs.python.org/3/library/fnmatch.html), таких как астериск (`*`) для обозначения любого количества символов и скобок (`[]`) для указания части имени теста или группы тестов. 

Астериск (`*`) служит шаблоном соответствия любому количеству символов в имени теста. Это позволяет выборочно запускать тесты, имена которых начинаются, заканчиваются или содержат определённые фрагменты.

Примеры: 
 - `-F=*DataTest` запустит все тесты, имена которых завершаются на `DataTest`.
 - `-F=Auth*` запустит все тесты, имена которых начинаются с `Auth`.
 - `-F=*Util*` запустит все тесты, содержащие `Util` в любом месте имени.
Шаблоны взяты в одинарные кавычки для того чтобы shell не развернул фильтр в список файлов, которому может соответствовать шаблон.

Использование скобок (`[]`)

Скобки (`[]`) используются для указания конкретных частей имени теста, которые должны быть соответствующим образом фильтрованы. Это может быть полезно для более точечного указания тестов по их порядковым номерам в рамках определённых групп или для реализации других механизмов выборки.

 Пример:
`-F="[X/Y] chunk"`, `--test-filter="[X/Y] chunk"` — фильтрация тестов по chunk'ам. Внутри `[]` можно использовать `*` для фильтрации.

Применение дать возможность разработчикам или тестировщикам эффективно управлять исполнением только тех тестов, которые актуальны для текущей задачи или для заданного контекста разработки.

* Опции `--style` и `--regular-tests` предоставляют возможность гибко управлять запуском тестов в процессе разработки программного обеспечения, фильтруя тесты на основе их типа: либо тесты стиля кода, либо обычные пользовательские тесты.

 `--style` Запуск тестов стиля кода

Опция `--style` используется для запуска тестов, направленных на проверку соответствия кода установленным стандартам и правилам оформления (стиль, линтинг). Это включает в себя автоматическую проверку форматирования кода, правильности использования синтаксиса и прочих аспектов стиля кодирования. 

При этом, с помощью флага `--strip-skipped-test-deps`, также происходит исключение зависимостей для пропущенных тестов, что оптимизирует процесс выполнения проверки стиля.

Поддерживаемые тесты стиля:
 - `classpath.clash`, `clang_tidy`, `eslint`, `gofmt`, `govet`, `java.style`, `ktlint`, `py2_flake8`, `flake8`, `black`, `ruff` Это инструменты для различных языков программирования (Java, C\+\+, JavaScript, Go, Kotlin, Python и т.д.), каждый из которых предназначен для автоматической проверки соответствия кода заранее определённым стилистическим стандартам и правилам.

`--regular-tests` Запуск пользовательских тестов

В противоположность опции `--style`, флаг `--regular-tests` позволяет запустить только те тесты, которые непосредственно проверяют функционал программного продукта, не затрагивая стилевые проверки. 

Поддерживаемые обычные тесты

`fuzz`, `g_benchmark`, `go_bench`, `go_test`, `gtest`, ` `java`, `jest`, `py2test`, `py3test`, `unittest` и [другие] (https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_typetest.md) - представляют собой различные форматы и фреймворки тестирования для проверки функционала на многих языках программирования, включая С\+\+, Go, Java, Python, JavaScript и т.д.

* Опция `--test-size=TEST_SIZE_FILTERS` используется для запуска тестов, которые соответствуют определённым критериям размера. Эта возможность позволяет более точно контролировать объём и длительность тестирования путём выборочного запуска тестов на основе их классификации по размеру.

Размер тестов обычно определяется исходя из их сложности, времени выполнения и требуемых ресурсов:
 - **SMALL**: Тесты, требующие минимум времени и ресурсов для выполнения. Это обычно unit-тесты, которые проверяют функциональность в изоляции от внешних зависимостей.
 - **MEDIUM**: Тесты, занимающие больше времени и ресурсов, чем small-тесты, и могут включать в себя интеграционные тесты, тестирующие взаимодействие между различными частями системы.
 - **LARGE**: Самые затратные по времени и ресурсам тесты, включая системные, функциональные и E2E-тесты, охватывающие множество компонентов или всю систему в целом.

Используя `--test-size=TEST_SIZE_FILTERS`, можно указать, какие именно тесты следует выполнить. Например, параметр может использоваться для запуска только small-тестов в ранних этапах разработки для быстрой проверки изменений, или для выборочного запуска large-тестов перед релизом продукта.

* Опция `--test-type=TEST_TYPE_FILTERS` предназначена для выполнения фильтрации и выборочного запуска тестов в зависимости от их типа. Эта возможность  полезна в сценариях, когда требуется сосредоточить внимание на конкретном аспекте тестирования, например, при необходимости провести только функциональные тесты или только тесты производительности, не затрагивая другие виды тестов. 

Типом теста называется выполнение проверок с использованием одного конкретного инструмента, например, фреймворка pytest для Python или утилиты проверки форматирования кода go fmt для Golang. Полный список типов тестов приведен в [таблице](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_typetest.md)

* Опция `--test-tag=TEST_TAGS_FILTER` предоставляет возможность запускать конкретные тесты, отмеченные определёнными тегами. 

Теги  используются для категоризации и объединения тестов по различным признакам или характеристикам.

--test-tag=TEST_TAGS_FILTER — запускать только сюиты с определёнными тегами. 

Предположим, что в проекте имеются тесты, относящиеся к разработке новой функциональности и отмеченные тегом `feature/new-ui`. Если разработка этой функциональности идёт активно, и требуется часто запускать именно эти тесты, то команда может выглядеть следующим образом: `ya make -A --test-tag=feature/new-ui`
Такая команда запустит только те тесты, которые отмечены тегом `feature/new-ui`, позволяя сосредоточиться именно на текущей задаче.
Перед именами тегов можно использовать `+` для включения тега в фильтр и `-` для исключения. Таким образом `--test-tag tag1+tag2-tag3` запустит все тесты, у которых есть `tag1`, `tag2` и нет `tag3`. Фильтр `--test-tag -tag3` запустит все тесты без тега tag3. Фильтр `--test-tag ya:anytag` запустит все тесты со всеми тегами.

* Опция `--test-filename=TEST_FILES_FILTER` предоставляет возможность фильтрации и запуска тестов на основе имён файлов, содержащих тестовые сценарии.

Параметр актуален только для тестовых фреймворков, таких как `pytest` и `hermione`, которые поддерживают управление выполнением тестов на уровне отдельных файлов, другие тестовые фреймоврки не предоставляют такой информации.

При использовании `--test-filename=TEST_FILES_FILTER`, система тестирования будет искать тесты только среди тех, что расположены в файлах, имена которых соответствуют переданному шаблону, значительно сокращает объём тестов, подлежащих выполнению, и позволяет сфокусироваться на конкретной части кодовой базы или функциональности.

Примеры использования:
Отбор и запуск тестов, находящихся в файлах с определённым префиксом или постфиксом наименования: `ya make -A --test-filename=prefix_.py` 
Запуск тестов из конкретного набора файлов, имена которых точно указаны: `ya make -A --test-filename=test_module1.py`

* Опция `--test-size-timeout=TEST_SIZE_TIMEOUTS` предназначена для настройки продолжительности тайм-аутов для различных категорий тестов в зависимости от их размера.
Тесты классифицируются на несколько категорий (“small”, “medium”, “large”) на основе их ожидаемой продолжительности выполнения и ресурсных требований.
По умолчанию, тайм-аут теста для каждого размера в секундах (small=60, medium=600, large=3600)

Опция `--test-size-timeout` позволяет явно указать максимально допустимое время выполнения для каждой из этих категорий.

Формат значения `TEST_SIZE_TIMEOUTS`  следует шаблону `small=SECONDS, medium=SECONDS, large=SECONDS`, где `SECONDS` задаёт максимально допустимое время выполнения в секундах для тестов соответствующего размера.

Этот пример `–test-size-timeout=small=30,medium=300,large=1800` устанавливает тайм-ауты в 30 секунд для small-тестов, в 300 секунд для medium-тестов и в 1800 секунд для large-тестов.
## Отчет в консоли
* Опция `-P` или `--show-passed-tests` предназначена для вывода детальной информации о тестах, которые были успешно пройдены во время текущего запуска тестового набора. 

В стандартном режиме выполнения тестов сконцентрировано на сообщениях о неудачных тестах, поскольку именно они требуют внимания разработчиков для диагностики и исправления обнаруженных проблем. 

Успешно пройденные тесты часто остаются без дополнительного внимания, и результаты их выполнения выводятся в общем виде, например, в виде общего количества пройденных тестов.

Запуск тестов с отображением результата каждого пройденного теста может выглядеть так:
`ya make -A -P` или `ya make -A --show-passed-tests`

* Опция `--inline-diff`влияет на форматирование и представление различий (diff) между ожидаемыми и фактическими результатами, которые возникают при неудачном прохождении теста.

Включение `--inline-diff` обеспечивает более детальное и удобочитаемое отображение этих различий прямо в выводе в терминале, предоставляя построчное сравнение с подсветкой конкретных изменений или различий.

* Опция `--show-metrics` предназначена для отображения метрик тестирования в консоли в процессе выполнения тестов. 

Метрики тестирования могут включать в себя различную информацию, такую как время выполнения теста, использование памяти, количество запросов к базе данных, производительность API и другие значимые данные, которые помогают оценить не только корректность работы программного обеспечения, но и его эффективность.

При использовании этой опции, после завершения каждого теста или группы тестов, в выводе в консоль будут показаны собранные метрики для них. 

Чтобы увидеть метрики для успешно пройденных тестов, необходимо также использовать опцию `-P` (`--show-passed-tests`). Это связано с тем, что по умолчанию  в консоль выводиться информацию только о проваленных тестах, ограничивая вывод для успешных тестов общим итогом их количества. 

Опция `-P` показывает детальную информацию о каждом выполненном тесте, включая успешно пройденные, и, соответственно, когда используется вместе с `--show-metrics`, позволяет видеть собранные метрики и для успешных тестов.

`ya make -A -P --show-metrics` -  при выполнении каждого теста в консоль выводились детали по пройденным и не пройденным тестам, а также метрики, связанные с каждым из этих тестов.

* Опция `--disable-flake8-migrations` является настройкой, используемой в контексте тестирования и проверки кода с помощью утилиты `flake8`.

Все python-файлы, используемые в сборке и тестах, подключаемые через `ya.make` в секциях `PY_SRCS` и `TEST_SRCS`, автоматически проверяются линтером `flake8`. 

Он помогает идентифицировать ошибки стиля, сложности кода и потенциальные баги, проверяя код на соответствие рекомендациям PEP 8 и другим общепринятым стандартам написания кода.

`flake8` предоставляет возможность исключения или временного отключения определённых проверок (линтов), которые могут быть не всегда релевантны или предпочтительны для конкретных проектов или стадий разработки. Функциональность “миграций `flake8`” (также известная как “включение или отключение проверок `flake8`”) позволяет поэтапно вводить или исключать различные проверки для облегчения процесса адаптации кодовой базы к строгим стандартам.

Опция `--disable-flake8-migrations` используется для явного указания инструмента `flake8` игнорировать все настройки миграций (`flake8` migrations), которые могли быть определены разработчиками или командой проекта для поэтапного введения или отключения конкретных правил проверки. Эта опция “включает все проверки `flake8`”, тем самым применяя полный набор доступных проверок стиля и качества кода без исключения. 

В процессе разработки или при подготовке кода к финальной проверке перед слиянием в основную ветку проекта, разработчик может использовать эту опцию для гарантии того, что весь код полностью соответствует стандартам и рекомендациям.

 `ya make -A --disable-flake8-migrations path/to/module.py` 

Эта команда выполнит `flake8` проверку для файла `module.py`, применив ко всему коду полный набор правил без учёта ранее заданных миграций.

* Опция `--disable-jstyle-migrations` предназначена для использования в среде разработки Java и управляет применением проверок стиля кода.

Цель данной опции — включение всех доступных проверок стиля для Java кода, игнорируя любые ранее заданные “миграции” или исключения. 
В контексте стилевых проверок “миграции” часто используются для поэтапного внедрения новых стандартов стиля кодирования или для временного отключения определённых правил в процессе рефакторинга или при внесении значительных изменений в кодовую базу.

Для включения всех стилевых проверок Java в процессе тестирования или проверки кода, разработчик может добавить эту опцию в командную строку используемого инструмента анализа кода или сборки, например: `ya make -A --disable-jstyle-migrations`

## Канонизация
Канонизация тестов - это процесс объединения и стандартизации различных версий тестовых случаев, чтобы устранить возможные дубликаты и противоречия. Она также включает в себя подтверждение того, что каждый тестовый случай соответствует установленным стандартам и правилам создания тестов. 

* Опция `-Z` или `--canonize-tests` предназначена для канонизации результатов выполнения тестов.

Канонизация позволяет зафиксировать текущие результаты выполнения теста в качестве правильных (эталонных), с которыми в дальнейшем будет сравниваться вывод теста при его повторных запусках.

Тесты описываются в ya.make файлах в макросе `RUN`, где можно указать путь до файла с эталонными данными с помощью `CANONIZE_LOCALLY`:
```
OWNER(g:some-group)

EXECTEST() # Объявляем Exec-тест

RUN( # Команда, которую хотим выполнить
    cat input.txt
CANONIZE_LOCALLY ${TEST_CASE_ROOT}/test.out # Путь до файла с эталонными данными (будет сохранен в подкаталог canondata)
CANONIZE_DIR_LOCALLY ${TEST_CASE_ROOT}/dir # Путь до директории с эталонными данными (будет сохранен в подкаталог canondata)
)

DATA( # Тестовые данные (здесь лежит input.txt)
    path/devtools/ya/test/tests/exectest/data
)

# Текущий каталог для теста (каталог с input.txt)
TEST_CWD(path/devtools/ya/test/tests/exectest/data)

END()
```
В режиме ` -Z (--canonize-tests)` вместо сравнения данных с эталонными, сами эталонные данные будут заменены.  В локальное рабочее пространство будут внесены все необходимые изменения.

* Опция `--canon-diff=TEST_DIFF` используется для того, чтобы сравнить канонические данные тестов между различными состояниями кодовой базы. Это позволяет разработчикам и тестировщикам увидеть, как изменения в коде повлияли на результаты тестов, и помогает выявить регрессии или непреднамеренные эффекты от внесенных изменений.

Возможные значения для `TEST_DIFF` включают `rev1:rev2`, `HEAD`, и `PREV.
 * `--canon-diff=rev1:rev2`: Сравнить канонические данные между ревизиями `rev1` и `rev2`.
 * `--canon-diff=HEAD`: Сравнить текущие канонические данные с данными последней ревизии в текущей ветке.
 * `--canon-diff=PREV`: Сравнить канонические данные текущего состояния с данными состояния перед последним коммитом.

Для того, чтобы посмотреть, как менялся канонический результат теста, нужно прогнать конкретный тест в режиме `--canon-diff` командой `ya make -t --canon-diff PREV`.

Можно передать имя теста через параметр `-F(--test-filter)`, для этого можно сначала вывести список тестов в текущей папке `path/ya make -t --canon-diff HEAD -L`

* Опция `--canonize-via-http` предназначена для использования в процессе канонизации тестов, когда необходимо загрузить большие объемы канонических данных. Опция указывает системе, что для загрузки этих данных следует использовать протокол HTTP.

## Отладка
* Опция `--pdb` используется в контексте выполнения тестов, написанных на Python, и предназначена для автоматического запуска отладчика Python (pdb - Python Debugger) в случае возникновения ошибок во время выполнения теста.

Это позволяет разработчикам немедленно перейти к отладке проблемы, не прерывая процесс тестирования.

Чтобы передать управление `pdb` в произвольном месте, можно написать в коде `import pdb; pdb.set_trace()`, для `Python 3` можно использовать более короткий вариант `breakpoint()`.

Для активации `pdb` при возникновении ошибок, добавьте `--pdb` к команде запуска: `ya make -ttt --pdb`

Если во время выполнения произойдет ошибка, выполнение тестов остановится, и вы автоматически войдете в интерактивную сессию `pdb`. В этой сессии можно будет использовать команды `pdb`, такие как `list` для просмотра кода, `where` для просмотра стека вызовов, `next` и `step` для шагов выполнения кода, и `print` для вывода значений переменных.

* Опция `--gdb` позволяет автоматически запустить Python-тесты в среде GNU Debugger (GDB), когда это необходимо.
При этом `GDB` получит управление перед запуском тестов, а `pdb` только при срабатывании проверки.

Пример использования `ya make -ttt --gdb`

* Опция `--dlv` используется для запуска тестов для языка программирования Go и позволяет автоматически запустить тесты в отладчике `Delve` (dlv).

`Delve` является отладчиком для Go программ, предоставляющим возможности для пошагового выполнения кода, просмотра состояния переменных, управления точками останова и других действий, необходимых для детального анализа выполнения программы и поиска ошибок.

* Опция `--test-debug` предназначена для использования в процессе тестирования программного обеспечения, обеспечивая разработчикам расширенные возможности для отладки тестов. Эта опция включает ряд параметров, оптимизирующих процесс запуска тестов для удобства отладки, и предоставляет дополнительную информацию, полезную при диагностике проблем.

При использовании опции `--test-debug`, система тестирования автоматически применяет несколько дополнительных параметров к процессу выполнения тестов:

 1. **–test-threads=1**: Устанавливает количество потоков (threads) для выполнения тестов равным 1. Это означает, что все тесты будут выполняться последовательно, один за другим. Последовательное выполнение упрощает процесс отладки, поскольку исключает возможные проблемы, связанные с параллельным выполнением тестов, такие как состояние гонки (race condition).
 2. **–test-disable-timeout**: Отключает тайм-ауты для тестов. Это позволяет избежать автоматического прерывания теста по истечении времени выполнения, что важно при отладке, когда разработчику может потребоваться больше времени для анализа состояния программы или выполнения дополнительных действий в отладчике.
 3. **–retest**: Принудительно повторно выполняет все тесты, даже если они не были изменены. Это гарантирует, что при каждом использовании `--test-debug` тесты будут запущены, независимо от результатов предыдущих запусков.
 4. **–test-stderr**: Перенаправляет стандартный поток ошибок (stderr) тестов в стандартный вывод (stdout) или делает его видимым в выводе тестов. Это обеспечивает, что все сообщения об ошибках, предупреждения и другая диагностическая информация, выводимая тестами, будут непосредственно доступны для анализа.

Помимо вышеупомянутых настроек, опция `--test-debug` также печатает идентификатор процесса (PID) каждого запущенного теста. Эта информация может быть полезна для прикрепления отладчика к конкретному процессу теста для детального анализа его выполнения в реальном времени.

* Опция `--dlv-args=DLV_ARGS` предназначена для использования в контексте запуска Go юнит-тестов в отладчике `Delve` (dlv) и позволяет передать дополнительные аргументы командной строки непосредственно в `Delve`.

Когда вы используете `--dlv` для запуска тестов в `Delve`, `--dlv-args=DLV_ARGS` позволяет уточнить поведение `Delve`, добавив специфические для отладчика параметры. Это может включать в себя настройки логирования, управления сессией отладки, опции для точек останова и другие возможности `Delve`, которые могут быть полезны для конкретной задачи отладки.

* Опция `--test-retries=TESTS_RETRIES` предоставляет возможность автоматически повторять выполнение тестов, которые завершились неудачно, указанное количество раз (по умолчанию: 1).

Эта функциональность чрезвычайно полезна в ситуациях, когда тесты могут иногда завершаться сбоем из-за нестабильных условий окружающей среды, временных проблем с сетью, ресурсами системы или другими внешними факторами, не связанными напрямую с логикой тестируемого программного обеспечения.

При запуске тестов с использованием этой опции, система тестирования выполнит все указанные тесты и отслеживает те из них, которые завершились неудачно. 

Если какой-либо тест не прошел успешно, система автоматически попытается повторить его выполнение. Количество повторений для каждого неудачного теста задается значением `TESTS_RETRIES`. Например, если указано `--test-retries=2`, то каждый тест, который не прошел, будет автоматически повторен до двух раз в дополнение к его первоначальному запуску.

Предположим, вы работаете над проектом и хотите автоматически повторять неудачные тесты до трех раз в случае их сбоя. Для этого вы можете использовать следующую команду: `ya make -A --test-retries=3`

Эта команда запустит тестовый набор и, в случае неудачи любого теста, попытается повторить его выполнение до трех раз. Если тест проходит успешно в одной из попыток, он считается пройденным и система переходит к следующему тесту.

* Опция `--test-stderr`  предназначена для того, чтобы выводить стандартный поток ошибок (stderr) тестов непосредственно в консоль в реальном времени. Это позволяет разработчикам и тестировщикам наблюдать за всеми сообщениями об ошибках, предупреждениями и другой важной диагностической информацией, генерируемой тестами, без необходимости ожидания завершения всего набора тестов или изучения лог-файлов после их выполнения.

`ya make -t --test-stderr` - команда активирует вывод stderr тестов в консоль, позволяя вам наблюдать за возможными сообщениями об ошибках в режиме реального времени.

* Опция `--test-stdout` позволяет выводить стандартный поток вывода (stdout) тестов непосредственно в консоль в реальном времени. Это дает возможность разработчикам и тестировщикам наблюдать за всеми сообщениями, логами и другой информацией, генерируемой тестами, сразу же во время их выполнения.

Когда тесты запускаются с использованием этой опции, система тестирования перенаправляет все, что тесты пишут в стандартный поток вывода (stdout), непосредственно в консоль или терминал, из которого были запущены тесты.

Допустим, вы работаете над проектом и хотите запустить тесты, при этом видеть результаты выполнения тестов (вывод тестов) в консоли в реальном времени. Использование опции `--test-stdout` может выглядеть так: `ya make -ttt --test-stdout`

Эта команда заставит тестовую систему выводить в консоль все сообщения из stdout каждого теста, позволяя вам отслеживать ход выполнения тестов и немедленно реагировать на возникающие проблемы или ошибки.

* Опция `--test-disable-timeout` позволяет отключить механизм тайм-аута для тестов.

Это означает, что тесты не будут автоматически прерваны системой тестирования, если они превышают определенное время выполнения. 

В обычных условиях, `ya make` имеет настройку тайм-аута, чтобы ограничить максимальное время выполнения каждого теста. Это предотвращает “зависание” тестов и обеспечивает более эффективное использование ресурсов тестовой среды. Тайм-аут может быть задан глобально для всего набора тестов или индивидуально для каждого теста.

При использовании опции `--test-disable-timeout`, механизм тайм-аута отключается, и тесты могут выполняться неограниченное время. 

Опция `--test-disable-timeout` предназначена для использования толтко в локальной среде разработки и не рекомендуется к использованию при распределенном выполнении тестов (`--dist`).

Также эта опция несовместима с опцией `--cache-tests`, которая предполагает кеширование результатов тестов для ускорения последующих запусков.
 
* Опция `--test-binary-args=TEST_BINARY_ARGS` обеспечивает возможность передачи произвольных аргументов командной строки непосредственно в исполняемый файл теста (тестовый бинарный файл). Это позволяет настраивать поведение тестов на более глубоком уровне, используя механизмы, предусмотренные в самом тестовом приложении.

При запуске тестов с использованием этой опции, указанные аргументы (`TEST_BINARY_ARGS`) будут переданы в исполняемый файл теста как аргументы командной строки. Тестовое приложение может затем обрабатывать эти аргументы согласно своей внутренней логике, позволяя влиять на различные аспекты его выполнения.

Предположим, что ваше тестовое приложение поддерживает аргумент командной строки `--config`, который позволяет указать путь к файлу конфигурации. Вы хотите запустить тесты с использованием конкретного конфигурационного файла. Для этого вы можете использовать следующую команду: `ya make -A --test-binary-args=“–config=/path/to/config/file”`

В этом примере, аргумент `--config=/path/to/config/file` будет передан непосредственно в исполняемый файл теста, позволяя тестам использовать указанный файл конфигурации.

* Опция `--dump-test-environment` позволяет получить детальный снимок содержимого корня сборки теста, организованного в формате дерева, и записать эту информацию в файл `run_test.log` перед фактическим выполнением обертки теста.

При запуске тестов с этой опцией, система тестирования автоматически генерирует представление файловой структуры корневого каталога сборки теста в виде дерева. Это представление включает в себя все файлы, директории и их вложенные элементы, доступные в момент запуска теста. Сгенерированная информация затем записывается в файл `run_test.log`, который можно использовать для последующего анализа.

Допустим, вы столкнулись с проблемой, когда тест неожиданно не проходит из-за отсутствия определенного файла конфигурации в среде выполнения. Чтобы диагностировать эту проблему, вы можете запустить тесты с опцией `--dump-test-environment`, чтобы получить полное представление о содержимом корня сборки.

После выполнения тестов вы можете открыть файл `run_test.log` и изучить структуру директорий и файлов, доступных во время тестирования. Это поможет вам определить, отсутствует ли необходимый файл конфигурации или возможно он расположен в неправильном месте.

* Опция `--no-random-ports` используется для запуска сетевых тестов, которым требуются конкретные порты для их выполнения.

Использование опции `--no-random-ports` позволяет явно указать системе тестирования использовать порты, заданные разработчиком. 

Это дает разработчикам контроль над сетевыми настройками тестовой среды и упрощает интеграцию тестов с определенными сетевыми условиями или конфигурациями.

* Опция `--disable-test-graceful-shutdown` используется для управления поведением тестового процесса в случае возникновения тайм-аута. Эта опция указывает системе тестирования, что в случае превышения заданного времени выполнения теста, тестовый процесс (узел теста) должен быть немедленно прекращен (“убит”) без попытки его “мягкой” остановки или корректного завершения.

Когда тест превышает заданное время выполнения (тайм-аут), система пытается корректно завершить тестовый процесс, давая ему возможность освободить занятые ресурсы, закрыть открытые соединения и корректно завершить работу. 

Это называется “мягким” завершением работы или “graceful shutdown”. Однако, в некоторых случаях, такое поведение может быть не предпочтительным или неэффективным, например, если процесс теста “завис” и не реагирует на попытки его корректного завершения.

Использование опции `--disable-test-graceful-shutdown` отключает механизм “мягкого” завершения работы тестового процесса. Вместо этого, в случае возникновения тайм-аута, система тестирования немедленно отправляет сигнал на принудительное завершение процесса, что обычно приводит к его мгновенному прекращению.

## Среда выполнения
* Опция `--test-param=TEST_PARAMS` предоставляет возможность передачи произвольных параметров непосредственно в тесты, передавая в них параметры из командной строки.

При использовании этой опции, вы можете передать один или несколько параметров в формате `name=val`, где `name` — это имя параметра, а `val` — его значение. Эти параметры будут доступны внутри тестов, позволяя изменять их поведение в зависимости от переданных значений.

Пример использования: `ya make -t --test-param db_endpoint=localhost:1234`

* Опция `--autocheck-mode` предназначена для запуска тестов в локальной среде с набором ограничений, характерных для среды autocheck.

Включение `--autocheck-mode` автоматически активирует несколько ключевых ограничений и настроек:

 1. **–private-ram-drive**: Создает изолированный RAM-диск для каждого теста, что позволяет избежать взаимного влияния тестов друг на друга из-за файловой системы и гарантирует, что файлы, созданные или измененные одним тестом, не будут видны или доступны другим тестам. Это способствует повышению изоляции и надежности тестов.

 2. **–private-net-ns**: Использует изолированное сетевое пространство имен для каждого теста, обеспечивая, таким образом, что сетевые операции, выполняемые в рамках одного теста, не влияют на другие тесты. Это особенно важно для тестов, которые предполагают взаимодействие с сетью или определенные сетевые настройки.

* Опция `--private-ram-drive`  создавает для каждого тестового узла частный RAM-диск. 

При активации этой опции система сборки автоматически создает виртуальный диск в оперативной памяти (RAM-диск) для каждого узла тестирования, который его запрашивает. Все операции чтения и записи в рамках теста производятся на этом RAM-диске. Поскольку оперативная память обеспечивает значительно более высокую скорость чтения и записи данных по сравнению с традиционными жесткими дисками или даже SSD, использование RAM-диска может существенно сократить время, необходимое для выполнения операций ввода-вывода, и, как следствие, ускорить выполнение тестов.

* Опция `--private-net-ns` предназначена для создания изолированного сетевого пространства имен (network namespace) для каждого запускаемого теста.

Особенностью создаваемого сетевого пространства имен является поддержка `localhost`, что позволяет тестам взаимодействовать с сервисами, запущенными на локальной машине, но при этом изолировать их сетевые взаимодействия друг от друга.

## Расчет UID теста

* Опция `--cache-tests` позволяет сохранять результаты успешно выполненных тестов в кеше и при последующих запусках тестов избегать повторного выполнения тех, результаты которых уже присутствуют в кеше и считаются актуальными.

Когда эта опция активирована, система тестирования выполняет следующие действия:

 1. **Проверка Кеша**: Перед выполнением теста система проверяет наличие его результатов в кеше.
 2. **Пропуск Тестов**: Если результаты теста уже присутствуют в кеше и считаются валидными (то есть код, связанный с тестом, не был изменен с момента последнего успешного выполнения), тест пропускается.
 3. **Выполнение и Кеширование**: Тесты, для которых в кеше нет актуальных результатов, выполняются, а их результаты после успешного завершения сохраняются в кеше для использования в будущих запусках.

Все style-тесты по умолчанию кешируются, что эквивалентно команде `ya make - ttt --style --cache-tests`. 
Это значит, что при перезапуске `ya make` без изменения исходного кода style-тесты не будут перезапускаться, а вернут результат из кеша. Это сделано для ускорения локального прогона style-тестов, которые являются быстрыми и стабильными. Для принудительного перезапуска тестов нужно добавить ключ `--retest`.

* Опция `--retest` предназначена для принудительного повторного выполнения всех тестов, игнорируя любые результаты, которые могли быть сохранены в кеше от предыдущих запусков. Это значит, что независимо от того, был ли тест успешно выполнен ранее и его результат сохранен в кеше, при использовании этой опции система тестирования выполнит тест заново.

Когда тесты запускаются с использованием опции `--retest`, механизм кеширования результатов тестов игнорируется. Система тестирования будет вести себя так, как если бы она запускалась в первый раз, без доступа к предыдущим результатам. Все тесты в наборе запускаются заново, и их результаты обновляются в соответствии с текущим состоянием кодовой базы и тестовой среды.

## Зависимости тестов

* Опция `-b` или `--build-all`  указывает системе сборки собрать все цели, которые могут быть достигнуты через директивы `RECURSE` в `ya.make` файле, даже если эти цели не требуются непосредственно для запуска текущих тестов.

При вызове системы сборки с опцией `-b` или `--build-all`, система анализирует `ya.make` файлы на предмет директив `RECURSE`, прослеживая все возможные пути сборки до каждого компонента проекта.

Это включает в себя все библиотеки, программы, тесты и прочие цели, которые можно собрать. В результате, процесс сборки охватывает весь проект в полном объеме, не ограничиваясь только требуемыми для тестирования компонентами.

Предположим, у вас есть проект со множеством модулей, и вы хотите убедиться, что недавно внесенные изменения не поломали сборку других не связанных напрямую с тестами компонентов. Вызывая команду: `ya make -t -b` вы инициируете полную сборку проекта, что позволит обнаружить и предотвратить возможные проблемы. 

* Опция `--build-only-test-deps`  позволяет оптимизировать процесс сборки, фокусируясь исключительно на тех компонентах системы, которые необходимы для выполнения заданных тестов. 

При запуске системы сборки с этой опцией, механизм сборки проанализирует зависимости тестов, которые были запрошены для выполнения. Включение только необходимых для тестов зависимостей позволяет исключить из сборочного процесса все лишнее, что не имеет отношения к текущему тестовому прогону.

Вместо того, чтобы следовать всем путям в директивах `RECURSE` и собирать весь проект полностью, система сборки сфокусирована только на той части проекта, которая действительно используется в тестах.

Предположим, разработчик внес изменения в модуль и хочет запустить только тесты, относящиеся к этому модулю, не собирая остальную часть проекта. В этом случае команда для сборки и тестирования будет выглядеть так:

 `ya make -t --build-only-test-deps path_to_tests`

Здесь `path_to_tests` – это идентификатор или путь к тестам, которые необходимо выполнить. Система сборки выполнит анализ, определит, какие компоненты проекта требуются для выполнения данного набора тестов, и соберет только их.

* Опция `--strip-skipped-test-deps` позволяет исключить из процесса сборки зависимости тех тестов, которые по тем или иным причинам будут пропущены. 

Это означает, что система сборки не будет тратить время и ресурсы на подготовку тестов и их зависимостей, которые итак не будут выполнены.

* Опция `--strip-idle-build-results` позволяет системе сборки удалить результаты сборки, которые в конечном итоге не используются непосредственно для запуска тестов. 

Когда вы запускаете систему сборки с включенной опцией `--strip-idle-build-results`, в процессе сборки система отслеживает, какие именно результата сборки требуются для успешного выполнения заданных тестов. По завершении процесса сборки, вся информация о “лишних” узлах, которые не связаны с запуском тестов — удаляется.

* Опция `--no-strip-idle-build-results` указывает сохранить все результаты сборки, включая те, которые не нужны для прямого запуска тестов. Эта опция является противоположностью к `--strip-idle-build-results`, о которой шла речь ранее.

Применяется при полной сборке проекта (включая все модули и тесты) для проведения комплексной проверки перед релизом. В этом случае команда сборки может быть запущена с опцией `--no-strip-idle-build-results`, что гарантирует сохранение всех результатов сборки.

Синтаксис: `ya make -A --no-strip-idle-build-results`

## Отчеты в файлах

* Опция `--junit=JUNIT_PATH` предназначена для генерации отчёта о результатах выполнения тестов в формате JUnit.

При запуске тестов с указанием этой опции, система сборки выполняет все запрашиваемые тесты, а затем агрегирует информацию о прохождении каждого теста, результаты (удачные и неудачные исполнения), время выполнения и возможные сообщения об ошибках в один отчет в формате XML, соответствующем спецификации JUnit.

`JUNIT_PATH` здесь — это путь к файлу, куда будет записан сгенерированный отчет.

Предположим, что вы разрабатываете проект и используете систему сборки для запуска тестов. Вы хотите получить отчет о результатах тестирования в формате JUnit для интеграции с Jenkins. В этом случае вы можете добавить опцию в вашу команду запуска тестов следующим образом: `ya make -t --junit=/pat_to_your_project/test-results/results.xml`

После выполнения команды в указанном месте будет создан файл XML с отчетом о результатах тестирования в формате JUnit, который затем может быть импортирован в Jenkins или любую другую систему, поддерживающую анализ JUnit отчетов.

## Выходные данные теста

* Опция `--no-test-outputs`  используется для контроля над сохранением выводов тестов, а именно файлов и данных, которые тесты могут генерировать в процессе их выполнения. 

Опция `--no-test-outputs` представляет собой директиву системе сборки, указывающую не сохранять вышеупомянутые файлы и данные, созданные во время тестирования. 

 `ya make -t --no-test-outputs` - в этом случае система сборки выполнит все запрашиваемые тесты, но не сохранит никаких файлов, созданных в процессе их выполнения.

* Опция `--dir-outputs-in-nodes`  обеспечивает поддержку директорий в качестве выходных данных узлов сборки. Это означает, что при включении этой опции система сборки может обрабатывать целые директории как результат выполнения задачи сборки, а не только отдельные файлы.

В обычном режиме работы системы сборки каждый узел (или задача сборки) генерирует один или несколько файлов в качестве выходных данных. 

`ya make --dir-outputs-in-nodes /path/to/source/images/directory /path/to/destination/optimized/images/directory`

В этом случае система сборки обработает генерацию оптимизированных изображений, рассматривая всю директорию `/path/to/destination/optimized/images/directory` как выходной результат работы узла, а не каждый файл по отдельности.

* Опция `--test-node-output-limit=TEST_NODE_OUTPUT_LIMIT` используется для установления ограничения на максимальный размер файлов вывода, которые генерируются в процессе выполнения тестов.

Это позволяет контролировать объём данных, сохраняемых после работы тестов, важно для управления использованием дискового пространства, особенно в условиях ограниченных ресурсов или при работе с большим количеством тестов.

При выполнении теста система сборки отслеживает размер файлов вывода, генерируемых каждым тестовым узлом. Если объём данных превышает установленный лимит `TEST_NODE_OUTPUT_LIMIT`, указанный в байтах, система может обрезать эти файлы до указанного размера или же не сохранять часть вывода, превышающую этот лимит. В результате, для каждого теста сохраняется лишь наиболее важная часть вывода, позволяя снизить потребление ресурсов хранения.

* Опция `--test-keep-symlinks` разработана для управления сохранением символических ссылок, которые возникают в ходе выполнения тестов. При использовании этой опции система сборки не будет удалять символические ссылки из выходных данных теста, что может быть полезно в различных сценариях разработки и тестирования.

Символические ссылки (или симлинки) — это файлы, которые указывают на другие файлы или директории в файловой системе. Они могут использоваться в процессе тестирования для имитации определённых структур файловой системы, обращения к файлам без копирования реального содержимого или создания контролируемых условий тестовой среды.

При запуске тестов с этой опцией система сборки изменяет своё стандартное поведение таким образом, чтобы символические ссылки, созданные в процессе выполнения тестов, не удалялись после их завершения. Это означает, что вся структура директорий, файлы и симлинки, созданные или использованные тестами, будут сохранены в их исходном виде, давая возможность для последующего анализа или использования.

## Покрытие кода

Покрытие кода в системах сборки — это метрика, используемая для измерения степени, в которой исходный код программы испытан автоматическими тестами. Она выражается в процентах и показывает, какая часть кода была выполнена при запуске тестов, помогая определить не протестированные участки кода.

* Опция --coverage-verbose-resolve управляет выводом детальных отладочных логов во время процесса разрешения данных о покрытии, то есть на этапе, когда анализируются собранные данные о покрытии, обрабатываются файлы покрытия и готовится итоговый отчет о покрытии кода тестами.

* Опция `--merge-coverage` используется для объединения всех найденных данных о покрытии, обычно распределенных по разным файлам, в единый совокупный файл покрытия. Это позволяет агрегировать информацию о покрытии кода из разных источников или тестовых прогонов в один удобный для анализа документ.

* Опция `--coverage-report-path=COVERAGE_REPORT_PATH` используется для указания конкретного пути относительно каталога вывода (output directory), куда будет сохранен отчет о покрытии кода. 

* Опция `--enable-contrib-coverage` предназначена для расширения процесса сбора данных о покрытии кода в проектах, зависящих от внешних библиотек или компонентов, загруженных из каталога `contrib` в системе сборки. Эта опция влияет на то, как собираются эти внешние компоненты и какие дополнительные действия выполняются для генерации данных о покрытии кода этими компонентами.

* Опция `--fast-clang-coverage-merge` используется при сборке и запуске тестов с поддержкой покрытия кода, в частности, когда осуществляется сбор информации о покрытии `Clang source-based coverage`. Данная опция предназначена для оптимизации процесса мержа (объединения) профилей покрытия, собранных во время выполнения различных тестов или исполняемых файлов.

Опция `--fast-clang-coverage-merge` использует FUSE (Filesystem in Userspace) механизм для того, чтобы процедура обьединения происходила “на лету”, прямо во время выполнения тестов, что значительно ускоряет процесс. FUSE позволяет создавать виртуальные файловые системы, управляемые пользовательскими программами. В контексте объединения профилей покрытия это означает, что вместо физического создания промежуточных файлов профилей на диске, все операции с профилями происходят в памяти. Это позволяет минимизировать затраты на ввод/вывод и ускорить подготовку итогового отчета о покрытии.

* Опция `--sancov` представляет собой параметр системы сборки, который активирует сбор данных о покрытии кода при помощи инструментов санитайзеров (Sanitizers). 

Санитайзеры — это инструменты, обеспечивающие динамический анализ кода для выявления различных видов ошибок, таких как обращения за границы массивов, использование неинициализированной памяти и других.

При использовании опции `--sancov`, основное внимание уделяется построению отчетов о покрытии кода на основе анализа, проведенного данными инструментами.
Время тестов увеличивается в 1.5 раза.

* Опция `--coverage-exclude-regexp=COVERAGE_EXCLUDE_REGEXP`  позволяет явно указать регулярное выражение (regexp) на 
соответствующие типы файлов, которые следует исключить из отчета о покрытии кода. 

При активации этой опции и выполнении тестов с параллельным сбором данных о покрытии кода, система сборки применит заданное регулярное выражение для фильтрации типов файлов и они будут исключены из финального отчета о покрытии кода. 

* Опция `--coverage-prefix-filter=COVERAGE_PREFIX_FILTER` предназначена для фильтрации для создания отчета о покрытии, например, `devtools/ya` - если интересует покрытие только определенных участков репозитория.

* Опция `--coverage-report` используется для создания подробного отчёта о покрытии кода в формате HTML, который является визуальным и удобным средством для анализа покрытия кода тестами.

* Опция `--clang-coverage`  используется для активации сбора информации о покрытии кода (code coverage) для проектов с использованием компилятора Clang. (Автоматически увеличивает время выполнения в полтора раза)

* Опция `--java-coverage`  предназначена для сбора данных о покрытии кода в проектах на языке программирования Java.

Допустим, вы разрабатываете Java-проект и хотите убедиться в том, что ваши тесты покрывают достаточный объем кода. В этом случае вы бы использовали команду сборки с опцией `--java-coverage`, чтобы активировать сбор данных о покрытии:

`ya make -t --java-coverage`

После выполнения тестов система сборки сгенерирует отчет о покрытии кода, который вы можете просмотреть, чтобы оценить эффективность текущих тестов и определить области кода без достаточного покрытия.

* Опция `--go-coverage` в системе сборки применяется для сбора информации о покрытии кода в проектах, написанных на языке программирования Go. 

* Опция `--ts-coverage` в системе сборки служит для сбора информации о покрытии кода специально для проектов на TypeScript.

* Опция `--python-coverage` используется для сбора информации о покрытии кода для проектов, написанных на Python, в рамках процесса тестирования. 

Если, ваш проект содержит множество Python модулей, и вы хотели бы получить общее представление о покрытии кода тестами, запустите следующую команду в системе сборки: `ya make -t --python-coverage`

После выполнения тестов система сборки генерирует отчет о покрытии кода, который можно анализировать для дальнейших улучшений в тестовом покрытии.

## Fuzzing (методика фаззинга)

* Опция `--fuzzing` используется для активации процесса фаззинга, то есть автоматического тестирования приложения или его компонентов путем подачи на вход большого количества случайных, некорректных или неожиданных данных. 

Цель фаззинга - выявление ошибок, уязвимостей или нестабильностей в работе тестируемого кода, которые могут проявляться при непредвиденных условиях ввода.

* Опция `--fuzz-case=FUZZ_CASE_FILENAME` предназначена для указания конкретного тестового случая (case) или файла с данными, который будет использоваться при фаззинге тестируемого компонента или приложения. Эта опция предназначена для ситуаций, когда необходимо запустить фаззер с конкретным набором данных, а не позволять ему генерировать данные случайным образом, как это происходит в режиме стандартного фаззинга (`--fuzzing`).

* Опция `--fuzz-opts=FUZZ_OPTS` представляет собой  способ настройки процесса фаззинга за счет предоставления возможности напрямую передавать специальные параметры или опции в инструмент фаззинга. Эти параметры могут контролировать поведение фаззера, например, изменяя стратегию генерации данных, устанавливая ограничения времени или памяти на исполнение.

Запуск опции `--fuzz-opts="-max_total_time=7200"` стартует процесс фаззинга, который будет длиться 2 часа (7200 секунд). В течение этого времени фаззинг инструмент будет генерировать и тестировать случайные входные данные для поиска ошибок или необычного поведения в коде. Если будут найдены интересные случаи, они будут автоматически закоммичены в корпус соответствующего проекта, что позволит фиксировать и анализировать эти случаи для дальнейшей отладки и улучшения программы.

* Опция `--fuzz-minimization-only` запускает процедуру минимизации корпуса без фаззинга. Опцию следует использовать в паре с `--fuzzing`

* Опция `--fuzz-local-store` используется для сохранения результатов локально на машине, где выполняется тест.

* Опция `--fuzz-runs=FUZZ_RUNS` включает автоматическую генерацию входных данных для программы в целях обнаружения ошибок обработки этих данных.

`ya make -t --fuzzing --fuzz-runs=10000` - процесс фаззинга будет ограничен 10,000 индивидуальными запусками тестов (`--fuzz-runs=10000`).

* Опция `--fuzz-proof=FUZZ_PROOF` служит для выполнения особого этапа фаззинга — доказательства стабильности корпуса (corpus), т.е. подтверждения высокого уровня покрытия кода имеющимся корпусом.

Параметр `FUZZ_PROOF` задается в секундах и определяет продолжительность дополнительного этапа фаззинга, начиная с момента обнаружения последнего интересного (приводящего к новому поведению программы) случая тестовых данных.

Это означает, что если в течении указанных секунд с момента обнаружения последнего кейса (или с начала фаззинга, если не было найдено ни одного нового кейса в текущем запуске) будет найден хотя бы один новый - это приведёт к завершению фаззинга с ошибкой. Все найденные кейсы будут сохранены в корпусе.

`ya make -r --sanitize=address --sanitize-coverage=trace-div,trace-gep --fuzzing -A --fuzz-opts="-max_total_time=3600" --fuzz-proof=1800`

В этом случае будет запущена стандартная процедура расширения корпуса с ограничением времени фаззинга в 1 час (3600с). После её успешного окончания, ищется самый свежий кейс в полученном корпусе.

Если машинерия фаззинга обнаружит последний найденный кейс более 30 минут (1800с) назад, то считается что proof состоялся и фаззинг успешно завершается.

Если последний кейс был обнаружен 10 минут назад (для примера), то фаззинг будет перезапущен на дополнительные 20 минут в режиме fuzz proof с использованием всего текущего корпуса (включая новые найденные данные). Если тестовая машинерия обнаружит новый кейс во время работы в этом режиме, процесс фаззинга будет прерван, а все найденные кейсы сохранены - proof не состоялся, об этом сообщит ошибка в тесте.

`ya make -r --sanitize=address --sanitize-coverage=trace-div,trace-gep --fuzzing -A --fuzz-runs=1000000 --fuzz-proof=3600`
Аналогично работает fuzz proof режим при запуске фаззинга с ограничением суммарного количества прогонов целевой функции.

* Опция `--fuzz-minimize`  указывает инструменту фаззинга на необходимость выполнения процесса минимизации корпуса тестовых данных сразу после завершения основного этапа фаззинга. 

Ключевым элементом фаззинга является корпус тестов — набор данных, который используется фаззером для проверки программы. Корпус должен быть достаточно обширным и разнообразным, чтобы обеспечивать эффективное тестирование, но в то же время оптимизированным, чтобы не тратить ресурсы на проверку избыточных или повторяющихся тестов.

Минимизация корпуса — это процесс удаления из корпуса лишних тестов, которые не увеличивают покрытие кода, а также попыток уменьшить размер отдельных тестов без потери “интересности” для фаззера. Эта операция помогает ускорить последующие запуски фаззинга и упрощает анализ результатов.

Использование опции `--fuzz-minimize` гарантирует, что после каждого сеанса фаззинга будет автоматически выполнена минимизация корпуса тестов.

Опция `--fuzz-minimize`  позволяет не только увеличить эффективность тестирования за счет сокращения времени на прохождение корпуса, но и облегчает процесс нахождения и исправления ошибок благодаря более четкому и сжатому набору тестов.

##  Специфика тестов на Python

Основным фреймворком для написания тестов на Python является `pytest`. Поддерживаются Python 2 (макрос `PY2TEST`) и Python 3 (макрос `PY3TEST`).

* Опция `--test-log-level=TEST_LOG_LEVEL` является параметром командной строки для настройки уровня логирования в процессе выполнения тестов для языка Python. Этот параметр позволяет контролировать, какой объем сообщений лога будет выводиться в процессе тестирования, делая вывод информации более релевантным для текущих задач и предпочтений пользователя.

Уровни логирования определяют приоритет лог-сообщений и позволяют фильтровать вывод так, чтобы отображались только сообщения от установленного уровня и выше. Возможные значения `TEST_LOG_LEVEL` включают:
 - `debug`: самый низкий уровень, выводит наибольшее количество информации, включая отладочные сообщения.
 - `info`: отображает информационные сообщения, которые могут быть полезны для понимания хода выполнения программы, помимо предупреждений и ошибок.
 - `warning`: выводит предупреждения, которые указывают на потенциальные проблемы, требующие внимания, а также ошибки.
 - `error`: демонстрирует только сообщения об ошибках, которые указывают на непредвиденные проблемы в программе, требующие исправления.
 - `critical`: самый высокий уровень, отображает только критические ошибки, которые могут потребовать немедленного внимания.

* Опция `--test-traceback=TEST_TRACEBACK` позволяет настроить формат вывода трассировки стека (stack trace) при возникновении ошибок во время выполнения тестов. В зависимости от выбранной опции, трассировки могут быть представлены в различных форматах, что может упростить процесс отладки и ускорить нахождение причин сбоев.

Варианты значений параметра TEST_TRACEBACK:

 - `long`: Этот режим является наиболее подробным и выводит полную трассировку стека для каждой ошибки. Помимо стандартной информации о месте возникновения ошибки, `long` позволяет видеть контекст вызовов функций и цепочки вложенных вызовов, которые привели к ошибке.
 - `short`: По умолчанию используется этот формат. Он предоставляет сокращенную версию трассировки стека, фокусируясь на самом важном и исключая менее значимые детали. Обычно включает в себя информацию о месте возникновения непосредственной ошибки.
 - `line`: Отображает только одну строку для каждой ошибки, которая указывает на место в коде, где ошибка была обнаружена. Этот формат полезен для получения быстрого обзора ошибок без глубокой детализации.
 - `native`: Выводит трассировку стека в формате, стандартном для самого Python, без применения специфических для Pytest модификаций и улучшений. Может быть полезно для разработчиков, предпочитающих работать с трассировкой в “сыром” виде.
 - `no`: Полностью отключает вывод трассировки стека при возникновении ошибок в тестах. Этот режим может быть удобен при необходимости минимизировать количество информации в отчетах о тестировании.

* Опция `--profile-pytest` активирует процесс профилирования с помощью модуля `cProfile`, который является стандартным модулем профилирования в Python, и обрабатывает результаты для предоставления более детального и визуализированного представления данных о производительности тестов.

Использование `--profile-pytest` дает понимание временных затрат на различные участки кода в тестах. 

* Опция `--pytest-args=PYTEST_ARGS` позволяет пользователям передавать дополнительные аргументы и опции непосредственно в Pytest, расширяя стандартное поведение или настройки запуска тестов. 

Возможности, которые можно настроить с помощью `--pytest-args`:

  - Задание пути к тестам: можно указать конкретные файлы или директории для запуска;
  - Управление выводом: настроить уровень детализации выводимой информации (используйте -v для более подробного вывода и -q для менее подробного)
  - Маркировка тестов: запуск только тех тестов, которые отмечены определенными метками (`-m`), что позволяет гибко управлять наборами тестов;
  - Параллельное выполнение тестов: при наличии плагина `pytest-xdist`, можно распределить тесты на несколько процессов для их параллельного выполнения (`-n`);

## Специфика тестов Java

Для Java поддерживаются JUnit версий 4.х и 5.х.

* Опция `--system-property=PROPERTIES` используется, чтобы установить одно или несколько системных свойств JVM (Java Virtual Machine) перед выполнением приложения или теста.

Системные свойства в Java — это ключевые значения, которые можно использовать для конфигурации поведения JVM и приложения. Они могут влиять на работу стандартных классов Java и могут быть использованы для передачи конфигурационной информации в ваше приложение.

* Опция `--system-properties-file=PROPERTIES_FILES` представляет собой механизм, используемый при запуске тестов, для загрузки и установки системных свойств JVM из внешнего файла. 

`--system-properties-file=PROPERTIES_FILES`, где `PROPERTIES_FILES` указывает на путь к файлу, содержащему системные свойства.

Файл, из которого загружаются системные свойства, имеет простой текстовый формат, где каждая строка содержит одно свойство в формате `ключ=значение`. Комментарии могут быть добавлены, начиная строку с символа `#`.

* Опция `--jvm-args=JVM_ARGS` используется для передачи дополнительных аргументов непосредственно виртуальной машине Java (JVM) при её запуске. Эти аргументы позволяют настроить работу JVM, влияя на производительность, поведение сборщика мусора, использование памяти и другие важные аспекты исполнения Java-приложений.

`JVM_ARGS` — это строка, содержащая один или несколько аргументов, которые должны быть переданы JVM. Аргументы разделяются пробелами и могут включать в себя как стандартные опции JVM, так и специфичные для конкретной реализации JVM.

## Спецификация Hermione 

**Hermione** — это популярный инструмент для автоматизации тестирования веб-приложений, который позволяет писать тесты на высоком уровне абстракции. Тесты, написанные для Hermione, могут выполняться в различных браузерах, позволяя разработчикам убедиться, что их веб-приложение работает корректно в разных средах.

* Опция `--hermione-config=HERMIONE_CONFIG` в системе сборки `ya make` используется для указания пути к файлу конфигурации для запуска тестов, использующих Hermione — инструмент для автоматизированного тестирования веб-приложений с помощью Selenium.

**Формат опции:**

`--hermione-config=путь/к/файлу/конфигурации`

Файл конфигурации Hermione обычно представляет собой JavaScript файл, который экспортирует объект с настройками. В нем можно указать:
 - **browsers**: конфигурации для браузеров, в которых будут запускаться тесты.
 - **baseUrl**: базовый URL тестируемого веб-приложения.
 - **gridUrl**: URL Selenium Grid, через который будут запускаться браузеры.
 - **timeout**: таймауты для тестов.
 - **retry**: количество попыток перезапуска тестов в случае их неудачного выполнения.
 - **plugins**: настройки плагинов, расширяющих функциональность Hermione.

* Опция `--hermione-browser=HERMIONE_BROWSERS` позволяет ограничить выполнение тестов только выбранными браузерами, что полезно при необходимости запустить тесты в конкретной среде или при отладке проблем, связанных с определенным браузером.

`HERMIONE_BROWSERS` — это строка, содержащая имя браузера или список имен браузеров, разделенных запятыми, в которых должны выполняться тесты.

* Опция `--hermione-grep=HERMIONE_GREP` позволяет запускать только те тесты, названия которых соответствуют указанному шаблону, используя механизм фильтрации посредством регулярных выражений или подстрок.

`HERMIONE_GREP` — это шаблон (регулярное выражение или просто подстрока), по которому будет производиться поиск среди названий тестов или групп тестов (тестовых сценариев).

* Опция `--hermione-test-path=HERMIONE_TEST_PATHS` предназначена для запуска автоматизированных тестов веб-приложений, ограничивая выполнение тестов только теми, что расположены в указанных файлах.

`HERMIONE_TEST_PATHS` — это один путь или список путей к файлам с тестами, разделенных запятыми. Пути должны быть указаны относительно текущей рабочей директории (cwd - current working directory).

* Опция `--hermione-set=HERMIONE_SETS` позволяет ограничить выполнение тестов только теми, которые включены в определенный набор (или наборы), предварительно сконфигурированный в файле конфигурации Hermione.

**Hermione** позволяет группировать тесты в наборы (sets), чтобы можно было легко запускать различные подгруппы тестов в зависимости от текущих требований. Например, можно создать отдельные наборы для smoke-тестов, тестов регрессии, тестов определенной функциональности и т.д.

`HERMIONE_SETS` — это имя одного набора или список имен наборов, разделенных запятыми, которые должны быть выполнены.

Конфигурация наборов производится в файле конфигурации Hermione. Для определения наборов используется секция `sets` в конфигурационном объекте. Пример:
```
module.exports = {
    sets: {
        smoke: {
            files: [‘tests/smoke/.js’]
        },
        regression: {
            files: ['tests/regression/**/.js’]
        }
    },
    // Другие настройки конфигурации…
};
```

В этом примере определены два набора тестов: `smoke` и `regression`, каждый из которых содержит пути к тестовым файлам, входящим в соответствующий набор.

* Опция `--hermione-gui` предназначена для запуска тестов, в графическом интерфейсе пользователя (GUI).

При запуске с опцией `--hermione-gui`, Hermione инициирует веб-сервер, который предоставляет графический интерфейс для управления процессом тестирования. Этот интерфейс позволяет выбирать конкретные тесты для запуска, просматривать результаты их выполнения и взаимодействовать с тестовым окружением в более удобной и наглядной форме, чем при работе через командную строку.

`ya make -t  --hermione-gui`

После запуска команды в консоли появится URL, по которому доступен графический интерфейс Hermione. Открыв этот URL в браузере, вы увидите список доступных для запуска тестов и сможете управлять процессом тестирования непосредственно из браузера.

* Опция `--hermione-gui-auto-run` автоматизирует процесс тестирования, позволяя автоматически запустить выбранные тесты сразу после того, как пользователь открывает веб-интерфейс Hermione в браузере.

`ya make  -t --hermione-gui --hermione-gui-auto-run`

После выполнения этой команды и открытия GUI Hermione в браузере, тесты начнут выполняться автоматически, без дополнительных действий со стороны пользователя.

* Опция `--hermione-gui-no-open`  предназначена для сценариев, когда необходимо запустить веб-сервер для работы с GUI Hermione, но при этом избежать автоматического открытия окна браузера с интерфейсом Hermione сразу после запуска сервера.

* Опция `--hermione-gui-hostname=HERMIONE_GUI_HOSTNAME` позволяет указать конкретный хост (hostname), на котором будет запущен веб-сервер для работы с GUI Hermione.

`ya make  -t --hermione-gui --hermione-gui-hostname=192.168.1.5`

В этом примере сервер для работы с GUI Hermione будет запущен на хосте с IP-адресом `192.168.1.5`. Это означает, что к GUI можно будет получить доступ не только с локальной машины, но и с любого устройства в сети, которое может подключиться к этому IP-адресу.

* Опция `--hermione-gui-port=HERMIONE_GUI_PORT` позволяет указать конкретный сетевой порт, на котором будет запущен веб-сервер для доступа к GUI Hermione. Это дает возможность контролировать, через какой порт будет осуществляться взаимодействие с интерфейсом управления тестами.

## Спецификация JUnit 

* Опция `--junit-args=JUNIT_ARGS` позволяет передать дополнительные аргументы непосредственно в JUnit-раннер, что дает возможность настроить процесс выполнения тестов более гибко.

JUnit поддерживает различные аргументы командной строки, которые могут влиять на выбор и поведение тестов, например, фильтрацию тестов по имени, ограничение времени выполнения и другие настройки. 

Опция `--junit-args` позволяет указать эти параметры при запуске тестов через систему сборки.

## Спецификация Java

* Опция `--sonar` в системе сборки `ya make` предназначена для запуска анализа качества кода с помощью инструмента SonarQube. 

SonarQube — это платформа для непрерывного анализа и измерения качества кода, которая позволяет обнаруживать различные типы проблем в коде, такие как ошибки, уязвимости, "code smells", и другие потенциальные проблемы, которые могут негативно сказаться на качестве, безопасности или производительности программного обеспечения.

При использовании опции `--sonar`, `ya make` инициирует процесс анализа кода, в ходе которого код проекта сканируется, и результаты сканирования отправляются в SonarQube сервер для дальнейшего анализа и отображения в его веб-интерфейсе.

* Опция `--maven-export` в системе сборки `ya make` предназначена для экспорта артефактов Java проекта в репозиторий Maven.

Использование опции `--maven-export` инициирует процесс, в ходе которого артефакты проекта (например, скомпилированные JAR-файлы) подготавливаются и отправляются в указанный Maven репозиторий. Этот процесс включает в себя генерацию POM-файлов (Project Object Model), которые описывают проект и его зависимости, и самих артефактов в соответствии с требованиями Maven.

* Опция `--version=VERSION` позволяет указать версию экспортируемых артефактов, что является ключевым аспектом управления зависимостями в Maven и обеспечивает корректное версионирование библиотек или приложений в процессе их разработки и деплоя.

В Maven каждый артефакт (JAR-файл) идентифицируется уникальным сочетанием groupId, artifactId и версии. Версия артефакта позволяет отслеживать его изменения во времени, управлять совместимостью и обеспечивать стабильность сборки проектов, использующих эти артефакты как зависимости.

При использовании опции `--version=VERSION`, вы явно указываете версию артефакта, которая будет использоваться при его экспорте в Maven репозиторий. Это позволяет контролировать, какая версия артефакта будет доступна для других проектов.

* Опция тестирования `-J=JAVAC_FLAGS` или в альтернативном формате `--javac-opts=JAVAC_FLAGS` предназначена для передачи дополнительных флагов и параметров непосредственно компилятору Java в процессе сборки Java-проектов.

* Опция `--error-prone-flags=ERROR_PRONE_FLAGS` предназначена для настройки поведения `Error Prone` во время компиляции Java-кода.

`Error Prone` — это плагин для компилятора Java, который анализирует код на предмет распространенных ошибок программирования, которые традиционный компилятор Java не способен обнаружить.

При включении `Error Prone` в процессе компиляции, он анализирует исходный код на предмет различных “шаблонов ошибок” — проблем в коде, которые часто приводят к ошибкам или нежелательному поведению программы. Error Prone может выдать предупреждения или ошибки для найденных проблематичных участков кода. 

С помощью опции `--error-prone-flags` разработчики могут настраивать, какие правила анализа будут применяться, отключать определенные правила, изменять уровень серьезности выдаваемых предупреждений и т.д.

* Опция `--disable-run-script-generation` предназначена для отключения автоматической генерации скриптов запуска, обычно именуемых `run.sh` для Unix-подобных систем или `run.bat` для Windows.

* Опция `--sonar-project-filter=SONAR_PROJECT_FILTERS` позволяет уточнить и ограничить анализ SonarQube только определенными проектами или подпроектами, которые соответствуют заданным критериям или фильтрам.

Опция позволяет установить значение для фильтра, который применяется к проектам или модулям в рамках анализа SonarQube, определяя таким образом, какие конкретные цели сборки (проекты или модули) будут анализироваться SonarQube. 

* Опция `-N=SONAR_PROPERTIES` или в полной форме `--sonar-property=SONAR_PROPERTIES` позволяет задать одно или несколько дополнительных свойств, которые будут переданы в SonarQube в качестве параметров конфигурации анализа.

* Опция `--sonar-do-not-compile` используется во время подготовки к анализу кода инструментом SonarQube и сообщает системе о пропуске этапа компиляции Java исходных кодов.

Обычно, для анализа качества кода SonarQube требует указания местоположения скомпилированных бинарных файлов Java классов, это делается через свойство `sonar.java.binaries`. Когда анализируется только статический код и не требуется проверка байт-кода, компиляцию можно пропустить. Опция `--sonar-do-not-compile` позволяет обойти шаг компиляции, уведомляя систему сборки и SonarQube о том, что бинарные файлы не будут использоваться в данном запуске анализа.

* Опция `--sonar-java-args=SONAR_JAVA_ARGS` используется для тонкой настройки параметров Java Virtual Machine (JVM), на которой будет запущен сканер SonarQube в процессе анализа кода. Эта опция позволяет передать дополнительные аргументы и свойства JVM непосредственно к процессу сканера SonarQube, тем самым влияя на его работу и поведение.

* Опция `--get-deps=GET_DEPS` используется для компиляции и сбора всех зависимостей текущего проекта и их последующего копирования в указанную директорию.

* Опция `-s` или в расширенной форме `--sources` указывает включать в JAR-файл исходный код соответствующих классов.
