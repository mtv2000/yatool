## Запуск произвольных программ (Exec-тесты)

Exec-тесты позволяют выполнять произвольные команды и проверять их успешное завершение.
Успешным считается завершение команды с кодом возврата 0.

### Основные возможности Exec-тестов
Exec-тесты дают возможность запускать любые команды в рамках тестового окружения и проверять их результат.
Стандартные программы `unix` и команды `shell` не доступны, некоторые аналоги можно подключить через `DEPENDS`.

### Основная структура Exec-теста

Простое описание Exec-теста в файле ya.make:
```
OWNER(g:some-group)

EXECTEST()  # Объявление Exec-теста

RUN(  # Команда, которую хотим выполнить
    cat input.txt
)

DATA(  # Тестовые данные, которые необходимы для выполнения команды (здесь лежит input.txt)
    PROJECT/devtools/ya/test/tests/exectest/data
)

DEPENDS(  # Зависимость от других проектов (например, исходные коды cat)
    devtools/dummy_PROJECT/cat
)

# Текущий каталог для теста (каталог с input.txt)
TEST_CWD(devtools/ya/test/tests/exectest/data)

END()
```

### Разделение Exec-тестов

Каждое объявление макроса `RUN` создает отдельный тест. 
Тесты выполняются в том порядке, в котором они указаны в файле:
```
OWNER(g:some-group)

EXECTEST() 

RUN( # Первый тест
    NAME test-1  # Имя теста
    echo “1”
)

RUN( # Второй тест
    NAME test-hello-world  # Имя теста
    echo “Hello, world!”
)

END()
```
При параллельном запуске тестов в каждый из параллельно выполняемых потоков попадает только часть команд, указанных `в ya.make`. 
Поэтому не рекомендуется писать команды, результаты выполнения которых зависят от выполнения команд из вышестоящих макросов `RUN`.

### Поддерживаемые параметры макроса RUN

Макрос RUN предлагает множество возможностей для настройки выполнения команды:
```
OWNER(g:some-group)

EXECTEST()

RUN(
    NAME my-test  # Имя теста
    ENV TZ=Europe/Moscow  # Установка переменных окружения
    ENV LANG=ru_RU.UTF-8  # Дополнительные переменные окружения
    echo “1”  # Команда и её параметры
    STDIN {PROJECT_ROOT}/my-project/filename.txt  # Входной файл для команды
    STDOUT {TEST_CASE_ROOT}/test.out  # Файл для сохранения вывода stdout
    STDERR {TEST_CASE_ROOT}/test.err  # Файл для сохранения вывода stderr
    CWD {PROJECT_BUILD_ROOT}/my-project  # Рабочий каталог для теста
    CANONIZE_LOCALLY {TEST_CASE_ROOT}/test.out  # Путь до эталонных данных (будет сохранён локально)
    CANONIZE_DIR_LOCALLY {TEST_CASE_ROOT}/dir  # Канонизация директории (сохранён локально)
    DIFF_TOOL my-project/tools/my-difftool/my-difftool  # Инструмент для сравнения результатов (Путь до исполняемого файла, используемого для сравнения вывода теста с эталонными данными)
    DIFF_TOOL_TIMEOUT  # Таймаут для выполнения diff_tool
)
DEPENDS(
    my-project/tools/my-difftool
)

END()
```
### Переменные, доступные для задания путей

Для задания путей можно использовать следующие переменные:

| Переменная | Описание |
|------------------------|------------------------------------------------------------------|
| {PROJECT_BUILD_ROOT} | Корень сборочной директории |
| {PROJECT_ROOT} | Корень единого репозитория |
| {TEST_SOURCE_ROOT} | Путь к каталогу, в котором находится `ya.make` текущего теста |
| {TEST_CASE_ROOT} | Путь к каталогу с результатами текущего теста |
| {TEST_WORK_ROOT} | Путь к рабочему каталогу теста |
| {TEST_OUT_ROOT} | Путь к каталогу с результатами всех тестов |

Программы, подключенные по `DEPENDS`, не сохраняются в исходном коде, они могут быть симлинками или временными файлами. 

### Полезные программы и макросы

#### not

Иногда нужно проверить, что тестируемая программа завершилась с ненулевым кодом (например, при неправильных аргументах). 
Для таких случаев можно использовать программу not, которая инвертирует код возврата:
```
RUN(
    NAME “my_program fails with wrong arguments”
    not my_program wrong arguments  # Ожидается, что команда завершится с ошибкой
)

DEPENDS(
    my_project/my_program
    tools/not
)
```
