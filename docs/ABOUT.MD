# Основные концепции системы сборки ya make

## Основные преимущества и возможности

- Универсальность и гибкость: `ya make` поддерживает широкий спектр языков программирования и технологий, что делает его подходящим для работы с мультитехнологичными проектами. Он может быть использован для сборки проектов на таких языках, как C++, Python, Java, Go, и многих других, предоставляя разработчикам удобный способ управления сборкой в разнообразных разработческих экосистемах.
- Автоматизация сборки: Одной из ключевых особенностей `ya make` является его способность автоматически обрабатывать сложные системы зависимостей в проекте, обеспечивая точную и эффективную автоматическую сборку программных компонентов. Основываясь на конфигурациях, определенных в файлах `ya.make`, команда `ya make` автоматически разрешает зависимости и выполняет необходимые шаги для подготовки окончательной сборки проекта.
- Настройка параметров сборки: `ya make` предоставляет возможности по настройке процесса сборки, позволяя разработчикам выбирать между различными режимами сборки (например, debug или release), а также настраивать параметры компиляции, линковки и оптимизации кода для достижения наилучших результатов производительности и размера исполняемого файла.
- Расширенное тестирование: Инструмент  обеспечивает запуск широкого спектра тестов, включая модульные тесты, интеграционные тесты, тесты производительности и другие, с поддержкой настройки параметров запуска тестов для максимальной гибкости процесса верификации качества кода.
- Поддержка локальной и распределенной сборки: Позволяет выполнять сборку как на локальной машине разработчика, так и использовать распределенные ресурсы для ускорения процесса сборки.



Система сборки `ya make` может быть описана как

- Полностью *статическая*. Все зависимости анализируются заранее и изменения фиксируются в *графе команд*. На основе анализа каждая команда получает уникальный идентификатор *UID*, который фиксирует её результат на данном состоянии входных данных и зависимостей. Неизменность *UID* говорит о неизменности её результата и потому служит ключом в *кэше результатов*, а также используется при *анализе изменений* для исключения команды из исполнения.

- Универсальная и *высокоуровневая*. Описание системы сборки делается на уровне модулей, макросов и зависимостей между модулями. Наша система сборки скрывает очень многое.
  * Она сама строит межфайловые зависимости как прямые *(a.cpp включает b.h)*, так и индуцированные генерацией *(если x.proto импортирует y.proto, то x.pb.h будет включать y.pb.h)*. Эти зависимости внутри отображаются на команды: команда компиляции `a.cpp` будет перезапущена при изменении `b.h`, а команда изменение в `y.proto` повлечёт не только перегенерацию для `x.proto`, но и перекомпиляцию `z.cpp`, который включает `x.pb.h`.
  * Она сама строит цепочки обработки файлов - включение в модуль `GO_LIBRARY()` файла `w.proto` повлечёт генерацию из него .pb.go и дальнейшую трансляцию этого файла в составе пакета.
  * Она может связывать результаты работы макросов по именам: макрос, генерирующий `m.json` и макрос складывающий его в программу как ресурс в рамках одного модуля связываются просто по имени файла.

- *Декларативная*, но не совсем. В описании сборки большая часть конструкций фиксирует свойства модулей и команд и связи между ними. Однако, часть конструкций выполняется последовательно: установка и вычисление локальных переменных, условные конструкции — это то, что зависит от порядка, в котором написано в ya.make-файле.
Для корректной работы нашей системы сборки требуется *герметичность*: команды не должны неявным образом зависеть ни от окружения (файлов в системе, настроек системы и т.п.) ни от результата или порядка исполнения других команд.
Все зависимости должны быть известны системе сборки, чтобы сформировать корректный *UID* для каждой команды. Наша система сборки предоставляет средства для герметичного исполнения: все инструменты, используемые в сборке или
зафиксированы в бинарном виде, или строятся из исходного кода в рамках сборки.
Такая герметичность обеспечивает *воспроизводимость* —  сборка даст *функционально эквивалентный* результат в любой среде при фиксированном состоянии репозитория и запрошенной конфигурации.
Это обеспечивает как простую возможность воспроизводить проблемы, так и организовывать распределённую сборку и кэширование. Для обеспечения воспроизводимости мы стараемся не использовать
директории и шаблоны имён (globs) как входные параметры сборки. Явное описание входов позволяет избегать нежелательных эффектов при наличии в рабочей копии посторонних файлов (отладочных логов, недописанного кода и т.п.).

Важно понимать, что система сборки не гарантирует *бинарную воспроизводимость* и не опирается на неё в своей работе. Меняющаяся информация (времена, пути исходного кода на файловой системе и т.п.) могут изменять артефакты, но, если мы не считаем их существенными для функционирования кода, мы не засчитываем их в *UID*.
Это повышает инкрементальность и делает сборку устойчивой к *сборочному шуму* - случайной информации, вносимой инструментами в артефакты.

Вторым важным свойством нашей системы сборки является *масштабируемость*. Наша система сборки построена таким образом, что:

- Активно использует кэширование как информации, используемой в процессе анализа зависимостей, так и кэширование результатов. Воспроизводимость позволяет использовать в локальной работе распределённый кэш, прогреваемый на кластере распределённой сборки.

- Наша система легко шардируется: в сценарии CI, когда нам надо проверить влияние изменений на все тесты в репозитории система анализирует зависимости и исполняет сборки частями. Даже при наличии большого количества горизонтальных связей (зависимостей между проектами в разных частях репозитория) заметно снижает время на анализ зависимостей  ускоряет сборку. Для каждой части (partition) система сборки строит свой замкнутый *сборочный граф*, который исполняется отдельно независимо на кластере распределённой сборки, а развитое кэширование позволяет не дублировать работу.

## Как работает наша система сборки 

Система сборки `ya make`, решает очень непростую задачу, связанную с объединением большого количества различных частей программы. Поэтому найти идеальное решение, которое устроит всех, невозможно. Любое решение будет несовершенным и имеет свои плюсы и минусы.

## Как мы устроили процесс сборки

Сейчас мы работаем по модели, где заранее известно всё, что нужно для сборки программы (мы имеем полный граф зависимостей). Каждый шаг сборки программы имеет свой уникальный идентификатор (UID), который мы рассчитываем заранее, опираясь на граф и не меняем в процессе сборки.

У такого подхода есть свои преимущества:

- Воспроизводимость: если условия постоянны, результат сборки всегда будет одинаковым.
- Предсказуемость: мы знаем, какой объем работы предстоит выполнить.
- Изоляция: доступ к файлам есть только у тех частей сборки, которым это нужно.
- Простота в планировании работы и возможность сохранения результатов сборки для использования в следующий раз.
- Устойчивость к мелким изменениям: изменения в именах файлов или времени сборки не влияют на UID и результаты.
- Возможность работать над разными частями проекта одновременно и быстро.
- Простая и сжатая структура: зависимости между частями проекта учтены в UID и не загромождают нашу схему сборки.
- Точность зависимостей: перекомпилировать нужно только определенные файлы, а не всю программу целиком.
- Легкость описания процесса сборки: многие зависимости система находит сама, без нашего вмешательства.

Но есть и минусы:

1. Погрешности: без запуска программы мы не можем точно понять, какие части кода зависят друг от друга, поэтому зависимости оцениваются с запасом.
2. Чувствительность к ошибкам: если системе не хватает информации обо всех зависимостях, это может привести к неправильному результату сборки.
3. Избыточная работа: из-за оценивания зависимостей с запасом, могут выполняться ненужные действия.
4. Время на подготовку: даже если в программе ничего не менялось, подготовка к сборке всё равно требует времени.

## Плюсы ya make

- Легкий в использовании язык описания сборки, похожий на CMakeLists.txt.
- Результаты сборки `ya make` в точности повторяемы в любой момент времени.
- Работает в операционных системах, таких как Linux, Windows и macOS, и поддерживает сборку проектов под множество платформ.
- Все возможные зависимости известны до начала сборки, что помогает определить, какие части надо пересобрать.
- Масштабируемость: `ya make` подходит как для маленьких проектов, так и для больших, включая тысячи проектов и миллионы файлов.
- Настройка и расширение: система позволяет настраивать и добавлять новые функции без изменения основного кода сборщика благодаря специальному языку и плагинам на Python. 

Итак, `ya make` это инструмент, который помогает автоматически соединить разные части кода в одно целое. Он использует специальный граф зависимостей, который указывает, как одна часть программы связана с другой. Все это записывается в простые файлы с названием “ya.make”, которые легко можно редактировать и настраивать. По сути, `ya make` заранее знает всю картину проекта, чтобы потом быстро и правильно собрать его целиком.

Результат работы `ya make` всегда стабилен - если вы начнете процесс сборки с одними и теми же настройками и кодом, то получите точно такие же файлы программы. Это очень важно для тестирования и исправления ошибок, так как можно легко повторить ситуацию и найти проблему.

`ya make` универсален и не привязан к одной операционной системе - он работает в Linux, Windows и macOS и может собирать программы для разных устройств, включая даже смартфоны.

А главное, `ya make` способен масштабироваться: будь то маленький проект на вашем личном компьютере или огромный проект с тысячами компонентов и миллионами файлов, работающем на мощном серверном кластере. При этом он не только быстрый, но и экономит ресурсы, пересобирая только то, что действительно изменилось или зависит от изменений.

И последнее, но не менее важное: `ya make` гибок к изменениям. Вы можете настроить его для своих нужд, используя более чем триста макросов и семьдесят различных модулей, которые можно легко кастомизировать с помощью специального языка программирования или плагинов на Python, без необходимости вносить изменения в сам код сборщика. 
