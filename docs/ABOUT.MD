Система сборки `ya make` может быть описана как

- Полностью *статическая*. Все зависимости анализируются заранее и изменения фиксируются в *графе команд*. На основе анализа каждая команда получает уникальный идентификатор *UID*, который фиксирует её результат на данном состоянии входных данных и зависимостей. Неизменность *UID* говорит о неизменности её результата и потому служит ключом в *кэше результатов*, а также используется при *анализе изменений* для исключения команды из исполнения.

- Универсальная и *высокоуровневая*. Описание системы сборки делается на уровне модулей, макросов и зависимостей между модулями. Наша система сборки скрывает очень многое.
  * Она сама строит межфайловые зависимости как прямые *(a.cpp включает b.h)*, так и индуцированные генерацией *(если x.proto импортирует y.proto, то x.pb.h будет включать y.pb.h)*. Эти зависимости внутри отображаются на команды: команда компиляции `a.cpp` будет перезапущена при изменении `b.h`, а команда изменение в `y.proto` повлечёт не только перегенерацию для `x.proto`, но и перекомпиляцию `z.cpp`, который включает `x.pb.h`.
  * Она сама строит цепочки обработки файлов - включение в модуль `GO_LIBRARY()` файла `w.proto` повлечёт генерацию из него .pb.go и дальнейшую трансляцию этого файла в составе пакета.
  * Она может связывать результаты работы макросов по именам: макрос, генерирующий `m.json` и макрос складывающий его в программу как ресурс в рамках одного модуля связываются просто по имени файла.

- *Декларативная*, но не совсем. В описании сборки большая часть конструкций фиксирует свойства модулей и команд и связи между ними. Однако, часть конструкций выполняется последовательно: установка и вычисление локальных переменных, условные конструкции — это то, что зависит от порядка, в котором написано в ya.make-файле.
Для корректной работы нашей системы сборки требуется *герметичность*: команды не должны неявным образом зависеть ни от окружения (файлов в системе, настроек системы и т.п.) ни от результата или порядка исполнения других команд.
Все зависимости должны быть известны системе сборки, чтобы сформировать корректный *UID* для каждой команды. Наша система сборки предоставляет средства для герметичного исполнения: все инструменты, используемые в сборке или
зафиксированы в бинарном виде, или строятся из исходного кода в рамках сборки.
Такая герметичность обеспечивает *воспроизводимость* —  сборка даст *функционально эквивалентный* результат в любой среде при фиксированном состоянии репозитория и запрошенной конфигурации.
Это обеспечивает как простую возможность воспроизводить проблемы, так и организовывать распределённую сборку и кэширование. Для обеспечения воспроизводимости мы стараемся не использовать
директории и шаблоны имён (globs) как входные параметры сборки. Явное описание входов позволяет избегать нежелательных эффектов при наличии в рабочей копии посторонних файлов (отладочных логов, недописанного кода и т.п.).

Важно понимать, что система сборки не гарантирует *бинарную воспроизводимость* и не опирается на неё в своей работе. Меняющаяся информация (времена, пути исходного кода на файловой системе и т.п.) могут изменять артефакты, но, если мы не считаем их существенными для функционирования кода, мы не засчитываем их в *UID*.
Это повышает инкрементальность и делает сборку устойчивой к *сборочному шуму* - случайной информации, вносимой инструментами в артефакты.

Вторым важным свойством нашей системы сборки является *масштабируемость*. Наша система сборки построена таким образом, что:

- Активно использует кэширование как информации, используемой в процессе анализа зависимостей, так и кэширование результатов. Воспроизводимость позволяет использовать в локальной работе распределённый кэш, прогреваемый на кластере распределённой сборки.

- Наша система легко шардируется: в сценарии CI, когда нам надо проверить влияние изменений на все тесты в репозитории система анализирует зависимости и исполняет сборки частями. Даже при наличии большого количества горизонтальных связей
  (зависимостей между проектами в разных частях репозитория) заметно снижает время на анализ зависимостей  ускоряет сборку. Для каждой части (partition) система сборки строит свой замкнутый *сборочный граф*, который исполняется отдельно
  независимо на кластере распределённой сборки, а развитое кэширование позволяет не дублировать работу.

