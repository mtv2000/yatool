# Общее для всех языков: макросы

## Базовые управляющие конструкции

В отличии от большинства других макросов `ya.make`, относительный порядок базовых управляющих конструкций играет важную роль. `IF` воспринимает то значение переменной, которое было установлено ранее в `ya.make`, и не видит то, которое будет установлено ниже по коду. Однако, если изменение переменной влияет на свойства модуля или его команд, это может повлиять и на управляющие конструкции, находящиеся выше по тексту:

**Пример:**

```
SRCS(x.cpp)

SET(LLVM_VER 11)
PEERDIR(contrib/libs/llvm${LLVM_VER})

# SET(LLVM_VER 8) — Это бы повлияло на IF ниже, но не на PEERDIR выше.

IF (LLVM_VER == 11)
   SET(CFLAGS -Wno-error)    # Это влияет на SRCS выше
ENDIF()
```

### INCLUDE/INCLUDE_ONCE

```
INCLUDE(<path>)
```

Система сборки `ya make` поддерживает текстовые включения через макрос `INCLUDE(<full_file_name>)`. Текст из указанного файла будет вставлен на место макроса `INCLUDE` и затем интерпретирован.

Таким образом, вставленный текст:

1. Будет относиться к тому же скоупу, что и макрос `INCLUDE`.
2. Переменные, определённые в тексте, будут становиться модульными переменными, если `INCLUDE` размещён в модуле, и будут видны в условных конструкциях и параметрах других макросов, находящихся ниже по тексту.
3. Переменные, определённые выше `INCLUDE`, будут доступны в параметрах макросов включённого файла, включая условные конструкции.
4. По умолчанию на данный момент включаемые файлы обрабатываются каждый раз, когда встречаются при интерпретации `ya.make` и включённых в него файлов. В частности, макросы `SET_APPEND` в включённом файле будут выполняться столько раз, сколько раз файл включён в `ya.make`. Это может привести к избыточному росту значений переменных. Чтобы изменить поведение на однократную обработку файлов для каждого начального `ya.make`, можно использовать макрос `INCLUDE_ONCE`.
5. В контексте мультимодуля любой INCLUDE работает так, как если бы все текстовые включения были выполнены до генерации вариантов мультимодуля. То есть конструкции из включённого файла будут интерпретированы во всех вариантах мультимодуля.

Параметром `INCLUDE` должно быть полное имя файла, с указанием `${BUILD_ROOT}/` как принадлежность к дереву исходных файлов.

```
INCLUDE_ONCE([yes|no])
```
Тестовые включения могут вызвать ситуацию, когда один и тот же файл будет включён несколько раз через различные пути от основного `ya.make`, что приведёт к замедлению работы и потенциальному дублированию значений при использовании макроса `SET_APPEND`.

Для предотвращения этого рекомендуется применять макрос `INCLUDE_ONCE()`. Файл, содержащий этот макрос, будет обрабатываться только один раз для каждого `ya.make-файла`. Все последующие включения этого файла в рамках обработки текущего `ya.make` будут игнорироваться.

* Макрос `INCLUDE_ONCE` без параметров или с параметром `yes` активирует однократную обработку файла.
* Макрос `INCLUDE_ONCE` с параметром `no` отключает однократную обработку файла. Это может быть полезно для явного обозначения того, что файл предназначен для многократного включения, особенно если поведение `INCLUDE` по умолчанию изменится.

Независимо от того, где в файле выполнен макрос `INCLUDE_ONCE`, этот файл не будет интерпретирован повторно. Однако рекомендуется размещать этот макрос в самом начале файла и настоятельно не рекомендуется вставлять его внутри условных конструкций `IF`.

### SET

```
SET(VarName VarValue)
```
Задает или изменяет значение переменной, перезаписывая любое ранее установленное значение.

### SET_APPEND

```
SET_APPEND(VarName Values...)
```
Добавляет значение к переменной. Существующее значение могло быть установлено в глобальной конфигурации сборки. Например, команда `SET_APPEND(CFLAGS -fno-omit-frame-pointer`) добавит указанный флаг к глобально определённым флагам для модулей `C++` и `C`, обеспечивая требуемый флаг для текущего модуля.

### DEFAULT

```
DEFAULT(VarName DefaultVal)
```
Задает значение по умолчанию для переменной. В отличие от `SET(VarName VarValue)`, этот макрос установит запрошенное значение переменной только в том случае, если значение для данной переменной ещё нигде не было определено.

### ENABLE/DISABLE { #enable }

```
ENABLE(VarName)
DISABLE(VarName)
```
Устанавливает или сбрасывает значение переменной, используемой в качестве флага. Эквивалентно командам `SET(VarName yes)`/`SET(VarName no)`.

### IF/ELSEIF/ELSE/ENDIF { #if }

```
IF (Expr)
    ...
ELSEIF (Expr)
    ...
ELSE()
    ...
ENDIF()
```
Позволяет выполнять или не выполнять макросы в зависимости от заданных условий. Работает аналогично условным конструкциям в императивных языках программирования.

В качестве выражений можно использовать:
* `VAR_NAME`, `$VAR_NAME`, `${VAR_NAME}` - проверяется значение переменной. Пустое значение или имя переменной, которая не была нигде определена, интерпретируются как false. В остальных случаях значение интерпретируется с помощью функций из util:
* `IsTrue`: true, t, yes, y, on, 1, da.
* `IsFalse`: false, f, no, n, off, 0, net.
* `NOT Expr`, `Expr AND Expr`, `Expr OR Expr` - логические выражения (приоритеты операций соблюдаются правильно: NOT, AND, OR).
* `DEFINED VAR_NAME` - проверка, определена ли переменная.
* `ISNUM SomeStrValue`, `ISNUM $VAR_NAME`, `ISNUM ${VAR_NAME}` - проверка, является ли содержимое переменной целочисленным значением.
* `==`, `!=` - сравнение значений переменных и/или строковых значений.
* `MATCHES` - бинарный оператор, проверяющий, что значение правого операнда является подстрокой в значении левого.
* `VERSION_GT`, `VERSION_GE`, `VERSION_LT`, `VERSION_LE` - бинарные операторы сравнения версий. Учитывают не более трёх числовых сегментов, разделённых точкой или дефисом. Например, 3.5.17, 5.2, 4-12, 1-5-17.
* `>`, `<`, `>=`, `<=` - бинарные операторы сравнения целых чисел.

В `ya.make` файлах можно встретить `IF` разрывающий скоуп модуля примерно так:

```
IF(DYNAMIC)
    DLL()
        EXPORT_SCRIPT(my.exports)
ELSE()
    LIBRARY()
ENDIF()
        SRCS(
            some_file.cpp
        )
    END()
```
Работоспособность этой конструкции не гарантируется. Она может работать для некоторых типов модулей, но не для всех. Мы не рекомендуем использовать разные типы модулей по одному пути в различных ситуациях. Однако, если это необходимо, правильный подход - обернуть весь модуль в условную конструкцию `IF` и вынести общую часть через `INCLUDE`.

```
IF(DYNAMIC)
    DLL()
        EXPORT_SCRIPT(my.exports)
        INCLUDE(module_body.inc)
    END()
ELSE()
    LIBRARY()
        INCLUDE(module_body.inc)
    END()
ENDIF()
```

### MESSAGE
```
MESSAGE([KIND] Text)
```
Выводит сообщение во время обработки `ya.make`.

* Если `KIND` указан как `STATUS` или не указан, то сообщение выводится как предупреждение.
* Если `KIND` указан как `FATAL_ERROR`, то сообщение выводится как ошибка конфигурации и сборка останавливается.

**Пример:**

```
LIBRARY()
    IF (NOT DEFINED USE_SYSTEM_PYTHON
        AND NOT DEFINED PYTHON_CONFIG)
        MESSAGE(FATAL_ERROR "USE_SYSTEM_PYTHON/PYTHON_CONFIG is not defined, use ya make -D USE_SYSTEM_PYTHON=2.7")
    ENDIF()
END()
```

### BUILD_ONLY_IF/NO_BUILD_IF { #build_only_if }
```
BUILD_ONLY_IF([FATAL_ERROR|STRICT] COND_VARS...)
```
```
NO_BUILD_IF([FATAL_ERROR|STRICT|WARNING] COND_VARS...)
```

Выдает предупреждение или ошибку, если модуль попал в сборку, нарушая условия, выраженные в `COND_VARS`.

- Макрос `BUILD_ONLY_IF` выдает ошибку, если все переменные `COND_VARS` не определены или имеют значение *ложь* (`false`, `f`, `no`, `off`, `0`). В противном случае ошибка не выдается.
- Макрос `NO_BUILD_IF` выдает ошибку, если хотя бы одна переменная из `COND_VARS` определена и не имеет значение *ложь* (т.е. значение отличается от `false`, `f`, `no`, `off`, `0`).

Параметры:

* `STRICT` (режим по умолчанию) управляет интерпретацией `ya.make` при нарушении условий. Если установлен, модуль и все варианты `RECURSE`, указанные в его `ya.make`, будут проигнорированы. Это приведёт к тому, что модуль не будет собираться и станет недоступен для зависимостей, определённых через `PEERDIR` и `DEPENDS`. Также не будут собираться модули, достижимые только через данный модуль по `RECURSE`, например его тесты.
* `FATAL_ERROR` определяет, должна ли выдаваться ошибка или только предупреждение при нарушении условий. Этот параметр также безусловно включает `STRICT`-режим интерпретации (см. выше).
* `WARNING` не влияет на сборку, а только выдает предупреждение (configure warning) при нарушении условий конфигурации.

**Примеры:**

```
LIBRARY()

# The code is not suitable for Windows, fail if accidentally used
NO_BUILD_IF(OS_WINDOWS)

SRCS(
    memtrack.cpp
)

END()
```

```
FAT_OBJECT()

OWNER(g:group)

BUILD_ONLY_IF(WARNING OS_IOS OS_DARWIN) # Either iOS or MacOS is OK, warn otherwise

PEERDIR(
    keyboard/ios/impl
)

END()
```
Эти макросы по умолчанию работают в режиме `STRICT`. В случае использования параметра `WARNING` будет выдано только предупреждение на консоль, и сборка продолжится. Модуль либо соберется в запрещенной конфигурации, либо произойдет ошибка сборки.

В случае использования параметров `FATAL_ERROR` или `STRICT`, модуль будет исключен из сборки с соответствующей ошибкой конфигурации или предупреждением. Зависимости через `PEERDIR` на такой модуль вызовут дополнительные ошибки конфигурации. Если такие ошибки будут проигнорированы с помощью параметра `-k` (`--keep-going`), то произойдут ошибки на этапе линковки.


## Информация о владении кодом

### OWNER

```
OWNER(name|g:group ...)
SUBSCRIBER(name|g:group ...)
```
Позволяет указать владельца кода в данной директории. Владелец автоматически добавляется во все ревью, касающиеся кода, сборка которого описана в данном `ya.make` файле. Таким кодом считается код, из которого строится модуль, описанный в данном `ya.make`, либо сам `ya.make` файл, если он не содержит модулей, а только перечисление подпроектов через `RECURSE`.

При указании владельца используется логин пользователя. Группы описываются в проекте в папке `groups`.

Этот макрос должен использоваться обязательно. При этом настоятельно рекомендуется использовать группы, а не отдельных людей, чтобы избежать ситуаций, когда код остается неподдерживаемым после ухода сотрудника.

Для определения владельцев кода в директориях без собственного `ya.make` (т.е. которые напрямую не указаны ни в одном `ya.make`), берется первый найденный `ya.make` выше по иерархии директорий. Если в первом найденном `ya.make` не будет указан `OWNER`, то директория будет считаться бесхозной, даже если еще выше по иерархии есть `ya.make` с указанным `OWNER`.

### SUBSCRIBER

```
SUBSCRIBER(name|g:group ...)
```
Параметры и их семантика полностью аналогичны макросу `OWNER`.

Позволяет указать отдельную группу людей, которые будут получать уведомления о изменениях в коде, сборка которого описана в данном `ya.make` файле. Этот макрос не накладывает на указанных людей ответственность за владение кодом, но позволяет им отслеживать изменения. В будущем планируется внедрение доработок, позволяющих подписчикам более гибко управлять уведомлениями от различных проектов

## Структура подпроектов

### RECURSE/RECURSE_ROOT_RELATIVE/RECURSE_FOR_TESTS { #recurse }

```
RECURSE(Dirs...)
RECURSE_FOR_TESTS(Dirs...)
RECURSE_ROOT_RELATIVE(Dirs...)
```
Добавляет проекты по указанным путям к списку стартовых целей сборки, если текущая директория уже находится в этом списке. Эти макросы не оказывают никакого эффекта, если текущий проект попал в сборку через `PEERDIR`, `DEPENDS`, или как инструмент сборки (через `RUN_PROGRAM` либо как часть реализации специфичного макроса, используемого в процессе сборки).

При вызове `ya make` `some/project/subdir` `another/project/dir`, изначальный список стартовых проектов задается аргументами командной строки. В процессе чтения файлов `ya.make`, к стартовым целям будут добавляться директории, указанные через один из макросов `RECURSE`. Этот процесс продолжается рекурсивно.

Простейшая и наиболее распространенная форма макроса `RECURSE` принимает в качестве аргументов список относительных путей и интерпретирует их как пути, относительно директории, содержащей текущий `ya.make` файл.

Для подключения проектных тестов рекомендуется использовать форму `RECURSE_FOR_TESTS`, которая не добавляет указанные проекты в сборку, если сборка тестов не запрашивается. Как и в простой форме макроса, принимаемые пути интерпретируются как относительные пути относительно директории с текущим `ya.make` файлом.

Если нужно задать путь за пределами текущей директории, используется форма `RECURSE_ROOT_RELATIVE`. Использование этой расширенной формы для обычных проектов не рекомендуется. Она в первую очередь нужна для внутренних настроек автосборки.

В идеальной ситуации каждый проект должен быть доступен через цепочку `RECURSE` от корневого ya.make файла репозитория, а пре- и пост-коммитные проверки должны выполнять инкрементальную сборку всего репозитория эквивалентно команде `ya make -tt autocheck`. Иногда при разработке библиотеки её забывают добавить в список `RECURSE` родительской директории, но всё равно добавляют зависимость через `PEERDIR` там, где это требуется. В таком случае сборка этой библиотеки происходит, но её тесты не собираются и не запускаются в автосборке. Всегда добавляйте новые модули в список `RECURSE` в родительской директории.

На практике не все проекты собираются для всех платформ, поэтому некоторые пути могут быть достижимы из `ya.make` только при сборке под Linux, а другие - только при сборке с использованием JDK15. Описание того, для каких платформ поддерживается сборка каждого проекта, хранится централизованно в директории autocheck в корне репозитория.

Этот макрос нельзя использовать внутри модульного скоупа (между макросом начала модуля и макросом `END()`). Он пишется только в глобальном скоупе.

## Базовые модульные макросы

### PEERDIR 

```
PEERDIR(Dirs..)
```

Основной макрос для указания зависимостей между модулями. Директория, указанная в `PEERDIR`, должна содержать файл `ya.make` с описанием сборки модуля, от которого зависит данный модуль.

Чтобы `PEERDIR` был корректным, необходимо выполнение следующих условий:
1. Директория должна существовать.
2. В этой директории должен быть файл `ya.make`.
3. Файл `ya.make` должен описывать сборку модуля.

Если хотя бы одно из этих условий не выполнено, будет выдана ошибка конфигурации `BadDir`.

Модуль, в котором указан `PEERDIR`, зависит от модуля, на который ссылается этот `PEERDIR`.

`PEERDIR` интерпретируется с учетом типа модуля, в котором он указан, и может обозначать один из двух вариантов зависимостей:
1. Для программ и подобных им модулей `PEERDIR` означает *включение* или *необходимость для сборки*. То есть, модули в `PEERDIR` являются составными частями или необходимы в построенном виде для сборки данного модуля. Например, библиотеки *включаются* в программы, а пакеты в `go` требуют зависимые пакеты для своей сборки.
2. Для библиотек и подобных им модулей `PEERDIR` означает *необходимость для использования*. То есть, модули в `PEERDIR` не нужны для сборки данного модуля, но необходимы для его использования. Например, библиотеки на `C++` могут собираться раздельно, но обе они должны быть включены в программу для корректного использования первой библиотеки.

Интерпретация зависимости `PEERDIR` задает состав и порядок сборки:
- В первом варианте требуют построения всех зависимых модулей при сборке данного модуля и до его сборки (результаты их сборки используются при сборке данного).
- Во втором варианте не требуется построение зависимых модулей при сборке данного, и они не будут собираться. Например, при сборке `LIBRARY` не будут строиться библиотеки, от которых она зависит. При сборке программы `PROGRAM` все библиотеки будут строиться, но могут собираться параллельно, без учета зависимостей между ними.

С точки зрения свойств сборки, `PEERDIR` является зависимостью в любой интерпретации. Это означает, что от зависимого модуля к зависящему могут передаваться артефакты и свойства.

* Если `LIBRARY` зависит от `PROTO_LIBRARY`, то их можно собирать параллельно, но в библиотеке будут доступны заголовочные файлы `.pb.h`, генерируемые в `PROTO_LIBRARY`.
* Если в библиотеке `LIBRARY` указан макрос добавления путей в поиск `ADDINCL(GLOBAL ...)`, то все зависящие от неё библиотеки тоже будут использовать этот путь для поиска `include` в своих файлах, даже если они строятся независимо.

`PEERDIR` — это всегда зависимость времени сборки, а не времени исполнения. Например, если из `PY3TEST` разрешен `PEERDIR` на `PY3_PROGRAM`, это означает, что программа будет включена в *сборку* теста, а не будет доступна во время его исполнения. Для выражения зависимости времени исполнения теста используется макрос `DEPENDS`.

Однако в определенных случаях зависимые модули могут расширять набор выходных артефактов (транзитивно) зависящего от них модуля. Например, `PACKAGE` содержит, как часть своих результатов, копии программ, включенных в него через `PEERDIR`.


#### Ограничения 

Не все зависимости, указанные через `PEERDIR`, допустимы. Зависимости между модулями могут быть ограничены как по естественным причинам (зависимость не имеет интерпретации), так и искусственно (явными правилами). Для `PEERDIR` действуют следующие ограничения:

- Промежуточные модули (например, `LIBRARY`) не могут зависеть от финальных модулей (например, `PROGRAM`).
- Сборочные модули (любые `xPROGRAM`, `xLIBRARY`, `xTEST`) не могут зависеть от агрегирующих модулей, таких как `PACKAGE` и `UNION`.
- Никакие модули не могут зависеть от тестов.
- Модули размечены тегами для контроля совместимости. Недопустимы `PEERDIR`-зависимости между несовместимыми модулями. Например, `PY2_LIBRARY` не может зависеть от `PY3_LIBRARY` и наоборот. Поскольку программа на Python содержит интерпретатор фиксированной версии, она должна быть написана на одной версии Python: `PY2_PROGRAM` только на `Python 2`, `PY3_PROGRAM` только на `Python 3`. Через теги также ограничены зависимости, которые не могут быть интерпретированы в рамках системы сборки. Например, система сборки не смогла бы обработать зависимость `LIBRARY` от `JAVA_LIBRARY`.
- Зависимости могут быть автоматически ограничены на основе их расположения, например, для директорий `internal`, или политиками. Такие ограничения описаны в [специальном разделе документации].

Тестовые модули в Java могут зависеть друг от друга, поскольку на самом деле такие модули представляют собой мультимодули, включающие тест и java-библиотеку с кодом. В реальности эта зависимость превращается в зависимость одного теста от библиотеки с кодом другого теста. Это означает, что при запуске зависимого теста зависимый тест сам по себе не будет запущен.

#### PEERDIR и мультимодули 

Система сборки `ya make` поддерживает *мультимодули*. Это способ описания различных вариантов сборки одного и того же исходного кода для разных целей использования. В случае использования `PEERDIR` на *мультимодуль*, конкретный вариант определяется типом модуля, в котором этот `PEERDIR` указан.

Примеры:
- Для мультимодуля типа `PROTO_LIBRARY`, если `PEERDIR` указан в `JAVA_LIBRARY`, то создается зависимость на `Java`-вариант, а если в `LIBRARY`, то на `C++` вариант.
- `PY23_LIBRARY` — это мультимодуль, позволяющий собирать `Python-код` как для `Python 3` (как `PY3_LIBRARY`) так и для `Python 2` (как `PY2_LIBRARY`). Соответственно, `PEERDIR` из `PY3_PROGRAM` выберет вариант для `Python 3`. Важно отметить, что этот вариант для своих зависимостей также будет выбирать соответствующие варианты (это соответствует поведению `PY3_LIBRARY`).
- `PY3_PROGRAM` является мультимодулем, включающим библиотеку с кодом, аналогичным `PY3_LIBRARY`, и исполняемую программу, аналогичную `PROGRAM`, но со встроенным интерпретатором `Python 3`. Это позволяет использовать `PEERDIR` из `PY3TEST`, который сделает код программы (ее библиотечную часть) доступным в коде теста.

Выбор вариантов в *мультимодулях* управляется теми же тегами, которые используются для контроля совместимости. Общее правило такое:

*`PEERDIR` разрешен только на совместимый модуль. Если вариантов несколько, будет выбран совместимый. Если вариантов нет вообще или нет совместимых, будет выдана ошибка конфигурации `BadDir`.*

### SRC

```
SRC(Source Flags...)
```
Добавляет один файл исходного кода в сборку.

Файл будет обработан на основе его расширения. При стандартной обработке будут также применены флаги `Flags…`, специфичные для команды обработки этого типа файлов (например, флаги компиляции для `C++`).

### SRCS 

```
SRCS( ([GLOBAL] Files)... )
GLOBAL_SRCS(Files...)
```
Добавляет набор файлов исходного кода в сборку, обрабатывая каждый файл на основе его расширения.

Макрос `SRCS` действует по-разному для различных типов файлов и модулей, а иногда и для разных вариаций мультимодуля:
- В модулях типа `GO_LIBRARY`, `GO_PROGRAM` и т.п. макрос `SRCS` поддерживает исходный код на языке `Go`, в то время как модули на других языках его не поддерживают.
- В `PROTO_LIBRARY` файлы `.proto` обрабатываются по-разному в зависимости от языкового варианта.

Параметр `GLOBAL` обеспечивает включение результата сборки файла в программу, как если бы объектный файл, полученный из указанного исходного файла, подавался в строку линковки напрямую. Параметр действует только на один файл, указанный сразу после него.

Макрос `GLOBAL_SRCS` эквивалентен применению параметра `GLOBAL` в макросе `SRCS` перед всеми перечисленными файлами.

Для сборки кода на `Python` и `Java` исходные файлы указываются в макросах `PY_SRCS` и `JAVA_SRCS` соответственно. Это связано с тем, что при сборке для этих языков исходные файлы обрабатываются специальным образом, и эти макросы позволяют указывать специальные параметры для этой обработки.

Дополнительно:
- Модули `Python` поддерживают макрос `SRCS` для исходного кода на `C++` и других поддерживаемых в этом макросе языках. Использование этого макроса приведет к обработке файлов до объектного кода, который будет собран в библиотеку. Этот код затем будет линкован в программу и может быть использован из Python-кода через биндинги, такие как `Cython`.
- Модуль `EXTERNAL_JAVA_LIBRARY` поддерживает очень ограниченный набор типов файлов в макросе `SRCS` через специальную обработку файлов, совместимую с `Java` (например, порождение `.java` или `.jsrc` на выходе).

### SRCDIR

```
SRCDIR(
     Dirs...
)
```
Макрос `SRCDIR` позволяет добавлять пути для поиска исходных файлов (входов для команд). Относительно этих путей будут искаться не только файлы, указанные в макросе `SRCS` и аналогичных макросах, но и входные файлы во всех остальных макросах, например в параметре `<value>` макроса `RESOURCE` или в параметре `IN` макроса `RUN_PROGRAM`.

При описании сборки в `ya.make` входные файлы могут быть указаны полностью, даже с указанием `${BUILD_ROOT}` (дерево исходного кода) или `${DIR_BUILD_ROOT}` (дерево сгенерированных файлов). Однако, в большинстве случаев, указывается относительный путь, который система сборки должна превратить в путь к реальному файлу либо в дерево исходного кода, либо в дерево сгенерированных файлов. Этот процесс называется *резолвинг*.
Он пытается подобрать директорию, относительно которой указано имя файла. По умолчанию, список директорий для такого поиска включает `${BUILD_ROOT}` (дерево исходного кода), `${DIR_BUILD_ROOT}` (дерево сгенерированных файлов) и `${CURDIR}` (директория проекта в дереве исходного кода) — именно в таком порядке.

Макрос `SRCDIR` позволяет расширить этот список, добавляя другие директории.
- Директории в дереве исходного кода должны указываться от корня репозитория, указание `${BUILD_ROOT}` не обязательно.
- Директории в дереве сгенерированных файлов (если требуется указание генерированных файлов не от корня) должны быть обязательно указаны от корня с включением самого корня, например `${DIR_BUILD_ROOT}/1st_level_dir/subdir`.

Рекомендации по использованию макроса `SRCDIR`:
1. Мы не рекомендуем использовать макрос `SRCDIR` без необходимости: в большинстве случаев он усложняет понимание описания сборки, так как скрывает реальное расположение исходных файлов в макросах.
2. Не используйте макрос `SRCDIR`, чтобы переиспользовать одни и те же исходные файлы в разных модулях. Каждый файл анализируется системой сборки один раз, и такое *воровство исходных файлов* может привести к пропущенным зависимостям, неоднозначностям в описании сборки и другим проблемам.

### ADDINCL

```
ADDINCL(
     ([GLOBAL|ONE_LEVEL] [FOR lang] Dirs)...
)
```

Макрос `ADDINCL` позволяет добавить пути для поиска файлов, используемых в конструкциях `include/import в файлах`, участвующих в сборке модуля.

Система сборки анализирует исходные файлы для выявления зависимостей между ними. Она получает список имен, по которым ей нужно найти реальные файлы. Этот процесс называется *резолвинг*.
Процесс *резолвинга* пытается определить директорию, относительно которой указано имя файла. Для `include` и `import` операций этот процесс отличается от резолвинга исходных файлов:
* Поиск может быть разным для различных типов файлов.
* Часть файлов может отсутствовать в репозитории проекта (например, загружаться вместе со сборочными инструментами). В некоторых случаях это может означать несколько разных файлов. Дополнительная информация об этом указана в разделе о инклуд-операциях в `С++`.
- По умолчанию список директорий для поиска включает в себя `.` (путь до файла, в котором написан `include`, применяется не всегда), `${DIR_BUILD_ROOT}` (дерево генерированных файлов), `${BUILD_ROOT}` (дерево исходного кода). Это отличается от списка, используемого в `SRCDIR`.

Помимо *резолвинга*, макрос `ADDINCL` передает пути для поиска в соответствующие инструменты, чтобы при сборке эти инструменты могли найти упомянутые файлы.

Макрос `ADDINCL` позволяет задавать директории поиска для каждого языка независимо. Так как основной потребитель этого макроса — `C++`, то при использовании без указания языка директории считаются директорией поиска для `C++`. Также можно указать пути для других языков:

* `ADDINCL(FOR asm ...)`
 * `ADDINCL(FOR asp ...)`
 * `ADDINCL(FOR c ...)` дефолт если не указан язык явно
 * `ADDINCL(FOR cython ...)`
 * `ADDINCL(FOR flatc ...)`
 * `ADDINCL(FOR fortran ...)`
 * `ADDINCL(FOR gperf ...)`
 * `ADDINCL(FOR idl ...)`
 * `ADDINCL(FOR lex ...)`
 * `ADDINCL(FOR nlg ...)`
 * `ADDINCL(FOR proto ...)`
 * `ADDINCL(FOR ragel ...)`
 * `ADDINCL(FOR sc ...)`
 * `ADDINCL(FOR swig ...)`
 * `ADDINCL(FOR xs ...)`
 * `ADDINCL(FOR xsyn ...)`
 * `ADDINCL(FOR yacc ...)`
 * `ADDINCL(FOR ydl ...)`

Макрос `ADDINCL` позволяет указать директории поиска включаемых файлов не только для текущего модуля, но и для модулей, которые от него зависят, с помощью модификаторов `GLOBA`L или `ONE_LEVEL`. Это особенно важно, когда одна сторонняя библиотека в своих заголовочных файлах включает заголовочные файлы другой сторонней библиотеки. В этом случае дополнительные флаги с директориями поиска нужно передавать при компиляции как самой библиотеки, так и тех библиотек, которые её используют.

- `GLOBAL` действует на все модули, зависящие от данного как напрямую, так и транзитивно через другие модули. Это позволяет использовать имя файла относительно указанного пути поиска как в исходных, так и в заголовочных файлах, распространяя их использование по зависимостям.
- `ONE_LEVEL` действует только на модули, напрямую зависящие от данного. Такое поведение может применяться в двух сценариях:
1. Путь поиска для приватного интерфейса, который должен использоваться только другими частями реализации библиотеки, но не должен быть доступен внешним пользователям.
2. Путь поиска обеспечивает *резолвинг* локальных файлов с общими именами (например, `stdio.h` или `config.h`). Обычно такие имена должны ссылаться на стандартную библиотеку или на файл той библиотеки, к которой относится код. Использование `ADDINCL(GLOBAL)` привело бы к нежелательному резолвингу в зависящих модулях, и добавление `ADDINCL()` во всех прямых пользователях может быть неудобным и сложным в поддержке.

При использовании макроса ADDINCL:
- Директории в дереве исходного кода должны указываться от корня репозитория проекта, указание `${BUILD_ROOT}` не обязательно.
- Директории в дереве сгенерированных файлов (если требуется указание генерированных файлов не от корня) должны быть указаны от корня с указанием самого корня, например `${DIR_BUILD_ROOT}/1st_level_dir/subdir`.

Рекомендуется указывать все импорты и инклуды от корня репозитория проекта. Механизм `ADDINCL` предназначен для работы с `contrib` кодом или кодом, который выкладывается в `opensource`.

### RUN_PROGRAM/PYTHON/RUN_PYTHON3/RUN_LUA

```
RUN_PROGRAM(
    tool_path args...
    [CWD dir]
    [ENV key=value...]
    [TOOL tools...]
    [IN[_NOPARSE] inputs...]
    [OUT[_NOAUTO] outputs...]
    [STDOUT[_NOAUTO] output]
    [OUTPUT_INCLUDES output_includes...]
    [INDUCED_DEPS $VARs]
)
```

```
RUN_PYTHON3(
    script_path args...
    [CWD dir]
    [ENV key=value...]
    [TOOL tools...]
    [IN[_NOPARSE] inputs...]
    [OUT[_NOAUTO] outputs...]
    [STDOUT[_NOAUTO] output]
    [OUTPUT_INCLUDES output_includes...]
    [INDUCED_DEPS $VARs]
)
```

```
RUN_LUA(
    script_path args...
    [CWD dir]
    [ENV key=value...]
    [TOOL tools...]
    [IN[_NOPARSE] inputs...]
    [OUT[_NOAUTO] outputs...]
    [STDOUT[_NOAUTO] output]
    [OUTPUT_INCLUDES output_includes...]
    [INDUCED_DEPS $VARs]
)
```

Для запуска производной кодогенерации можно использовать макросы, которые работают с собранной из репозитория программой (`RUN_PROGRAM`) или со скриптами на `Python (версии 2 или 3)` или `Lua`. Основные принципы работы и параметры для всех макросов одинаковы, только первый параметр различается.

- Для `RUN_PROGRAM` первый параметр — это путь к директории с файлом `ya.make`, который описывает сборку программы (`PROGRAM`, `GO_PROGRAM`, `PY3_PROGRAM` и т.п.). Во время сборки программа будет собрана под текущую платформу и запущена для генерации исходного кода. Все зависимости программы учитываются автоматически, и при их изменении программа пересобирается и перезапускается.
- В других макросах первый параметр — это путь к скрипту от корня репозитория. Для `Lua` и `Python` скрипты просто выполняются интерпретатором без компиляции. Если скрипт зависит от других файлов, их нужно явно указать в параметре `IN`, иначе они не будут учтены.

Общие параметры для всех макросов:

* `args` — Аргументы для программы или макроса, передаваемые через командную строку. Если аргументы совпадают с именами, указанными в `IN`, `IN_NOPARSE`, `TOOL`, `OUT` или `OUT_NOAUTO`, они будут преобразованы в абсолютные пути к этим файлам. Считается, что они в точности являются входными или выходными файлами, указанными в параметрах. На данный момент отключить это поведение нельзя. Если это не нужно, рекомендуется изменить имя параметра или же добавить параметр, соответствующий корню репозитория, и рассчитать относительный путь.

* `CWD` — Рабочая директория для запуска программы или скрипта. Путь должен включать корень, например, `${BUILD_ROOT}` или `${BINDIR}`. Важно явно указывать рабочую директорию, если это критично, поскольку умолчания для локальной сборки и `distbuild` разные.

* `ENV` — Переменные среды для запуска программы или скрипта. Укажите их явно, так как наличие переменных вроде `$HOME` или `$PATH` не гарантируется.

* `TOOL` — Пути к `ya.make`, которые собирают программы или библиотеки, необходимые для исполнения программы или скрипта. Все они будут собраны под текущую платформу и доступны по путям в репозитории проекта.

* `IN[_NOPARSE]` — Входные файлы для запуска программы или макроса. Явные файлы должны быть указаны в `args`, значения из `IN` и `IN_NOPARSE` не попадают в командную строку, но учитываются как зависимости. Указывайте все файлы, используемые генератором, иначе изменения в неуказанных файлах не приведут к перегенерации. Файлы из `IN` анализируются на зависимости на основе их расширений, для отключения этого используйте `IN_NOPARSE`.  Параметр требует перечислять именно файлы, не директории. Однако, с помощью макроса `DECLARE_IN_DIRS` можно сформировать список файлов в директории по маске в виде переменной. Эту переменную можно передать в параметр `IN`, а также получить через нее имена для передачи в командную строку. 

* `OUT[_NOAUTO]` — Выходные файлы, созданные генератором. Если путь не указан с `${DIR_BUILD_ROOT}`, он считается относительным от `${BINDIR}`. Указывайте явно все генерируемые файлы. Если результатов много, можно запаковать их генератором в `.tar-архив` и обрабатывать в следующих командах уже весь архив целиком, описав его там как вход. Файлы из параметра `OUT` далее автоматически обрабатываются в соответствии с их расширением. Чтобы отключить эту обработку или если правил обработки нет, используйте вариант `OUT_NOAUTO`.

* `STDOUT[_NOAUTO]` — Аналогичный параметр для случая, когда генератор пишет в стандартный поток вывода. Укажите один файл как `STDOUT` или `STDOUT_NOAUTO`.

* `OUTPUT_INCLUDES` — параметр, позволяющий задать явные зависимости генерируемых файлов. `OUTPUT_INCLUDES` позволяет перечислить файлы, от которых зависят результаты генерации. Эти файлы будут предоставлены командам обработки генерируемых файлов, а не команде генерации. При их изменении будет перезапущена обработка результатов генерации (например, компиляция), а не сама генерация. Необходимо учитывать, что: 
   - Все файлы, указанные в этом параметре, будут считаться зависимостями для всех файлов, перечисленных в `OUT[_NOAUTO]` и `STDOUT[_NOAUTO]`. Более точной фильтрации по именам выходных файлов или их расширениям не предусмотрено.
   - Для некоторых расширений система сборки автоматически считает файлы зависимостями не только для самих результатов генерации, но и для последующей обработки этих результатов (например, при генерации `.pyx` это будут и другие `.pyx` и `.h`, включенные в `.pyx`). Здесь также отсутствует возможность фильтрации.
   - Не указывайте в этом параметре файлы из `OUT[_NOAUTO]` и `STDOUT[_NOAUTO]`, так как это создаст цикл зависимостей, где файл будет зависеть от самого себя, что может вызвать проблемы при анализе.

Если программа-генератор, используемая в `RUN_PROGRAM`, всегда генерирует одни и те же зависимости (или их часть), она может указать их в своем модуле с помощью макроса `INDUCED_DEPS`. В этом случае вам не нужно будет перечислять эти зависимости в `OUTPUT_INCLUDES` для каждого вызова `RUN_PROGRAM` этого генератора.

* `INDUCED_DEPS` — Зависимости генерируемых файлов определенного типа. Используйте этот параметр для задания зависимостей только определенных типов файлов. В некоторых случаях параметр `OUTPUT_INCLUDES` действует слишком широко, делая указанные файлы зависимостями для всех результатов макроса. Если нужно, чтобы файлы стали зависимостями только определенных типов файлов, используйте параметр `INDUCED_DEPS`. Для этого передавайте в него значение переменной, подготовленное с помощью макроса `PREPARE_INDUCED_DEPS`.

* Все списочные параметры, такие как `ENV`, `IN`, `OUT`, могут быть указаны несколько раз. Значением параметра является список строк, разделённых пробелами от имени параметра до имени другого параметра или закрывающей скобки.

**Пример для а/b/ya.make:**
```
 RUN_PYTHON3(run.py x.inp xx.inp y.cpp ENV X=xx IN x.inp xx.inp OUT y.cpp IN .run.settings ENV HOME=${CURDIR})

 # Командная строка:
 #   python3 ${BUILD_ROOT}/a/b/run.py ${BUILD_ROOT}/a/b/x.inp ${BUILD_ROOT}/a/b/xx.inp ${DIR_BUILD_ROOT}/a/b/y.cpp
 # Параметры:
 #   ENV=['X=xx', 'HOME=${BUILD_ROOT}/a/b']
 #   IN=['${BUILD_ROOT}/a/b/x.inp', '${BUILD_ROOT}/a/b/xx.inp', '${BUILD_ROOT}/a/b/.run.settings']
 #   OUT=['${DIR_BUILD_ROOT}/a/b/y.cpp']
```

Параметры `OUT_NOAUTO` или `STDOUT_NOAUTO` одного макроса могут быть в `IN`, `IN_NOPARSE` и `OUTPUT_INCLUDES` другого, при этом они могут находиться как в одном `ya.make`, так и в разных. Важно, чтобы `ya.make` с макросом-потребителем имел зависимость `PEERDIR` хотя бы косвенно на `ya.make` с макросом-источником.

**Пример:**
```
RUN_PYTHON3(${BUILD_ROOT}/devtools/dummy/includes/gen.py
    inc.h.gen inc.h
    # preinc.h генерируется выше и является зависимостью команды генерации
    # Эта команда запустится второй и получит результат первой на вход
    IN inc.h.gen preinc.h
    OUT inc.h
)

RUN_PYTHON3(${BUILD_ROOT}/devtools/dummy/includes/gen.py
    preinc.h.gen preinc.h
    IN preinc.h.gen
    OUT preinc.h       # Этот результат употребится верхним макросом
    # inc.h ниже генерируется верхним макросом, но это ОК, поскольку OUTPUT_INCLUDES — это
    # зависимости не команды генерации, а её результата. Эта команда выполнится первой
    OUTPUT_INCLUDES ${DIR_BUILD_ROOT}/devtools/dummy/includes/ambig_source_generated_from_gen/inc.h
)

```

#### PREPARE_INDUCED_DEPS
```
PREPARE_INDUCED_DEPS(VAR Type Files...)
```
Определите файлы `Files` как зависимости для заданного типа выходных файлов, которые могут быть использованы в макросах, таких как `RUN_PROGRAM`.

Параметры:
* `Type` - тип файлов, для которых устанавливаются зависимости. Эти типы аналогичны тем, что используются в макросе `INDUCED_DEPS`.
* `Files` - список файлов, которые будут являться зависимостями для выбранных генерированных файлов.

Это описание не обязательно применяется непосредственно к генерируемым файлам, а может также относиться к производным генерированным файлам в цепочке обработки выходных файлов по расширениям. Типичным примером является `Cython`: сгенерированный файл `.pyx` может импортировать файл `.pxd` и включать заголовочный файл (`.h`) с помощью `cimport`. В данном случае первый файл является зависимостью для самого `.pyx-файла` (он требуется для генерации кода), в то время как второй файл является зависимостью сгенерированного кода (`.pyx.cpp`), он необходим для компиляции этого кода.

Для этого примера описание зависимостей может выглядеть так:

```
PREPARE_INDUCED_DEPS(PYX_DEPS pyx imported.pxd)
PREPARE_INDUCED_DEPS(CPP_DEPS cpp cdefed.h)
RUN_PYTHON3(generate_pyx.py genereted.pyx OUT generated.pyx INDUCED_DEPS $PYX_DEPS $CPP_DEPS)
```

Переменная `VAR` представляет собой пару в формате `Type:[Files...]`, который подходит для передачи соответствующему параметру макросов, таких как `RUN_PROGRAM`. Это решение принято потому, что в текущей версии языка `ya.make` не поддерживаются словари и массивы словарей в качестве значений для параметров макросов.

#### DECLARE_IN_DIRS

```
DECLARE_IN_DIRS(var_prefix files_mask DIRS dirs [RECURSIVE] [EXCLUDES excludes] [SRCDIR srcdir])
```
Макрос для создания переменных, который помогает получить список файлов в директории и передать его в макросы типа `RUN_PROGRAM` через параметр `IN`.

Параметры макроса уже проходят валидацию, хотя некоторые списки могут не работать корректно или вовсе не работать, например, из-за превышения длины командной строки. В будущем валидация может быть улучшена для предотвращения слишком больших списков, а также чрезмерных или глубоких зависимостей. Предполагается, что макрос будет использоваться для локальных списков файлов с ограниченным размером.

Макрос создает переменную специального типа список файлов, которая может быть использована только в определенных контекстах. Список файлов, созданный этим макросом, не будет работать в макросах типа `SRCS`, которые создают отдельную команду для каждого файла, а также в макросах, которые требуют значения на ранних стадиях выполнения, например, `SET` или `MESSAGE`. Весь список должен обрабатываться одной командой, что возможно только с помощью макросов, таких как `RUN_PROGRAM` и аналогичных.

Файлы, полученные этим макросом, не анализируются на зависимости. Для корректной работы их необходимо передавать в параметр `IN`, а не `IN_NOPARSE`.

Правила получения списка файлов:
- Поиск файлов осуществляется в директории `<srcdir>`, которая задается относительно модульной директории и по умолчанию совпадает с ней.
- Внутри `<srcdir>` файлы ищутся в директориях `<dirs>`, рекурсивно или нет в зависимости от параметра `RECURSIVE`.
- Файлы фильтруются по маске `<files_mask>`, поддерживающей `*` и `?`.
- Из полученного списка исключаются файлы по маске `<excludes>`, которая может быть рекурсивной (включать `**`). Также исключаются файлы типа `ya.make`.

Макрос определяет 4 переменные с префиксом `<var_prefix>`:
- `<var_prefix>_FILES` - список файлов, полученный по вышеуказанным правилам. Эта переменная может быть передана как параметр `IN` в макросы типа `RUN_PROGRAM`. Также она может (с экранированием) использоваться в командной строке вызова программы или скрипта. Подробнее см. примеры ниже.
- `<var_prefix>_PATTERNS` - шаблоны для выбора файлов.
- `<var_prefix>_EXCLUDES` - шаблоны для исключения файлов. Помимо указанных в параметре `EXCLUDES` включают исключение для файлов `ya.make`.
- `<var_prefix>_SRCDIR` - значение параметра `SRCDIR`.

Параметры:
* `var_prefix` - (Обязательный). Префикс для переменных, создаваемых макросом.
* `file_mask` - (Обязательный) Маска для выбора файлов, не должна содержать `**`.

Для масок файлов частично поддерживаются регулярные выражения. Это может быть полезно, например, для выбора файлов по нескольким расширениям, таким как (`*.cpp|*.h`). Однако такой же шаблон попадет в переменную `<var_prefix>_PATTERNS`, и если она передается программе или скрипту, то они тоже должны поддерживать эту функциональность. Если программа или скрипт используют свою собственную логику для поиска файлов, то значение переменной им не потребуется и это не будет проблемой.

* `DIRS dirs` - (Обязательный) Список директорий для поиска файлов относительно текущей или `SRCDIR`. Не должен содержать `${BUILD_ROOT}` и подобные конструкции, `..`, `*` или `?`.
* `RECURSIVE` - Если задан, файлы будут искаться в `DIRS` рекурсивно. Без этого параметра поиск будет выполняться только в указанных директориях.
* `EXCLUDES excludes` - Опциональная маска для исключения определенных файлов из списка.
* `SRCDIR srcdir` - Опциональная базовая директория. Если не задана, берется директория, где находится `ya.make`. Использование `srcdir` за пределами текущей директории крайне не рекомендуется, хотя и не запрещено. Значение может содержать `..` или начинаться с `${BUILD_ROOT}`, чтобы адресоваться от корня репозитория. Однако `srcdir` не может быть маской и содержать `*` или `?`.

При раскрытии списка в командной строке могут возникнуть проблемы с пустым списком. Это известная проблема. Обычно ее можно обойти, добавив явный параметр в командную строку, например, `concat.py \${TXT_FILES} -> concat.py - \${TXT_FILES}`.

Работа `EXCLUDES` зависит от того, указан `SRCDIR` или нет. Чтобы точно и нерекурсивно исключить файлы при указанном `SRCDIR`, используйте префикс.

Например, если заданы параметры `SRCDIR a/b/zz EXCLUDE *.x`, то `*.x` применится ко всем файлам внутри `zz` рекурсивно. Чтобы ограничить исключения только одним уровнем, используйте такие параметры: `SRCDIR a/b/zz EXCLUDE zz/*.x`.

**Примеры:**
```
DECLARE_IN_DIRS(TXT *.txt DIRS . EXCLUDE .*.txt **/.*.txt)
# file list requires escaping as argument
RUN_PYTHON3(concat.py \${TXT_FILES} IN ${TXT_FILES} STDOUT concatenated.txt)
```

```
DECLARE_IN_DIRS(ALL_TXT *.txt SRCDIR txt RECURSIVE DIRS design rules EXCLUDE all.txt)
RUN_PYTHON3(concat_all.py --dirs ${MODDIR}/${ALL_TXT_SRCDIR} --pattern ${ALL_TXT_PATTERNS} --exclude ${ALL_TXT_EXCLUDES} IN ${ALL_TXT_FILES} STDOUT concatenated.txt)
```

```
DECLARE_IN_DIRS(D_TXT *.txt SRCDIR txt/design EXCLUDE all.txt DIRS .)
DECLARE_IN_DIRS(R_TXT *.txt SRCDIR txt/rules DIRS .)
RUN_PYTHON3(concat_all.py --dirs ${MODDIR}/${D_TXT_SRCDIR} ${MODDIR}/${R_TXT_SRCDIR} --patterns ${D_TXT_PATTERNS} ${R_TXT_PATTERNS} --exclude ${D_TXT_EXCLUDES} IN ${D_TXT_FILES} ${R_TXT_FILES} STDOUT concatenated.txt)
```


### COPY_FILE/COPY_FILE_WITH_CONTEXT

```
COPY_FILE(
    Src Dst
    [AUTO]
    [OUTPUT_INCLUDES output_includes...]
)
```

```
COPY_FILE_WITH_CONTEXT(
    Src Dst
    [AUTO]
    [OUTPUT_INCLUDES output_includes...]
)
```
Макросы для получения файлов в сборочной директории модуля с возможностью их переименования или перемещения.

* Исходный файл `Src` может находиться как в репозитории, так и быть сгенерированным в процессе сборки. Конкретный файл определяется по имени через механизм разрешения имён (*резолвинга*).

- Результирующий файл `Dst` рассматривается как относительный путь от директории модуля в сборочном дереве `${BINDIR}`.

- Макрос `COPY_FILE` делает файл текстовым, то есть на него не распространяется анализ зависимостей исходного файла. Макрос `COPY_FILE_WITH_CONTEXT` позволяет скопировать файл вместе с его зависимостями. Список зависимостей для полученного файла можно указать с помощью параметра `OUTPUT_INCLUDES`, который используется аналогично одноименному параметру в макросе `RUN_PROGRAM`. В случае `COPY_FILE_WITH_CONTEXT` это будут дополнительные зависимости, а в случае `COPY_FILE` — все зависимости.

- По умолчанию скопированные файлы не будут автоматически обрабатываться по расширению. Чтобы включить такую обработку, вы можете явно указать файл в макросе `SRCS` или использовать параметр `AUTO`.

### INDUCED_DEPS

```
INDUCED_DEPS(Kind Paths...)
```

Установите зависимости для кода, генерируемого программой.

Для исходного кода система сборки может автоматически выводить зависимости путем парсинга исходных файлов. Однако, поскольку это происходит до выполнения сборки, для генерируемого кода такой подход невозможен. Поэтому зависимости для генерируемого кода необходимо указывать явно. В макросах, таких как `RUN_PROGRAM`, для этого предусмотрен параметр `OUTPUT_INCLUDES`. Если программа-генератор всегда включают фиксированный набор зависимостей, вы можете описать их вместе с программой в модуле `PROGRAM/PY3_PROGRAM/GO_PROGRAM` и аналогичных. Тогда, при использовании этой программы в качестве генератора (первый параметр макроса `RUN_PROGRAM`) или дополнительного инструмента (параметр `TOOL`) любого из макросов генерации кода, указанные зависимости автоматически станут зависимостями для генерируемых файлов.

Нужно указать, к каким типам файлов применяются зависимости, используя параметр `Kind`. Поддерживаются следующие варианты:

| Kind | Вид зависимостей |
| ------- | ------------------------------------------- |
| go | импорты в Go |
| h | инклуды в заголовочных файлах C++ |
| cpp | инклуды в исходных файлах C++ |
| h+cpp | инклуды в C++ (включая исходные и заголовочные файлы) |
| proto | импорты в proto-файлах |
| idl | импорты в IDL-файлах mapkit |

Если генерируется и `.cpp` файл и `.h` файл, и первый из них включает второй, зависимости для заголовочного файла следует указывать как `h+cpp`. Саму зависимость `.cpp` от `.h`, порождаемую одним генератором, описывать не нужно: это может вызвать цикл зависимостей и некорректную работу сборки.

Поскольку файлы будут использоваться не в том модуле, где описаны зависимости, указания не должны полагаться на *резолвинг* по месту использования. Поэтому все файлы должны быть указаны с полными путями, включая `${BUILD_ROOT}` или `${DIR_BUILD_ROOT}`. Если зависимые файлы не находяться в репозитории или могут ссылаться на разные файлы в различных конфигурациях, рекомендуется создать рядом с программой файл, где указаны все необходимые зависимости, и уже этот файл использовать в макросе.

**Пример:**
```
PROGRAM()

OWNER(g:group)

SRCS(
    main.cpp
)

# Это включается и в код, и в хедер
INDUCED_DEPS(h+cpp
    ${DIR_BUILD_ROOT}/kernel/web_factors_info/metadata/factors_metadata.pb.h
    ${BUILD_ROOT}/util/network/address.h
)

# Это включается только в код
INDUCED_DEPS(cpp
    ${BUILD_ROOT}/util/network/endpoint.h
)

# Это включается только в хедер
INDUCED_DEPS(h
    ${BUILD_ROOT}/util/network/interface.h
)

PEERDIR(
    kernel/web_factors_info/metadata
)

END()
```

### BUNDLE

```
BUNDLE(TargetPath [NAME ResultName])
```
Привязать результат сборки одного модуля к другому модулю в виде файла. Этот результат может быть использован, например, в макросах `RESOURCE` или как побочный продукт в модуле `UNION`. В отличие от `PEERDIR`, модуль из `BUNDLE` не станет зависимостью самого модуля (команды сборки модуля), а будет входными данными для макросов в модуле.

- Как и в других подобных модулях, `TargetPath` — это имя директории с файлом `ya.make`, который собирает требуемый модуль и его артефакт.
- Параметр `NAME` позволяет задать фиксированное имя артефакта в текущем модуле.

**Пример:**

test_bundle/ya.make
```
LIBRARY()

BUNDLE(test_bundle/prg NAME prg2)

RESOURCE(prg2 /prg)

END()
```

test_bundle/prg/ya.make
```
PROGRAM()

SRCS(main.cpp)

END()
```
Рекомендации:
- Если у модуля несколько результатов сборки, макрос `BUNDLE` всегда выбирает основной артефакт. Обычно это именно то, что требуется (например, программа или динамическая библиотека).
- Если `TargetPath` указывает на файл `ya.make` с мультимодулем, будет выбран вариант, который собирает конечный артефакт (например, программу или динамическую библиотеку, а не статическую библиотеку). Если таких вариантов несколько, будет выдана ошибка.

### RESOURCE 

```
RESOURCE([FORCE_TEXT ][Src Key]* [- Key=Value]*)
```

Макрос для добавления произвольных данных в код программы, которые могут быть взяты из файлов или переданы непосредственно через параметр макроса. Для доступа к этим данным доступны библиотеки для языков `C++`, `Python` и `Go`.

Поддерживаются два варианта использования макроса:

1. Включение содержимого файлов:

```
RESOURCE(
    path/to/file1 key/in/program/1
    path/to/file2 key2
)
```
Содержимое файлов `path/to/file1` и `path/to/file2` будет включено в код программы и доступно по ключам `key/in/program/1` и `key2` соответственно. Файлы, указанные в первом параметре, могут быть как файлами в репозитории, так и генерируемыми. В случае генерации файлов рекомендуем использовать префиксы `${DIR_BUILD_ROOT}` или `${BINDIR}`, чтобы упростить понимание процесса.

2. Включение строки как ресурса:

```
    RESOURCE(- my/key=my/value)
```
Строка `my/value` будет включена в код программы и доступна по ключу `my/key`. Этот механизм особенно полезен для передачи информации из сборки в программу на `Python` и других языках.

```
IF (WITH_FEATURE_X)
    RESOURCE(- featuters/x=enabled)
ENDIF()
```
В С++ того же можно было бы добиться через `CFLAGS(-DFEATURE_X)`, но в Python ничего подобного нет.

***

**Пример для C++**

Поддержка доступа к ресурсам реализована в `library/cpp/resource`.

В `ya.make`:

```
PEERDIR(
    library/cpp/resource
)

```

В `source.cpp`:

```
#include <library/cpp/resource/resource.h>

#include <util/stream/ios.h>

int main() {
    Cout << NResource::Find("key/in/program/1") << Endl;
    Cout << NResource::Find("key2") << Endl;
}

```
`key/in/program/1` и `key2` не должны содержать названия файлов `path/to/file1` и `path/to/file2`.

***

**Пример для Python**

В питоне нужно использовать `library/python/resource`

```
PEERDIR(
    library/python/resource
)

```

В `source.py`:

```
from library.python import resource
r1 = resource.find("key/in/program/1")
r1 = resource.find("key2")

```

***

**Пример для Go**

В go для доступа к ресурсам используйте модуль `library/go/core/resource`.

Подгружать ресурс, когда вам нужно как-то парсить его данные можно, например, так:

```
var resourceParsedData ResourceType
var initResourceOnce = sync.Once{}

func GetResource() ResourceType {
    initResourceOnce.Do(parseResource)

    return resourceParsedData
}

func parseResource() {
    resourceParsedData = ResourceType{}

    jsonData := resource.Get("/key2")
    if jsonData == nil {
        return
    }

    _ = json.Unmarshal(jsonData, &resourceParsedData)
}

```
1. Из-за особенностей инициализации ресурсов, нельзя просто так взять и создать свой собственный пакет, в котором подгружать содержимое ресурса в init'е пакета. Так вам стабильно будет возвращаться пустые данные (будто ресурса не существует)

2. Механизмы включения ресурсов в код для С++/Python и Go не совместимы между собой. Ресурсы, включённые в код в C++ библиотеке и влинкованные через CGO, не будут доступны через go-библиотеку для доступа к ресурсам.

3. Механизм включения ресурсов в код для Go макросом `RESOURCE` не совместим с `go embed`. Механизм `go embed` поддерживается системой сборки ya make.

***

По умолчанию, система сборки проверяет все входные файлы на зависимости от других файлов. Однако для файлов, используемых в качестве ресурсов, это обычно не требуется. Полное отключение анализа в данный момент слишком затратное. Чтобы отключить анализ, используйте параметр `FORCE_TEXT`, если хотите включить файл, для которого такой анализ выполняется.

Параметр `FORCE_TEXT` не доступен в макросе `RESOURCE` для `go`.

Макрос `RESOURCE` позволяет включать файлы, доступные в сборке, а также строки.


### RESOURCE_FILES 

```
RESOURCE_FILES([PREFIX {prefix}] [STRIP prefix_to_strip] {path})

```
Макрос `RESOURCE_FILES` представляет собой расширение макроса `RESOURCE` и имеет следующие особенности:

- В `RESOURCE_FILES` можно просто указывать файлы, в то время как в `RESOURCE` необходимо задавать ключ для каждого файла.
- `RESOURCE_FILES` запоминает пути к файлам.

Сохранение путей к файлам полезно для диагностики (программа может указать источник ресурса), для опционального чтения файлов с файловой системы (используется с `Y_PYTHON_SOURCE_ROOT`) и для распаковки ресурсов на файловую систему.

Файлы будут сохраняться с ключом `resfs/src/{prefix}/{stripped path}`.

#### Реализация

`RESOURCE_FILES` является подпространством в пределах пространства имён `RESOURCE`. Например, если в файле `aa/ya.make` указаны `RESOURCE_FILES(PREFIX bb/ c/d)`, и существует файл `aa/c/d` с содержимым `e`, то будут созданы следующие ресурсы:

- Файл ресурса с ключом `bb/c/d` (resource file with key=`bb/c/d`), значением `e` (value=`e`) и источником `aa/c/d` (src=`aa/c/d`).
- Ресурс с ключом `resfs/file/bb/c/d` (resource with key=`resfs/file/bb/c/d`) и значением `e` (value=`e`).
- Ресурс с ключом `resfs/src/resfs/file/bb/c/d` (resource with key=`resfs/src/resfs/file/bb/c/d`) и значением `aa/c/d` (value=`aa/c/d`).

#### Python API

`__res` определяет и `library.python.resource` реэкспортирует следующие функции:

- `resfs_files()` = `['bb/c/d', …]`
- `resfs_read('bb/c/d')` = `'e'`
- `resfs_src('bb/c/d', resfs_file=True)` = `'aa/c/d'`
- `resfs_src('resfs/file/bb/c/d')` = `'aa/c/d'`
- `resfs_resolve('aa/c/d')` = `'/home/user/arc/aa/c/d'`, если этот файл существует при env `Y_PYTHON_SOURCE_ROOT=/home/user/arc`, иначе None

приложениям на Python не надо использовать это API, если подходят стандартные pkgutil.get_data](https://docs.python.org/2/library/pkgutil.html#pkgutil.get_data) и [pkg_resources](https://setuptools.readthedocs.io/en/latest/pkg_resources.html#resourcemanager-api).

Сейчас pkg_resources api считается [Deprecated](https://setuptools.pypa.io/en/latest/pkg_resources.html), python сообщество настоятельно рекомендует использовать вместо него [importlib.resources](https://docs.python.org/3.11/library/importlib.resources.html#module-importlib.resources)


##### Пример использования `library.python.resource`

Допустим у нас есть python программа (`PY3_PROGRAM`), единственная задачей которой - вывести содержимое ресурсных файлов на стандартный выход.

Структура каталога:

```
$ tree $BUILD_ROOT/foo/bar/library_python_resource_example
~/arcadia/foo/bar/library_python_resource_example
├── extra
│   └── file.txt
├── __main__.py
├── static.txt
└── ya.make
```

`__main__.py`:

```python
import library.python.resource

print(library.python.resource.resfs_read("extra/file.txt"))
print(library.python.resource.resfs_read("static.txt"))
```

`ya.make`:

```
PY3_PROGRAM()
OWNER(the_owner)
PEERDIR(
    library/python/resource
)
PY_SRCS(
    __main__.py
)
RESOURCE_FILES(
    extra/file.txt
    static.txt
)
END()
```

Проверяем:

```
$ ya make
Ok
$ ./library_python_resource_example
b'Hello from static.txt\n'
b'Hello from file.txt\n'
```
Обратите внимание, `library.python.resource` возвращает байты.

##### Пример использования `importlib.resources`

Повторим код из предыдущего примера, будем обращать внимание на отличия

Структура каталога:
```
$ tree $BUILD_ROOT/foo/bar/importlib_resources_example
~/arcadia/foo/bar/importlib_resources_example
├── extra
│   └── file.txt
├── __init__.py  # понадобился пустой __init__.py, даже для PY3_PROGRAM или PY3TEST
├── __main__.py
├── static.txt
└── ya.make
```

`__main__.py`:

```python
import importlib.resources

root_node = importlib.resources.files(__package__)
print((root_node / "extra/file.txt").read_text())  # можем читать не только байты
print((root_node / "static.txt").read_bytes())
```

`importlib.resources.files` возвращает [importlib.resources.abc.Traversable](https://docs.python.org/3/library/importlib.resources.abc.html#importlib.resources.abc.Traversable) у него subset методов [pathlib.Path](https://docs.python.org/3/library/pathlib.html#pathlib.Path)

`ya.make`:

```
PY3_PROGRAM()
OWNER(the_owner)
PY_SRCS(
    __init__.py
    __main__.py
)
RESOURCE_FILES(
    PREFIX foo/bar/importlib_resources_example/  # понадобился PREFIX, обратите внимание на замыкающий `/`, без него работать не будет. Prefix должен совпадать с репозиторииным путем.
    extra/file.txt
    static.txt
)
END()
```

Проверяем:

```
$ ya make
Ok
$ ./importlib_resources_example
Hello from file.txt

b'Hello from static.txt\n'
```

#### Реализация PY_SRCS в Python 3

Механизм `RESOURCE_FILES` используется в сборке питона в [исполняемые программы](../python/#python_program)

Для модуля `c.f` из файла `aa/bb/c/f.py`, создаётся:

- resource file with key=`py/c/f.py`, value=содержимое `f.py`, src=`aa/bb/c/f.py`
- resource file with key=`py/c/f.py.yapyc3`, value=байткод `f.py`, src=`aa/bb/c/f.py.yapyc3`

(`aa/bb/c/f.py.yapyc3` это реальный файл в build root на выходе от прекомпилятора Python `pycc`.)

#### Взаимодействие с pkgutil.get_data

Пусть имеется `aa/ya.make` такого вида:

```yamake
OWNER(the_owner)

PY3_LIBRARY()

PY_SRCS(TOP_LEVEL
        bb/__init__.py
        bb/f.py)

RESOURCE_FILES(PREFIX aa/ bb/c/d)

END()
```

В репозитории лежат файлы `aa/bb/__init__.py`, `aa/bb/f.py`, и `aa/bb/c/d` с содержимым `e`. Тогда `f.py` может сделать `pkgutil.get_data(__package__, 'c/d')` и получить `e`, потому что:

```python
__package__ == 'bb'
bb.__file__ == 'aa/bb/__init__.py'
resource_name = join(dirname(bb.__file__), 'c/d')
resource_name == 'aa/bb/c/d'
get_data = resfs_read # для относительных путей
get_data('aa/bb/c/d') == 'e'
```

С `Y_PYTHON_SOURCE_ROOT=/home/user/arc`:

```python
bb.__file__ == '/home/user/arc/aa/bb/__init__.py'
resource_name == '/home/user/arc/aa/bb/c/d'
get_data(path) = open(path).read # для абсолютных путей
get_data('/home/user/arc/aa/bb/c/d') == 'e'
```

### ALL_RESOURCE_FILES {#all_resource_files}

```
ALL_RESOURCE_FILES(Ext [PREFIX {prefix}] [STRIP {strip}] Dirs...)
```

Является обёрткой над `RESOURCE_FILES`, позволяя положить в ресурсы все файлы с расширением `Ext` из директорий `Dirs`.

Все параметры трактуются как пути относительно текущей директории (в которой лежит ya.make), и `..` скорее всего работать не будет, либо будет работать некорректно.

## Межмодульные ограничения

### LICENSE

```
LICENSE(license...)
```

Указывает лицензию текущего модуля. Позволяет указать [SPDX выражение описывающее лицензию](https://spdx.github.io/spdx-spec/v2.3/SPDX-license-expressions/)  модуля. По умолчанию модули, не прописавшие свою лицензию через макрос `LICENSE` имеют лицензию, заданную переменной `DEFAULT_MODULE_LICENSE` в [`ymake.core.conf`](../../extension/core_conf.md)

Для каждой отдельной лицензии используемой в выражении имени лицензии должны быть описаны её свойства в файле [`ymake.core.conf`](../../extension/core_conf.md) с помощью служебных переменных `LICENSE_PROPERTIES`, `LICENSES_<PROP_NAME>_STATIC`, `LICENSES_<PROP_NAME>_DYNAMIC` или `LICENSES_<PROP_NAME>`. Лицензия, для которой не описаны её свойства считается неизвестной и её использование в макросе `LICENSE` диагностируется как ошибка конфигурации.

Из за синтаксических ограничений ya.make, при писпользвоании скобок в SPDX выражении, нужно заключить выражение или его часть использующую скобки в кавычки.

### LICENSE_RESTRICTION

```
LICENSE_RESTRICTION(ALLOW_ONLY|DENY LicenseProperty...)
LICENSE_RESTRICTION_EXCEPTIONS(LibPath...)
```

Макрос задаёт ограничение на лицензии библиотек, используемых текущим модулем напрямую или транзитивно. Если макрос используется несколько раз для одного и того же модуля, то все его вызовы должны иметь один и тот же тип ограничения (все `ALLOW_ONLY` либо все `DENY`).

 * `ALLOW_ONLY` требует, чтобы у каждой библиотеки, от которых зависит текущий модуль, была хотя бы одна лицензия, не имеющая свойств отличных от перечисленных.
 * `DENY` требует, чтобы у каждой библиотеки, от которых зависит текущий модуль, была хотя бы одна лицензия, не имеющая перечисленных свойств.

В качестве свойства лицензии используется строка, не содержащая пробелов, перечисленная в переменной `LICENSE_PROPERTIES` в файле [`ymake.core.conf`](../../extension/core_conf.md).

Лицензии могут налагать разные ограничения на проекты, линкующиеся с лицензируемой библиотекой статически и динамически.
При описании свойств лицензии указывается какие из них налагают требования на проект линкующийся с библиотекой статически, а какие ограничивают только тех, кто линкуется динамически.
Ограничения, прописанные в макросе `LICENSE_RESTRICTION` автоматически учитывают тип линковки с используемой библиотекой правильно.
Для разных языков программирования статическая и динамическая линковка (с учётом нюансов репозиторииной сборки) понимается следующим образом:

 * Компилирующиеся в нативный код языки (C++, Go): обычным образом
 * Python: так как мы складываем питон код в ресурсы герметичного бинарного файла, то все PEERDIR зависимости между модулями на python считаются статической линковкой.
 * JVM языки (Java, Kotlin): PEERDIR между библиотеками считается динамической линковкой, аналогично тому, как зависимости через classpath трактует [FSF в отношении LGPL](https://www.gnu.org/licenses/lgpl-java.en.html). Зависимость от JNI кода считается динамической линковкой.

В отдельных ситуациях соблюдение требований лицензии может быть обеспечено невидимым для системы сборки образом.
Для таких случаев в макросе предусмотрен список исключений, задаваемый макросом `LICENSE_RESTRICTION_EXCEPTIONS`.
В качестве исключений можно указывать только полный путь к библиотеке и нет никаких возможностей указывать шаблоны путей.
Этот список исключений должен использоваться только для исключительных ситуаций, явно согласованных с юристами.

### CHECK_DEPENDENT_DIRS

```
CHECK_DEPENDENT_DIRS(ALLOW_ONLY [PEERDIRS|ALL] restrictions...)
CHECK_DEPENDENT_DIRS(DENY [PEERDIRS|ALL] restrictions... EXCEPT exception)
```

Данный макрос позволяет потребовать, чтобы среди прямых и транзитивных зависимостей модуля не было нежелательных библиотек либо не использовались нежелательные сборочные инструменты. В одном модуле можно задать либо чёрный список через `CHECK_DEPENDENT_DIRS(DENY ...)` либо белый список через `CHECK_DEPENDENT_DIRS(ALLOW_ONLY ...)`. Если в одном модуле макрос используется несколько раз, то тип ограничения во всех местах вызова должен быть одинаковым (либо везде `DENY` либо везде `ALLOW_ONLY`), нарушения данного правила диагностируются как ошибки конфигурации. Ограничения от всех вызовов суммируются.

Сами ограничения можно задать двумя способами. Во-первых, это может быть путь в репозитории, тогда все модули, живущие в поддиректориях этого пути, подпадают под ограничение. Во-вторых, можно использовать ant-подобный шаблон пути, используя ключевое слово `GLOB`, и в этом случае ограничения действуют только на пути, полностью ему соответствующие, но не на их поддиректории. Например: `CHECK_DEPENDENT_DIRS(DENY some/nested/path/bad)` запретит зависимость как от `some/nested/path/bad` так и от `some/nested/path/bad/lib`, в то время как `CHECK_DEPENDENT_DIRS(DENY GLOB **/nes?ed/*/bad)` запретит от `some/nested/path/bad`, но не от `some/nested/path/bad/lib`. Ключевое слово `GLOB` действует только на следующий за ним аргумент.

По умолчанию ограничения действуют как на `PEERDIR`, так и на `TOOL` зависимости. Поведение ограничений можно переключать, используя ключевые слова `PEERDIRS` и `ALL`. Эти ключевые слова действуют на все ограничения, следующие за ними. Например
```
CHECK_DEPENDENT_DIRS(ALLOW_ONLY
    PEERDIRS
        contrib/libs
        build/platform
    ALL
        contrib/tools
)
```
позволяет проекту использовать только сторонние C++ библиотеки, сторонние сборочные инструменты и, возможно, их runtime библиотеки, лежащие рядом с самими инструментами.

При использовании `DENY` можно описывать исключения с помощью ключевого слова `EXCEPT`, которое действует на следующее непосредственно за ним ограничение, превращая его в исключение для чёрного списка:
```
CHECK_DEPENDENT_DIRS(DENY
    PEERDIRS
      some/bad/path
    EXCEPT some/bad/path/alot-of-good-libs
    EXCEPT GLOB some/bad/path/*/good
)
```

Для Java модулей ограничения, задаваемые данным макросом, проверяют classpath модуля после применения `DEPENDENCY_MANAGEMENT` и `EXCLUDE`.

### PROVIDES

```
PROVIDES(Feature...)
```

Данный макрос позволяет находить конфликты между реализациями одного и того же функционала разными библиотеками.

Библиотеки, которые могут конфликтовать друг с другом (либо разные версии одной и той же библиотеки), помечают себя как реализации именованного функционала (возможно нескольких, если требуется). На стадии конфигурации для финальных целей (программ, динамических библиотек) проверяется, что в транзитивном замыкании зависимостей нет двух библиотек, объявивших себя провайдерами одного и того же функционала. Если проверка не проходит, то генерируется ошибка конфигурации, а в диагностике указываются пути по зависимостям до каждой из библиотек, являющихся конфликтующими провайдерами.

Хорошие примеры использования:
 * protobuf и protobuf_std помечены `PROVIDES(protobuf)`
 * llvm7, llvm8 и llvm11 помечены `PROVIDES(llvm)`

### FEATURE_VERSION

Предназначен для указания конкретного значения свойства в модуле, например, версии.

Макрос может применяться многократно для указания разных свойств.

#### Как использовать

Пример использования в ya.make проекта
```
FEATURE_VERSION(feature1 ver1.1)
FEATURE_VERSION(feature2 ver2.5)
```
Для данного проекта будут зафиксированы свойства feature1=ver1.1 и feature2=ver2.5

#### Перекрытие одного и того же свойства в проекте

Например, при использовании
```
FEATURE_VERSION(feature1 ver1.1)
FEATURE_VERSION(feature1 ver1.2)
```
Будет сгенерирована ошибка конфигурирования Misconfiguration. Данный функционал задуман как объявление свойств именно для конкретных модулей и перекрытие свойства в нем самом не имеет смысла, поэтому считается ошибкой.

### CHECK_FEATURE_VERSION_CONFLICTS

Применяется только в паре с FEATURE_VERSION. Предназначен для проверки соответствия свойств всех подчиненных модулей текущему модулю.

#### Как использовать

Указать в ya.make проекта
```
CHECK_FEATURE_VERSION_CONFLICTS()
FEATURE_VERSION(feature1 ver1.1)
FEATURE_VERSION(feature2 ver2.5)
```
Это означает, что необходимо проверить все (прямые и транзитивные) зависимости текущего проекта на соответствие свойствам feature1 и feature2, они должны иметь строго такое же значение.

При несоответствии хотя бы одного из свойств настройкам проекта генерируется ошибка конфигурирования BadDep

#### Использование без FEATURE_VERSION

При использовании в ya.make проекта
```
CHECK_FEATURE_VERSION_CONFLICTS()
# Отсутствуют FEATURE_VERSION
```
Генерируется ошибка конфигурирования Misconfiguration, потому что проверять нечего и такая конфигурация не имеет смысла.


### REQUIRES

```
REQUIRES(Paths..)
```

Макрос контролирует, что среди всего набора зависимостей модуля (включая транзитивные), присутствуют заданные. `Paths...` указывает список директорий, в которых описана сборка модулей, наличие которых контролируется.

Макрос может быть нужен для дополнительного контроля в файлах для [`INCLUDE`](#include). Например, если файл описывает общую часть сборки некоторых плагинов к одной системе, то макрос `REQUIRES` может использоваться,
чтобы контролировать присутствие зависимости от общего модуля, фиксирующего интерфейс плагинов. Зависимость на такой модуль может быть у кода реализации (живущем, например, в `LIBRARY`), от которой в свою очередь зависит финальный модуль самого плагина (например, `DLL`).

{% cut  "To be documented" %}

{% note alert %}

Этот раздел пока не заполнен, но мы над этим работаем.

{% endnote %}

### Про .in-файлы и макросы подстановки переменных

```
CONFIGURE_FILE(File)
```

{% note alert %}

Этот раздел пока не заполнен, но мы над этим работаем.

{% endnote %}

{% endcut %}

## Управление сборкой мультимодуля

### EXCLUDE_TAGS
```EXCLUDE_TAGS(Tags)```

Вызов макроса `EXCLUDE_TAGS` позволяет отключить инстанциацию подмодулей МУЛЬТИМОДУЛЯ для указанных вариантов (тэгов, перечисленных в аргументах макроса). По умолчанию инстанциируются следующие варианты мультимодуля, кроме тех вариантов для которых свойство `.INCLUDE_TAG` имеет значение `no`.

## INCLUDE_TAGS
```INCLUDE_TAGS(Tags)```

Вызов макроса `INCLUDE_TAGS` позволяет добавить инстанциацию подмодулей мультимодуля для указанных вариантов (тэгов, перечисленных в аргументах макроса).

### ONLY_TAGS
```ONLY_TAGS(Tags)```

Вызов макроса `ONLY_TAGS` переопределяет набор инстанциаций подмодулей мультимодуля для указанных вариантов (тэгов, перечисленных в аргументах макроса).

