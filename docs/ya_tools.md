## Основные инструменты, предоставляемые пакетом ya.

Для просмотра применения инструмента следует воспользоваться командой `ya tool <subcommand> --ya-help`. 

Для просмотра доступных аргументов и ключей инструмента используйте `ya tool <subcommand> -h`.

**Инструменты:**
1. [atop](#Инструмент-atop)
2. [black](#Инструмент-black)
3. [buf](#Инструмент-buf)
4. [Компиляторы С и С++](#Компиляторы-С-и-С-+-+)
5. [c++filt](#Инструмент-c++filt)
6. [clang-format](#Инструмент-clang-format)
7. [clang-rename](#Инструмент-clang-rename)
8. [gcov](#Инструмент-gcov)
9. [gdb и gdbnew](#Инструменты-gdb-и-gdbnew)
10. [go](#Инструмент-go)
11. [gofmt](#Инструмент-gofmt)
12. [llvm-cov](#Инструмент-llvm-cov)
13. [llvm-profdata](#Инструмент-llvm-profdata)
14. [llvm-symbolizer](#Инструмент-llvm-symbolizer)
15. [nm](#Инструмент-nm)
16. [objcopy](#Инструмент-objcopy)
17. [strip](#Инструмент-strip)

### Инструмент atop
Инструмент `atop`, предназначен для мониторинга ресурсов и системных процессов в режиме реального времени. Предоставляет всесторонний обзор состояния системы, отображая информацию о процессоре, памяти, сети и дисковой активности.

#### Основные функции atop:
- **Отображение активных процессов:** По умолчанию `atop` показывает только те процессы, которые активно потребляют ресурсы, но с флагом `-a` может показать все процессы.
- **Мониторинг различных типов процессов:** С помощью управления флагами (`-g`, `-m`, `-d`, `-n`, `-s`, `-v`, `-c`, `-o`, `-u`, `-p`, `-j`) можно сконцентрироваться на определенных показателях процесса (общая информация, память, дисковая активность, сеть, планировщик задач, и т.д.).
- **Анализ пропорциональных сетов размерности (`PSS`):** Флаг `-R` позволяет рассчитать `PSS` для каждого процесса.
- **Вывод данных в различных форматах:** С флагом `-P` генерируется вывод в формате `JSON`, пригодном для дальнейшего парсинга.
- **Расширенные настройки отображения:** Флаги `-x`, `-L`, `-f`, `-F`, `-G`, `-l`, `-y`, `-1` позволяют тонко настроить отображение данных (например, включение/выключение цветов, установка фиксированной длины строки, и т.д.).
- **Сортировка процессов:** В зависимости от интересующего параметра можно сортировать процессы по потреблению `CPU` (`-C`), памяти (`-M`), дисковой активности (`-D`), сетевой активности (`-N`), активности `GPU` (`-E`) или по наибольшей активности ресурса в автоматическом режиме (`-A`).

#### Работа с сырыми лог-файлами:
- **Запись данных в лог-файл:** Флаг `-w` позволяет записывать сырые данные в файл для последующего анализа.
- **Чтение данных из лог-файла:** Флаг `-r` используется для чтения данных из ранее записанных логфайлов.
- **Автозавершение записи:** Флаг `-S` автоматически завершает запись до полуночи.
- **Фильтрация данных по времени:** С помощью флагов `-b` (начало) и `-e` (окончание) можно выбирать нужный интервал времени для отображения данных.

#### Интервалы и пробы:
- **Указание интервала времени:** Значение интервала задается в секундах и определяет, как часто будут обновляться данные (минимальное значение — 0 секунд).
- **Число проб:** Указывает количество интервалов, по которым будут собираться данные (минимальное значение — 1).

### Инструмент black
Инструмент `black` — это автоматический форматировщик кода для языка программирования `Python`, который жестко придерживается установленных стилей форматирования, обеспечивая определенное и неизменное оформление кода. Минимизирует количество изменений в форматировании при внесении правок в код.

#### Основные функциональные возможности и особенности:

1. Форматирование кода:
- Поддерживает передачу кода в виде строки или из файла, что позволяет легко встраивать его в CI/CD процессы или использовать напрямую из командной строки.

2. Поддержка различных версий `Python`:
- Адаптирует форматирование под множество версий Python (от py33 до py312), что делает его универсальным инструментом для проектов, использующих разные версии интерпретатора.

3. Стилизация длины строки:
- Максимальная длина строки задается пользователем (по умолчанию: 88 символов), что помогает поддерживать читабельный стиль кода.

4. Обработка специальных типов файлов:
- Форматирует файлы с аннотациями типов (`.pyi`) и Jupyter Notebooks (`.ipynb`), что полезно для проектов, включающих типизацию и анализ данных.

5. Настройка нормализации строк:
- Поддерживает настройку для пропуска нормализации строковых выражений и первой строки исходного кода, что удовлетворяет уникальным потребностям некоторых проектов.

6. Режимы проверки и анализа разницы (`diff`):
- Проверка позволяет анализировать, какие изменения будут внесены в файлы, без их записи.
- Вывод разницы (`diff`) отображает изменения, которые будут внесены, что полезно для предварительного анализа перед окончательной модификацией файлов.

7. Параллельное форматирование:
- Поддержка многопроцессорной обработки для ускорения форматирования большого числа файлов, что делает его эффективным инструментом для крупных проектов.

8. Исключение файлов и директорий:
- Возможность исключения определенных файлов и директорий по регулярным выражениям, что позволяет пользователю точно контролировать, какие файлы должны быть обработаны.

### Инструмент buf
Инструмент `buf` — это многофункциональная утилита для работы с файлами `Protobuf`, которая упрощает `linting`, генерацию кодовых заглушек и управление файлами `Protobuf` в проектах. 

#### Основные функциональные возможности и особенности:

1. `Linting` и проверка изменений:
- Команда `check` позволяет проводить `linting` и анализа на обнаружение изменений, способных вызвать сбои или непредвиденное поведение в `Protobuf` схемах. 

2. Генерация заглушек (`stubs`):
- Команда `generate` используется для генерации заглушек для плагинов `protoc` с использованием шаблонов. Это автоматизирует процесс генерации кода на основе `Protobuf` схем.

3. Работа с изображениями и наборами дескрипторов файлов:
- Команда `image` позволяет работать с изображениями и наборами дескрипторов файлов, что полезно для сложных схем и структур данных, представляемых в `Protobuf`.

4. Список файлов `Protobuf`:
- Команда `ls-files` отображает все файлы `Protobuf` для указанного местоположения ввода, что удобно для анализа и управления проектом.

5. Высокопроизводительная замена `protoc`:
- Команда `protoc` обеспечивает высокопроизводительную замену утилиты `protoc`, что ускоряет процессы компиляции и генерации кода на основе `Protobuf`.

#### Основные флаги (параметры):

- `–log-format string`: Формат вывода логов, доступные значения: `text`, `color`, `json`. По умолчанию используется color.
- `–log-level string`: Уровень логирования, доступные значения: `debug`, `info`, `warn`, `error`. По умолчанию используется `info`.
- `–timeout duration`: Длительность до тайм-аута. По умолчанию установлено 2 минуты (2m0s).

### Компиляторы С и С++
Инструменты предназначены для компиляции программ на языкач `C` и `C++`. 
Для языка программирования `C` используется основной компилятор `clang`, а для языка программирования `C++` - `clang++`.

### Основные возможности и функции

1. Компиляция и сборка кода:
- Предоставляют возможность компиляции исходного кода с генерацией объектных файлов и конечных исполняемых файлов.
- Поддержка компиляции как отдельных исходных файлов, так и нескольких файлов одновременно.

2. Параметры для компиляции:
- Поддержка множества опций и флагов для настройки процесса компиляции, таких как выбор стандарта, включение различных оптимизаций и обработка предупреждений и ошибок.
- Компилятор позволяет детально настраивать различные аспекты компиляции и сборки, используя параметры типа `-std=<value>`, `-O` для оптимизаций и многие другие.

3. Отладка и анализ:
- `clang` предоставляет возможности для генерации полной отладочной информации, что важно для разработки и отладки программ.
- Включение статического анализа кода для выявления возможных ошибок и уязвимостей (параметры `--analyze`, `--analyzer-output <value>`).

4. Поддержка различных архитектур:
- Компилятор поддерживает различные архитектуры и целевые платформы, что позволяет компилировать код для разных систем. Отдельные флаги, такие как `--target=<value> и `-march=<value>, позволяют выбрать конкретную архитектуру для компиляции.

5. Интеграция с `LLVM`:
- Использует внутренние инструменты `LLVM` для улучшения процесса оптимизации кода и генерации машинного кода.
- Возможность генерации промежуточного кода `LLVM` (параметры `-emit-llvm`).

6. Профилирование и покрытие кода:
- Инструменты для сбора и анализа данных о покрытии тестов и профилировании кода (флаги `--profile-use`, `--profile-generate`, `-ftime-report`).

7. Обработка ошибок и предупреждений:
- Компилятор поддерживает расширенные возможности для вывода и анализа ошибок и предупреждений, что позволяет разработчикам быстро выявлять проблемы в коде (параметры `-W<warning>, `-pedantic`).

Кроме перечисленных основных функций, компилятор предоставляет широкий спектр дополнительных возможностей.

### Инструмент c++filt
Инструмент предназначен для декодирования (деманглинга) закодированных имен (`mangled names`), которые появляются после компиляции программ на языках, таких как `C++`, где используются сложные правила именования. Такие закодированные имена часто сложно читаемы и непонятны для разработчиков, что делает анализ и отладку кода более сложными. `c++filt` преобразует такие имена обратно в удобочитаемый формат, облегчая понимание и анализ программного кода.

#### Возможности

Инструмент c++filt предлагает следующие возможности:

1. **Деманглинг имен:** Основная функция утилиты `c++filt` заключается в преобразовании закодированных (`mangled`) символов обратно в их оригинальные, удобочитаемые имена. 

2. **Поддержка различных форматов именования:** Несмотря на то, что в текущей реализации поддерживается только формат `gnu`, в будущем планируется добавление поддержки других форматов.

3. **Удаление ведущего подчеркивания:** По умолчанию, `c++filt` удаляет ведущие подчеркивания из закодированных имен. Это можно изменить с помощью опции `--no-strip-underscore`.

4. **Деманглинг типов:** Утилита `c++filt` также способна попытаться деманглить не только имена функций, но и типы данных, что делает ее более универсальной в анализе кода.

### Инструмент clang-format
Инструмент предназначен для автоматического форматирования кода на различных языках программирования, включая `C`, `C++`, `Java`, `JavaScript`,`JSON`, `Objective-C`, `Protobuf`.

#### Основные возможности и функции

1. Автоматическое форматирование кода:
- `clang-format` может форматировать исходные файлы кода или код, поступающий из стандартного ввода. Если файлы указаны, они могут быть отредактированы на месте (с опцией `-i`).

2. Опции для настройки форматирования:
- Предоставляет множество опций для настройки стиля кодирования. Стиль можно задать через предустановленные схемы, файл `.clang-format` или напрямую указав параметры.

3. Поддержка различных языков:
   - Автоматически определяет язык исходного файла по его расширению. Также можно указать язык явно с помощью опции `--assume-filename`.

4. Парное форматирование участков кода:
   - Можно форматировать только определённые участки кода, задав параметры `--offset` и `--length` или `--line`s.
  
5. Включение отладочных сообщений и вывода информации:
   - Опция `--verbose` выводит список обрабатываемых файлов.
   - Опция `--dump-config` выводит текущие настройки форматирования.

6. Дополнительные функции:
   - Опция `--sort-includes` позволяет сортировать директивы `#include`.
   - Опция `--output-replacements-xml` выводит замены в формате `XML`.
  
### Инструмент clang-rename
`clang-rename` — это утилита, предназначенная для автоматизации процесса переименования символов в коде, написанном на языках, поддерживаемых компилятором `Clang`, таких как `C` и `C++`. 

Основная цель этого инструмента — упростить задачу рефакторинга, особенно в больших кодовых базах, где ручное переименование может быть трудоёмким и подверженным ошибкам.

#### Возможности

1. Переименование символов:
`clang-rename` позволяет переименовывать символы (переменные, функции, классы и т.д.) в исходном коде. Пользователь указывает новое имя символа, который необходимо переименовать, и утилита выполняет замену в коде.

2. Работа с квалифицированными именами:
Утилита поддерживает работу с полностью квалифицированными именами символов с помощью опции `--qualified-name=<string>`,что помогает точно указывать символы, которые нужно переименовать, особенно когда имена могут быть неоднозначны.

3. Работа с файлами конфигураций:
Файлы `YAML` могут использоваться для хранения пар старое_имя-новое_имя. Это позволяет загружать большой перечень символов для переименования через опцию `--input=<string>`.

4. Гибкость командной строки:
`clang-rename` поддерживает различные дополнительные аргументы командной строки для передачи дополнительных параметров компилятору (`--extra-arg=<string>`, `--extra-arg-before=<string` а также для указания каталога сборки (`-p <string>`).

5. Экспорт предложенных исправлений:
Утилита может экспортировать предложенные исправления в файл `YAML` с помощью опции `--export-fixes=<filename>`. Это позволяет сохранять и позже применять исправления.

6. Печать информации:
`clang-rename` может выводить в стандартный поток ошибок (`stderr`) информацию о затронутых переименованием местоположениях (`--pl`) и о найденном имени символа до переименования (`--pn`).

7. Переименование по смещению:
Помимо использования координат в виде строки и столбца, утилита поддерживает переименование символов по смещению байтов в файле (`--offset=<uint>`).

8. Принудительное переименование:
Опция `--force` позволяет игнорировать ошибки, связанные с несуществующими именами.

9. Перезапись файлов:
Использование флага `-i` позволяет утилите перезаписывать изменённые файлы на месте, что упрощает взаимодействие с системами сборки и CI/CD.

### Инструмент gcov
`gcov` — инструмент для анализа покрытия кода, который помогает разработчикам понять, какие части их исходного кода были исполнены во время выполнения тестов.

#### Возможности

1. Анализ базовых блоков:
Флаг `-a` позволяет отображать покрытие всех базовых блоков в программе. 

2. Отображение вероятностей ветвления:
С помощью опции `-b` инструмент может показывать вероятности ветвления.

3. Подсчет ветвей:
Вместо отображения процентов выполнения ветвей, опция `-c` (вместе с `-b`) позволяет отображать точные числа о том, сколько раз определенные ветви были выполнены.

4. Деманглирование имен функций:
Опция `--demangled-names` позволяет преобразовывать закодированные имена функций в более удобочитаемый формат.

5. Покрытие на уровне функций:
С опцией `-f` инструмент показывает покрытие для каждой функции в исходном коде.

6. Поддержка промежуточного формата:
`gcov` может выводить данные в промежуточном текстовом формате, используя опцию `--intermediate-format`.

7. Работа с путями и префиксами файлов:
Опция `-l` добавляет имена файлов с префиксом основного файла. Дополнительно, опция `-p` сохраняет компоненты пути, а `-s <string>` позволяет исключить указанный префикс пути из выходных данных.

8. Вывод на стандартный вывод:
С опцией `-t` можно вывести результаты анализа покрытия кода непосредственно в стандартный вывод (`stdout`), что облегчает быструю проверку результатов.

9. Информация о безусловных ветвях:
Опция `-u` отображает информацию о безусловных ветвях.

10. Упрощение длинных путей:
С помощью опции `-x`, инструмент может хешировать длинные пути, что делает работу с большими проектами удобнее.

11. Внутренние и отладочные опции:
`gcov` также предлагает ряд отладочных опций, таких как `--dump`, которая выводит содержимое файла в `stderr`, и `--gcda` и `--gcno`, которые позволяют задать файлы данных покрытия вручную.

### Инструменты gdb и gdbnew

`gdb` (`GNU Debugger`) инструмент для отладки программ, позволяет исследовать состояние программ во время их выполнения, находить и исправлять ошибки.

`gdbnew` —  утилита, являющаяся версией `GNU Debugger (GDB)`, предназначенной для использования на операционных системах `Ubuntu 16.04` и более поздних версиях.

Предоставляет все те же возможности для отладки, что и классический `gdb`, но с учетом особенностей и обновлений, доступных в более новых версиях `Ubuntu`.

#### Возможности

1. Выбор программы и файлов для отладки:
- `--args` позволяет передавать аргументы для отлаживаемой программы.
- `--core=COREFILE` используется для анализа дампа памяти (`core dump`).
- `--exec=EXECFILE` задает исполняемый файл для отладки.
- `--pid=PID` позволяет прикрепиться к уже запущенному процессу.
- `--directory=DIR` задает директорию для поиска исходных файлов.
- `--symbols=SYMFILE` загружает символы отладки из указанного файла.

2. Базовые команды:
- `--command=FILE` или `-x` выполняет команды из указанного файла.
- `--init-command=FILE` или `-ix` выполняет команды до загрузки программы.
- `--eval-command=COMMAND` или `-ex` выполняет одну команду `gdb`.
- `--init-eval-command=COMMAND` или `-iex` выполняет одну команду до загрузки программы.
- `--nh` пропускает чтение файла `~/.gdbinit`.
- `--nx` пропускает чтение всех файлов `.gdbinit`.

3. Управление выводом и интерфейсом пользователя:
- `--fullname` выводит информацию, используемую интерфейсом `emacs-GDB`.
- `--interpreter=INTERP` выбирает определенный интерпретатор/интерфейс пользователя.
- `--tty=TTY` задает `tty` для ввода/вывода программы.
- `-w` включает графический интерфейс (`GUI`).
- `--nw` отключает графический интерфейс.
- `--tui` включает текстовый интерфейс (`TUI`).
- `-q`, `--quiet`, `--silent` отключает вывод номера версии при запуске.

4. Режимы работы:
- `--batch` завершает работу после обработки командной строки.
- `--batch-silent` как `--batch`, но подавляет вывод информации.
- `--return-child-result` завершение `gdb` с кодом завершения отлаживаемой программы.
- `--configuration` выводит информацию о конфигурации `gdb` и завершает работу.

5. Удаленная отладка:
- `-b BAUDRATE` задает скорость передачи данных по последовательному порту для удаленной отладки.
- `-l TIMEOUT` задает таймаут в секундах для удаленной отладки.

6. Прочие опции:
- `--cd=DIR` меняет текущую директорию на указанную.
- `--data-directory=DIR`, `-D` задает директорию данных `gdb`.

### Инструмент go
`go` применяется для управления исходным кодом на языке программирования `Go` и предоставляет широкий набор команд для компиляции, тестирования, форматирования, установки и поддержания `Go`-проектов и их зависимостей. 

#### Основные команды

1. Общие команды:
- `bug` — запуск отчета об ошибке.
- `version` — вывод текущей версии `Go`.
- `env` — вывод информации о среде выполнения `Go`.

2. Команды для работы с кодом:
- `build` — компиляция пакетов и их зависимостей.
- `clean` — удаление объектных файлов и файлов кэша.
- `doc` — отображение документации для пакета или символа.
- `fix` — обновление пакетов для использования новых `API`.
- `fmt` — форматирование исходного кода `Go` (использует утилиту `gofmt`).
- `generate` — генерация файлов `Go` путем обработки исходного кода.
- `run` — компиляция и выполнение программы `Go`.
- `install` — компиляция и установка пакетов и их зависимостей.
- `list` — вывод списка пакетов или модулей.
- `mod` — управление модулями.
- `work` — управление рабочим пространством.
- `get` — добавление зависимостей в текущий модуль и их установка.
- `test` — тестирование пакетов.
- `tool` — запуск указанного инструмента `Go`.
- `vet` — обнаружение вероятных ошибок в коде.

#### Дополнительные параметры

- `buildconstraint` — управление ограничениями сборки.
- `buildmode` — режимы сборки.
- `c` — вызовы между `Go` и `C`.
- `cache` — кэширование сборок и тестов.
- `environment` — переменные окружения `Go`.
- `filetype` — типы файлов.
- `go.mod` — файл go.mod.
- `gopath` — переменная окружения GOPATH.
- `goproxy` — протокол прокси модулей.
- `importpath` — синтаксис путей импорта.
- `modules` — модули, версии модулей и прочее.
- `module-auth` — аутентификация модулей с использованием `go.sum`.
- `packages` — списки пакетов и шаблоны.
- `private` — конфигурация для скачивания приватного кода.
- `testflag` — флаги тестирования.
- `testfunc` — функции тестирования.
- `vcs` — управление версиями при помощи `GOVCS`.

### Инструмент gofmt
`gofmt` — это инструмент для форматирования исходного кода на языке `Go`. Приводит исходный код к единому стилю форматирования.

#### Возможности

1. Форматирование кода:
Основная функция `gofmt` — автоматическое форматирование исходного кода `Go` в соответствии с правилами.

2. Вывод на стандартный вывод или запись в файл:
По умолчанию, `gofmt` выводит отформатированный код на стандартный вывод (`stdout`). Использование флага `-w` позволяет перезаписать исходные файлы результатом форматирования.

3. Отображение различий:
Флаг `-d` заставляет `gofmt` отображать различия между оригинальным и отформатированным кодом, вместо непосредственного перезаписывания файлов.

4. Список файлов с неправильным форматированием:
С помощью флага `-l` отслеживаются файлы, стиль форматирования которых отличается от принятого `gofmt`.

5. Упрощение кода:
Флаг `-s` упрощает код, применяя стандартные оптимизации и упрощения, что делает код более читаемым и компактным.

6. Сообщение об ошибках:
Флаг `-e` позволяет `gofmt` сообщать обо всех ошибках форматирования, тогда как по умолчанию выводятся только первые десять.

7. Переписывание кода по правилам:
Флаг `-r` <правило> позволяет задавать правила преобразования кода.

8. Профилирование производительности:
Флаг `-cpuprofile` <файл> позволяет записывать профиль производительности `CPU` в указанный файл.

### Инструмент llvm-cov
`llvm-cov` — это инструмент из экосистемы `LLVM`, предназначенный для анализа покрытия кода. Он предоставляет разработчикам возможность видеть, какие части их кода были выполнены, а какие остались не протестированными. 

#### Подкоманды
1. **export**: Экспортирует файл профилей (`instrprof`) в структурированный формат.
2. **gcov**: Работа с форматом `gcov`. Эта подкоманда совместима с инструментами, использующими форматы покрытия `GCC`.
3. **report**: Обобщает информацию о покрытии, используя стиль покрытия `instrprof`.
4. **show**: Аннотирует исходные файлы, используя стиль покрытия `instrprof`. Позволяет визуально проверить, какие части исходного кода были выполнены.
   
Настройки и опции для каждой из этих подкоманд могут варьироваться в зависимости от конкретных требований к анализу и используемых инструментов и файлов.

### Инструмент llvm-profdata
`llvm-profdata` — это набор инструментов для работы с профильными данными, используемый в экосистеме `LLVM`. Предназначен для обработки и анализа данных профилирования, которые генерируются в процессе выполнения программ.

#### Возможности

llvm-profdata поддерживает несколько команд, каждая из которых предоставляется для различных аспектов работы с профильными данными:

1. **merge**:
-  Объединение нескольких файлов профильных данных. 
- Генерация агрегированного профиля, который можно использовать для оптимизации компилятора.

2. **show**:
- Вывод подробной информации о содержимом файлов профиля.
- Анализ статистики использования кода, такой как количество вызовов функций, частота исполнения и т.д.

3. **overlap**:
- Сравнение профилей для определения сходства в поведении программ.
- Оценка, насколько данные профилеры совпадают или различаются, что помогает в анализе изменений производительности между разными версиями программы.

### Инструмент llvm-symbolizer
Инструмент ёllvm-symbolizerё предназначен для преобразования адресов в человеко-читаемые символы и линии исходного кода.

#### Возможности
- **Печать адресов**: Опция `--addresse`s позволяет отображать адреса перед информацией о строке кода.
- **Корректировка адресов**: Опция `--adjust-vma=<offset>` добавляет указанный смещение к адресам в объектном файле.
- **Сокращение путей**: С помощью опции `--basenames` можно удалять имена директорий из путей, оставляя только имена файлов.
- **Работа с Build ID**: Опция `--build-id=<value>` позволяет использовать `Build ID` для поиска нужного объектного файла.
- **Кэширование**: Опция `--cache-size=<value>` позволяет задавать максимальный размер кэша для бинарных файлов в памяти, улучшая производительность при символизации больших объемов данных.
- **Поддержка цвета**: Опции `--color` и `--color=<value>` включают использование цветов в метках логов, что улучшает читаемость вывода.
- **Деманглирование**: Опция `--demangle` позволяет преобразовывать закодированные имена функций в удобочитаемый вид, что особенно полезно для языков, таких как `C++`.
- **Обработка встроенных функций**: С помощью опции `--inlines` можно отображать все встроенные кадры для заданного адреса, что облегчает понимание контекста выполнения.
- **Печать функций**: Опция `--functions` позволяет выводить имена функций, которым принадлежат заданные адреса.
- **Определение стиля вывода**: Опция `--output-style=<style>` позволяет выбирать стиль вывода из поддерживаемых стилей, таких как `LLVM`, `GNU` или `JSON`.
- **Контекст исходного кода**: Опция `--print-source-context-lines=<value>` позволяет выводить определенное количество строк исходного кода вокруг символизируемого адреса для лучшего понимания контекста.
- **Альтернативное имя файла**: С помощью опции `--obj=<file>` можно указывать путь к объектному файлу, который будет использован для символизации.

`llvm-symbolizer` также поддерживает специфические для `Mach-O` опции, такие как `--default-arch=<value>` и `--dsym-hint=<dir>`, что делает его универсальным инструментом для множества различных систем и форматов файлов.

### Инструмент nm
Утилита `nm` предназначена для отображения символов из объектных файлов. С её помощью можно изучить содержимое таблицы символов бинарных файлов, включая объектные файлы, библиотеки и исполняемые файлы.

#### Возможности

1. Отображение символов:  
По умолчанию `nm` показывает таблицу символов для заданного файла. Символы могут включать различные виды, такие как глобальные, локальные, внешние и неопределенные символы.

2. Форматирование вывода:  
Поддерживает различные форматы вывода через опцию `--format` (сокращённо `-f`). Доступные форматы: `bsd`, `posix`, `sysv`, `darwin` и `just-symbols`.

3. Фильтрация символов:  
Возможность отображения только определённых типов символов с помощью опций:
   - `--defined-only` (`-U`): показывает только определённые символы.
   - `--undefined-only` (`-u`): показывает только неопределённые символы.
   - `--extern-only` (`-g`): показывает только внешние символы.
   - `--no-weak` (`-W`): показывает только не-weak символы.
   - `--dynamic` (`-D`): показывает динамические символы вместо обычных.

4. Деманглинг:
Опция `--demangle` (`-C`) для преобразования закодированных символов в удобочитаемый формат (чаще всего применяется для символьных имен `C++`).

5. Производительность анализа:
Может выводить дополнительную информацию, такую как размер символов (`--print-size`, `-S`) и исходный файл символов (`--print-file-name`, `-o`, `-A`).

6. Сортировка символов:
Символы могут быть отсортированы различными способами:
   - По адресу (`--numeric-sort`, `-n`, `-v`).
   - В обратном порядке (`--reverse-sort`, `-r`).
   - По размеру (`--size-sort`).

7. Дополнительные возможности:
- Экспорт списка символов для всех входных файлов (опция `--export-symbols`).
- Возможность печати карты архива (опция `--print-armap`).
- Управление отображением символов, например, с использованием специального формата для `Mach-O` и `XCOFF` файлов.

### Инструмент objcopy
Инструмент `objcopy` служит для манипуляций с объектными файлами разных форматов. Он позволяет редактировать, удалять и преобразовывать секции и символы в объектных файлах, а также изменять их формат.
#### Возможности
objcopy предоставляет следующие основные возможности:
- Добавление и удаление секций:
   - Опция `--add-section=section=file` позволяет добавить новую секцию с содержимым из указанного файла.
   - Опция `--remove-section=section` позволяет удалить указанную секцию.

- Работа с символами:
   - Опция `--add-symbol=name=[section:]value[,flags]` добавляет новый символ в таблицу символов .symtab.
   - Опция `--globalize-symbol=symbol` делает символ глобальным.
   - Опция `--strip-symbol=symbol` удаляет указанный символ.
   - Опция `--weaken-symbol=symbol` делает символ слабым.
   - Опция `--keep-symbol=symbol` сохраняет указанный символ, предотвращая его удаление.

- Преобразование и редактирование символов:
   - Опция `--redefine-sym=old=new` изменяет имя символа с `old` на `new``.
   - Опция `--prefix-symbols=prefix` добавляет префикс ко всем именам символов.
   - Опция `--localize-symbol=symbol` делает символ локальным.

- Управление форматами и секциями:
   - Опция `--compress-debug-sections=format` сжимает отладочные секции используя указанный формат (например, `zlib` или `zstd`).
   - Опция `--decompress-debug-sections` декомпрессирует отладочные секции.
   - Опции `--input-target=<value>` и `--output-target=<value>` задают формат входного и выходного файлов.

- Изменение свойств секций:
   - Опция `--set-section-alignment=section=align` устанавливает выравнивание для секции.
   - Опция `--set-section-flags=section=flag1[,flag2,...]` устанавливает флаги для секций.

- Работа с отладочными данными:
   - Опция `--only-keep-debug` создает файл, который сохраняет только секции, полезные для отладки.

- Оптимизация и устранение ненужных данных:
   - Опция `--strip-all` удаляет все неиспользуемые секции за пределами сегментов.
   - Опция `--strip-debug` удаляет все отладочные секции.
   - Опция `--strip-unneeded` удаляет все символы, не нужные для релокаций.

- Работа с форматами архивов:
   - Опция `--enable-deterministic-archives` и `--disable-deterministic-archives` управляют режимом детерминирования при работе с архивами, что позволяет использовать или игнорировать реальные значения `UID`, `GID` и метки времени.

- Изменение начальных адресов:
   - Опция `--change-start=incr` добавляет указанное значение к начальному адресу.

### Инструмент strip
Инструмент `strip` предназначен для сокращения размера объектных файлов и исполняемых файлов за счет удаления ненужных секций и символов. 

#### Возможности
`strip` предоставляет следующие основные возможности:
- Удаление символов:
   - Опция `--discard-all` удаляет все локальные символы, кроме символов файлов и секций, также удаляются все отладочные секции.
   - Опция `--discard-locals` удаляет локальные символы, сгенерированные компилятором (например, символы, начинающиеся с `.L`).
   - Опция `--strip-symbol=symbol` удаляет указанный символ.
   - Опция `--strip-unneeded` удаляет все символы, не нужные для релокаций.
   - Опция `--strip-all` удаляет все не распределенные секции, находящиеся вне сегментов. Секции типа `.gnu.warning*` и `.ARM.attribute` не удаляются.

- Сохранение специфических символов и секций:
   - Опция `--keep-symbol=symbol` сохраняет указанный символ, предотвращая его удаление.
   - Опция `--keep-section=section` сохраняет указанную секцию.
   - Опция `--keep-file-symbols` предотвращает удаление символов файлов.
   - Опция `--keep-undefined` предотвращает удаление неопределенных символов.

- Работа с отладочными секциями:
   - Опция `--strip-debug` удаляет все отладочные секции.
   - Опция `--only-keep-debug` создает файл, который сохраняет только секции, полезные для отладки.

- Управление форматами архивов:
   - Опция `--enable-deterministic-archives` включает детерминистский режим при работе с архивами (используются нули для `UID`, `GID` и меток времени).
   - Опция `--disable-deterministic-archives` отключает детерминистский режим при работе с архивами (используются реальные значения `UID`, `GID` и меток времени).

- Удаление секций:
   - Опция `--remove-section=section` удаляет указанную секцию.
   - Опция `--strip-sections` удаляет все заголовки секций и все секции, не находящиеся в сегментах.

- Сохраниение меток времени:
   - Опция `--preserve-dates` сохраняет метки времени доступа и модификации.

- Работа с регулярными выражениями и масками:
   - Опция `--regex` разрешает использование регулярных выражений при сравнении имен.
   - Опция `--wildcard` разрешает использование масок для символов. Например, `*` для соответствия любому количеству символов, `?` для соответствия одному символу, и `[]` для определения классов символов.

- Специфические возможности:
   - Опция `-T` удаляет символы `Swift`.
   - Опция `--version` выводит версию инструмента и завершает выполнение.
