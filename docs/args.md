## Типы и виды параметров

Параметры в ya.make бывают всего трёх типов: строки, списки строк и булевы (по признаку наличия, см. ниже).

Параметры в ya.make бывают *именованные* и *неименованные*.

**Неименованные параметры** участвуют в вызове своим значением, они бывают:

- **Скалярные** — значением параметра является строка (одно слово). Иногда такой параметр может быть опциональным. Например, имя модуля 
   (параметр макроса заголовка модуля) — это обычно опциональный скалярный параметр.  Если таких параметров несколько, они принимают свои
   значения в соответствии с позицией

  - В документации обычно параметр описывается как `<значение>` (обязательный) или `[<значение>]` опциональный. Иногда угловые скобки опущены для читаемости.
    Важно, что слово, обозначающее значение, в таком случае одно и оно не целиком заглавными буквами.

  __Примеры:__
  ```
  ### @usage: PY_NAMESPACE(<name.space>)
  PY_NAMESPACE(my.namespace)
  .
  ### @usage: KV(<Key> <Value>)
  KV(the_key, the_value) # Key=the_key, Value=the_value
  ```

- **Свободно-списочные** — значением параметра является список всех строк (слов), не отнесённых ни к какому другому параметру. Если таких не находится, список остаётся пустым.
  - В документации такой параметр описывается как `Значение...`. 

  __Примеры:__
  ```
  ### @usage: ALL_SRCS([GLOBAL] Filenames...)
  .
  ALL_SRCS(x.cpp GLOBAL y.cpp)       # Filenames=x.cpp y.cpp, GLOBAL=True
  .
  ### @usage: SRC(<File>, Flags...)
  SRCS(x.cpp -Wno-error -std=c++17)  # Flags=-Wno-error -std=c++17
  SRCS(y.cpp)                        # Flags=<empty>
  ```

**Именованные параметры** участвуют в вызове своим именем и, возможно, значением. Исторически для именования параметров макросов, как и самих макросов, используется
(SCREAMING_SNAKE_CASE)[https://ru.wikipedia.org/wiki/Snake_case].

Именованные параметры бывают:

- **Булевы** — значение параметра определяется в описании самого макроса, а в вызове различается факт присутствия параметра в списке (*истина*) или отсутствия (*ложь*).
  - В документации такой параметр описывается как `[PARM_NAME]`. Важно, что в данном случае имя параметра написано целиком большими буквами и без угловых скобок.

  __Пример:__
  ```
  ### @usage: ALL_SRCS([GLOBAL] Filenames...)
  .
  ALL_SRCS(GLOBAL x.cpp y.cpp)  # GLOBAL is True
  ALL_SRCS(a.cpp b.cpp)         # GLOBAL is False
  ```

- **Скалярные** — значением параметра является строка (слово), идущее в вызове сразу после имени параметра. Такой параметр может быть *опциональным*, если он не указан,
  то параметр получит значение по умолчанию.
  - В документации такой параметр выглядит как `NAME <value>` или `[NAME <value>]`. Имя параметра целиком большими буквами, а значение — одно слово в угловых скобках.

  __Примеры:__
  ```
  ### @usage: COMPILE_LUA(Src, [NAME <import_name>])
  .
  COMPILE_LUA(func.lua NAME my.func)  # NAME=my.func
  COMPILE_LUA(the_func.lua)           # NAME=<default>
  ```

- **Списочные** — значением параметра является список строк (слов), идущих после имени параметра и до следующего имени параметра или закрывающей скобки.
  Имя параметра может встречаться в строке несколько раз, давая в результате конкатенацию всех списков. Если имя параметра не встречается, список остаётся пустым.
  - В документации такой параметр выглядит как `NAME <list of values>` или `[NAME <list of values>]`. Имя параметра целиком большими буквами, а
    значение — несколько слов в угловых скобках. 

  __Пример:__
  ```  
  ### @usage: FROM_ARCHIVE(Src [RENAME <resource files>] OUT <output files> [PREFIX <prefix>] [EXECUTABLE])
  # Src    - обязательный неименованный скалярный
  # RENAME - опциональный именованный списочный
  # OUT    - обязательный именованный списочный
  # PREFIX - опциональный именованный скалярный
  # EXECUTABLE - булев
  .
  FROM_ARCHIVE(
      resource.tar.gz
      PREFIX y
      RENAME y/a.txt OUT y/1.txt
      RENAME y/b/c.txt OUT y/2.txt
      RENAME RESOURCE OUT 3.tar.gz
      OUT y/d.txt
  )
  # Src=resource.tar.gz 
  # PREFIX=y
  # RENAME=y/a.txt y/b/c.txt RESOURCE  ## RESOURCE в данном случае значение, а не имя параметра
  # OUT=y/1.txt y/2.txt 3.tar.gz y/d.txt
  ```
