## Канонизация тестов

Канонизация — это процесс определения и фиксации эталонных (канонических) данных для тестов, которые впоследствии будут использоваться для сравнения с текущими результатами тестов. Это позволяет убедиться, что результаты выполнения тестов остаются стабильными и совпадают с ожидаемыми результатами, тем самым обеспечивает сохранение качества и корректности программного обеспечения.

Процесс канонизации включает следующие шаги:

1. Первичный запуск и сохранение данных:
- Первичная канонизация: При первом запуске теста его результаты сохраняются в качестве эталонных данных (канонических данных). Эти данные будут использоваться для всех последующих сравнений.
- Фиксация канонических данных: Эти результаты фиксируются и сохраняются в определенном формате и расположении, чтобы они могли быть легко доступны для последующих сравнений. Обычно они сохраняются в директорию `canondata/<test name>/result.json`.

2. Сравнение с эталонными данными:
- Регулярные запуски тестов: При каждом новом запуске тестов результаты текущего выполнения сравниваются с эталонными данными, сохраненными в ходе первичной канонизации.
- Обработка отклонений: Если результаты текущего теста отклоняются от эталонных данных, система сигнализирует об этом и предоставляет отчет о различиях.

3. Актуализация канонических данных:
- Обновление эталонов: При изменении в коде или данных, эталонные результаты могут быть обновлены для отражения новых изменений. Этот процесс называется переканонизацией.

### Основные компоненты системы канонизации

- Фреймворки тестирования: Поддержка канонизации предоставляется большинством фреймворков тестирования для различных языков программирования. Каждый фреймворк для написания тестов предоставляет свою поддержку механизма канонизации, описанную в соответствующих разделах.
- Хранение данных: Канонические данные управляются системой и хранятся в определенных директориях.
- Инструменты сравнения: Для проверки соответствия результатов тестов используются стандартные и кастомные инструменты сравнения (diff tools).

### Ограничения и особенности

- Поддержка языков: Канонизация поддерживается для множества языков программирования, за исключением C++, для которого не предусмотрена нативная канонизация (предоставлены альтернативные способы).
- Хранение данных: Не рекомендуется вручную изменять данные внутри директории canondata. Все изменения должны выполняться через систему канонизации.
- Для тестов на стороне `ya` канонические данные находятся в доступе при помощи команды `ya make`.

### Как включить канонизацию

Для включения канонизации тестов используется опция `-Z` или `--canonize-tests`. В этом режиме вместо сравнения результатов теста с эталонными данными, система сохранит текущие результаты как новые эталонные данные.
```
  ya make -tF <test name> --canonize-tests --local
```
Если необходимо обновить эталонные данные (например, изменён тест или его логика), запуск с опцией `-Z` сохранит новые эталонные данные вместо старых. 
```
ya make -AZ  --local
```
Не изменяйте канонические данные вручную. Это может привести к некорректному функционированию тестов, так как система сравнивает контрольные суммы файлов, и любые ручные изменения не будут учтены.

Иногда при переканонизации могут возникать ошибки (например, проблемы с кэшем). В таких случаях необходимо очищать кэш и повторно запускать тест.
```
ya gc cache --size-limit 0
```
### Просмотр ретроспективы канонического результата теста

Ретроспектива канонического результата теста позволяет отслеживать изменения канонических данных во времени. Это полезно для анализа, как и почему изменялись результаты тестов, а также для отладки проблем, связанных с канонизацией. 

Для просмотра ретроспективы канонического результата теста, нужно использовать режим `--canon-diff`. Запуск команды осуществляется через `ya make` с указанием соответствующих параметров:
```
ya make -t --canon-diff PREV
```
#### Аргументы для режима --canon-diff

- PREV: Сравнивает канонические данные теста с предыдущей ревизией.
- HEAD: Смотрит на текущую ревизию кода.
- <rev1>:<rev2>: Сравнивает канонические данные между двумя указанными ревизиями, где <rev1> и <rev2> — это идентификаторы ревизий.

Можно передать имя теста через параметр -F(--test-filter), для этого можно сначала вывести список тестов в текущей папке.
```
project/ya make -t --canon-diff HEAD -L
```
### Скачивание канонических данных из разных хранилищ

Чтобы результаты канонизации могли быть переиспользованы разными backend-ами, при канонизации тестов можно указать параметр `--canonization-backend`. Это значит, что ссылки на ресурсы будут шаблонизированы и смогут резолвиться в разные backend-ы в зависимости от условий запуска тестов.

#### Параметризация backend

При запуске тестов с использованием канонических данных, можно задать свой собственный backend. Это делает систему гибкой и адаптивной к разным условиям запуска.

**Пример команды для запуска тестов с указанием кастомного backend:**
```
ya make -tF <test name> -Z --canonization-backend="<my.custom.backend>"
```

#### Параметризация протокола

Помимо указания кастомного backend-а, вы также можете выбрать протокол для скачивания канонических данных. По умолчанию используется `https`, но это может быть изменено с помощью опции `--canonization-scheme`.
```
ya make -tF <test name> -Z --canonization-backend="<my.custom.backend>" --canonization-scheme="http"
```

### Формат результата канонизации

Результаты канонизации сохраняются в формате JSON и могут включать ссылки на файлы. 

После выполнения канонизации рядом с тестом создается файл `canondata/result.json`, содержащий ссылки на расположение загруженных канонических данных. При использовании параметра `--canonization-backend`, ссылки будут содержать шаблон для подстановки нужного backend’а вместо его явного указания.

**Пример**
```
"uri": "https://{canondata_backend}/1809005/61174eb05585f2f1c67e0387c436e184f0ccc131/resource.tar.gz#exectest.run_hello_world0_/stdout.out"
```

Рассмотри подробнее формат uri:
- схема - https
- бэкенд - {canondata_backend}
- путь до архива  - 1809005/61174eb05585f2f1c67e0387c436e184f0ccc131/resource.tar.gz
- путь до файла внутри архива - exectest.run_hello_world0_/stdout.out

### Поддержка канонизации для языков

Каждый фреймворк для написания тестов предоставляет свою поддержку механизма канонизации. Канонизация поддержана для всех языков, кроме C++.

#### Канонизация в C++

На данный момент нативная канонизация в C++ тестах не поддерживается. Есть несколько альтернативных способов канонизировать тесты на C++:

##### Матчер в gtest

Модуль `GTEST` предоставляет `NGTest::GoldenFileEq(filename)`, который умеет сравнивать тестируемые данные с содержимым указанного файла и обновлять его при запуске теста с аргументом `--test-param GTEST_UPDATE_GOLDEN=1`.
```
TEST(Suite, Name) {
    std::string data = RenderSomeTextData();
    EXPECT_THAT(data, NGTest::GoldenFileEq(SRC_("golden/data.txt")));
}
```
Данный способ не рекомендуется использовать для тестирования бинарных данных. 

##### Дополнительный EXECTEST

Можно канонизировать вывод тестов или выходные файлы с помощью отдельного `ya.make` с [`EXECTEST()`](test_exec.md), который будет зависеть от теста и запускать указанные тесты вручную.

#### Канонизация в Python

Канонизация в Python позволяет разработчикам фиксировать ожидаемые результаты тестов, которые будут использованы для сравнения с реальными результатами при последующих запусках тестов. 

##### Канонизация объектов

Для канонизации объектов в тестовых функциях необходимо просто вернуть значения, которые должны быть проверены. Поддерживаются все простые типы данных (числа, строки, булевы значения), списки и словари.

Пример:
```
def test():
    return [1, 2.0, True]
```
В этом примере, тестовая функция возвращает список с различными типами данных. Эти значения будут сохранены и использованы для сравнения с результатами последующих запусков теста.

##### Канонизация файлов

Иногда тестовые функции должны проверить содержимое файлов. Для этого используется функция `yatest.common.canonical_file`.

##### Параметры функции canonical_file

```
yatest.common.canonical_file(path, diff_tool=None, local=False, universal_lines=False, diff_file_name=None, diff_tool_timeout=None)
```
Описание параметров:
- path: Путь до файла, который будет канонизироваться.
- diff_tool: Путь к программе для сравнения канонических файлов. По умолчанию используется diff. Можно указать нестандартные программы для сравнения файлов.
- local: Если True, файл будет сохранен в локальный репозиторий.
- universal_lines: Нормализует окончания строк (EOL).
- diff_file_name: Название файла с различиями (diff). По умолчанию имя файла <имя сравниваемого файла>.diff.
- diff_tool_timeout: Тайм-аут для выполнения программы сравнения.

**Пример**
```
def test1():
    return [yatest.common.canonical_file(output_path1), yatest.common.canonical_file(output_path2)]
def test2():
    return {
        "path1_description": yatest.common.canonical_file(output_path1),
        "path2_description": yatest.common.canonical_file(output_path2)
    }
```

Этот пример показывает, как канонизировать несколько файлов. Варианты возвращаемого значения могут быть не только списком, но и словарем для более удобного описания файлов.

##### Канонизация директорий

Для канонизации содержимого директорий используется функция `yatest.common.canonical_dir`.

##### Параметры функции canonical_dir
```
yatest.common.canonical_dir(path, diff_tool=None, diff_file_name=None, diff_tool_timeout=None)
```

Описание параметров:
- path: Путь до директории, содержимое которой будет канонизироваться.
- diff_tool: Путь к программе для сравнения канонических файлов. По умолчанию используется diff.
- diff_file_name: Название файла с различиями (diff). По умолчанию имя директории <имя сравниваемой директории>.diff.
- diff_tool_timeout: Тайм-аут для выполнения программы сравнения.

#### Канонизация запуска программ

Для канонизации вывода программ используется функция `yatest.common.canonical_execute`.

#### Параметры функции canonical_execute
```
yatest.common.canonical_execute(binary, args=None, check_exit_code=True, shell=False, timeout=None, cwd=None, env=None, stdin=None, stderr=None, creationflags=0, file_name=None, save_locally=False)
```
Описание параметров:
- binary: Абсолютный путь к исполняемому файлу.
- args: Аргументы командной строки для запуска программы.
- check_exit_code: Если True, выбрасывает исключение ExecutionError, если программа завершается с ошибкой.
- shell: Если True, использовать оболочку для запуска программы.
- timeout: Тайм-аут для выполнения программы.
- cwd: Рабочая директория для запуска программы.
- env: Окружение для запуска программы.
- stdin: Поток ввода для программы.
- stderr: Поток ошибок программы.
- creationflags: Флаги создания для команды запуска.
- file_name: Имя выходного файла. По умолчанию используется имя программы binary. Конечное имя файла будет <file_name>.out.txt.
- save_locally: Если True, выходной файл будет сохранен в локальный репозиторий.

Для канонизации stdout запуска python-скриптов можно воспользоваться функцией
```
yatest.common.canonical_py_execute(script_path, args=None, check_exit_code=True, shell=False, timeout=None, cwd=None, env=None, stdin=None, stderr=None, creationflags=0, file_name=None)
```

Пример канонизации вывода нескольких программ:
```
res1 = yatest.common.canonical_execute(binary1)
res2 = yatest.common.canonical_execute(binary2)
return {"stand_initializer": res1, "prog2": res2}
```
##### Ожидаемое несоответствие канонизации

В `pytest` поддерживается механизм `xfail` (expected to fail), который используется для обозначения тестов, ожидаемо приводящих к падению. Однако, поскольку канонизация представляет собой надстройку над всеми тестовыми фреймворками, их механизмы не могут влиять на процедуру сверки канонических данных. Таким образом, тест, помеченный как `xfail` и имеющий расхождения (diff) с каноническими данными, будет считаться поломанным.

Чтобы указать, что у теста канонические данные отличаются от ожидаемых или отсутствуют, и это допустимо, его нужно пометить маркером `@pytest.mark.xfaildiff`. В этом случае:

- Если тест упадет, он получит статус `FAIL`.
- Если тест успешно выполнится и вернет канонические данные, но сравнить их будет не с чем (например, если канонизация ещё не проводилась и вы не хотите канонизировать неверные данные) или если данные будут отличаться, то тест получит статус `XFAIL`.
- Если тест успешно выполнится и канонические данные совпадут, тест упадет со статусом `XPASS`.

При канонизации (с использованием опции `-Z/–canonize-tests`) тесты, помеченные как `xfaildiff`, не будут канонизироваться.

#### Канонизация в Java

Канонизация в Java позволяет сохранять ожидаемые результаты тестов (канонические данные), чтобы можно было сравнить их с результатами последующих запусков тестов.

Чтобы канонизировать данные, нужно использовать функции из `devtools/jtest`.

##### Канонизация объектов

Основная функция для канонизации объектов:
```
ru.yandex.devtools.test.Canonizer.canonize(Object);
```
Особенности:
- Объект будет сериализован с помощью `new Gson().toJson(obj)`.
- На каждый тест может быть только один вызов `ru.yandex.devtools.test.Canonizer.canonize(Object)`. Если будет несколько вызовов, последний перетрет результаты предыдущих.

##### Канонизация файлов

Для канонизации файлов используется класс `ru.yandex.devtools.test.CanonicalFile`.

Основная функция для канонизации файлов:
```
ru.yandex.devtools.test.CanonicalFile.canonize(path, diffTool, diffToolTimeout, local);
```
Описание параметров:
- path: Путь до файла, который необходимо канонизировать.
- diffTool: Путь к программе для сравнения канонических файлов. Может использоваться для нестандартных программ сравнения.
- diffToolTimeout: Тайм-аут для выполнения программы сравнения.
- local: Если установлено в true, файл будет сохранен локально.

Если кастомный `diff_tool` представляет собой `Java-программу`, путь к ней должен передаваться вместе с путем до `Java`.

#### Канонизация в Go

Для канонизации данных нужно использовать `library/go/test/canon`.

##### Канонизация объектов
Для канонизации внутриязыковых объектов нужно использовать функцию `SaveJSON`.

##### Канонизация файлов
Для того, чтобы канонизировать файл, нужно использовать `SaveFile`.

Чтобы сохранять эти файлы локально, нужно в фукнцию SaveFile передать аргумент `canon.WithLocal(true)`.

Помимо обычного `diff`, можо использовать кастомный `diff_tool`.

#### Diff Tool для Сравнения Канонических Файлов и Директорий

По умолчанию, во всех фреймворках для сравнения канонизированных данных используется стандартная утилита diff. Однако, для специализированных случаев можно использовать кастомные diff-инструменты, которые могут лучше соответствовать специфике ваших данных и требований.

##### Основные Параметры

1. Поддерживаемые Фреймворки и Языки:
- Python
- Java
- Go
- Другие языки с поддержкой канонизации

2. Пример Стандартного Diff Tool:
- По умолчанию используется стандартный diff, который принимает два файла на вход и возвращает:
- Код 0, если файлы одинаковы.
- Код 1, если файлы различаются и выводит информацию о различиях в stdout.

##### Создание и Использование Кастомного Diff Tool

Для того, чтобы переопределить программу для сравнения канонических файлов, нужно добавить в секцию `DEPENDS` теста путь к `ya.make` программы, которая удовлетворяет следующим условиям:

1. Принимает на вход два неименованных аргумента:
- Пути к файлам, которые нужно сравнить.

2. Возвращает корректные коды выхода:
- Код 0, если файлы одинаковы.
- Код 1, если файлы различаются, и выводил информацию о различиях в stdout.

3. Был совместимым с вашей средой выполнения

В тестах в соответствующих функциях для канонизации файла или директории передать путь к програме.
