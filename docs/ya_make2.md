# ya make: основной сборочный инструмент

Система сборки `ya make` –  основная команда утилиты  `ya`, обеспечивающее автоматизацию сборки проекта, которая позволяет  компилировать код, управлять зависимостями, запускать тесты и генерировать исполняемые файлы в едином и согласованном окружении независимо от сложности проекта.

Чтобы подробно обсудить структуру и процесс работы нашей системы сборки, важно сначала познакомиться с рядом специфических терминов и концепций, которые мы будем использовать. Это поможет лучше понять, как функционирует система и какие преимущества она предоставляет.

Давайте начнем с основных терминов:
1. Сборочная цель (модуль): Программа, библиотека или пакет, которые будут собираться. Она может быть интерпретирована как конкретный результат сборки (артефакт) или как описание сборки, заданное в файле `ya.make`.
2. Артефакт - реальный результат сборки, такой как файл программы или библиотеки, либо директория с файлами пакета.
3. Описание сборки: Файл`ya.make`, который содержит инструкции по сборке программы, библиотеки или пакета.
4. Символьная ссылка: Специальный тип файла, который ссылается на другой файл или директорию.
5. Мультимодули: Специальные сборочные цели, которые могут создавать разные артефакты в зависимости от контекста их использования.
6. Промежуточный модуль: Библиотека или иной компонент, используемый для сборки финальных модулей. Промежуточные модули не предназначены для самостоятельного использования.
7. Финальный модуль: Программа, динамическая библиотека, тест или другой артефакт, который может исполняться и использоваться самостоятельно.
8. UID (Unique Identifier): Уникальный идентификатор для каждой сборочной команды, основанный на всех факторах, влияющих на её результат.
9. Герметичность сборки: Принцип, согласно которому сборка зависит только от данных, известных системе сборки, и не зависит от внешних факторов или файлов, не фиксированных в конфигурации сборки.
10. Конфигурирование: Процесс анализа зависимостей и построения графа сборочных команд в системе `ya make`.
11. Граф сборочных команд: Структура данных, представляющая зависимости между сборочными командами. В узлах графа расположены команды, а ребра указывают на порядок выполнения команд.
12. Макрос: Инструкция в `ya.make`, которая описывает конкретные аспекты сборки, такие как исходный код, зависимости, а также управляет логикой интерпретации файла.
13. PEERDIR: Макрос, указывающий на межмодульную зависимость; говорит системе сборки, что для сборки текущей цели необходима другая сборочная цель.
14. RECURSE/RECURSE_FOR_TESTS: Макросы, используемые для того, чтобы включить одно или несколько сборочных целей в текущий сборочный процесс.

Со всеми базовыми определениями и принципами системы сборки можно ознакомится в соответствующем разделе [документации](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_principle.md)

`ya make` позволяет очень гибко настраивать параметры сборки. 

Список настраиваемых возможностей включает:

- [Выбор типа и вида сборки](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_buildtype.md) — debug/release, LTO, sanitizers и т. п.
- [Параметры платформ](#Кросс-компиляция) — целевые аппаратная платформа и OS, настройки сборочной платформы и т. п.
- [Установку сборочных переменных](#Сборочные-переменные) — Например, `-DCFLAGS=-Wall`, `-DDEBUGINFO_LINES_ONLY` и т. п.
- [Настройки сборки](#Настройки-сборки) - выбор дополнительных результатов сборки и т. п.
- [Запуск и работу с тестами](#Локальная-работа-с-тестами) 

## Синтаксис

Ознакомтесь с возможностями сборки: `ya make  -h, --help`  печатает справку . Используйте `-hh` для большего количества опций и `-hhh` для ещё большего.

Со встроенной справкой можно также ознакомиться по [ссылке](helpfilemake.md)

### Общая форма команды

`ya make [OPTIONS]… [TARGET]…`

`[OPTIONS]` обозначает одну или несколько опций команды, предназначенных для изменения поведения сборки или тестирования. Опции могут управлять такими параметрами, как тип сборки (например, отладочный или релиз), применение оптимизации, использование инструментов анализа кода и многое другое.

`[TARGET]…` указывает на одну или несколько целей сборки. Целью может быть конкретный модуль в проекте, директория, содержащая компоненты для сборки, или специально заданный аргумент, определяющий действие (например, запуск тестов). Если цель не указана, ya make обычно выполняет сборку всего проекта, начиная с текущего каталога.

## Опции

Для систематизации многообразия опций, сделать информацию о них более доступной для пользователей опции можно разбить на следующие основные категории:

1.	Основные опции
2.	Опции сборки
3.	Опции Java - сборки
4.	Опции оптимизации
5.	Опции тестирования
6.	Опции вывода и логирования
7.	Опции кеширования
8.	Интеграция с внешними ресурсами
9.	Фаззинг
10.	Опции авторизации

Также опции разделяют по типам:

1.	Основные
2.	Расширенные 
3.	Экспертные

Полный список основных опций и примеры их использования можно найти в этой [документации](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_options.md).

Система сборки предлагает широкие возможности для тестирования, полный перечень опций и их описание можно найти [здесь](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_test.md).

### Опции сборки

Настройки сборки в ya make позволяют детально управлять процессом сборки проекта, оптимизировать его для разных сценариев использования и достичь требуемого баланса между скоростью сборки и требованиями к качеству исходного кода. 

Основные опции:

* `-d, --debug`
Опция `-d` или `--debug` активирует сборку в режиме отладки. В этом режиме компилятор включает отладочную информацию в генерируемые исполняемые файлы и снижает уровень оптимизации кода, что делает процесс отладки приложения более удобным и эффективным за счет улучшенной интерпретации и отслеживания ошибок.

* `-r, --release`
Использование флага `-r` или `--release` инициирует сборку проекта в режиме релиза. В этом режиме команда сосредоточена на оптимизации исполняемого кода для достижения максимальной производительности приложения, часто за счет размера выпускной версии и отсутствия отладочной информации.

* `-v, --verbose`
Флаг `-v` или `--verbose` инициирует подробный режим вывода, благодаря которому становится доступной дополнительная информация о процессе сборки. Подробный вывод может быть полезен для диагностики и устранения проблем, связанных со сборкой проекта.

* `--rebuild`
Опция `--rebuild` указывает команде `ya make` игнорировать результаты предыдущих сборок и начать процесс сборки с нуля.

Данная версия `ya make` поддерживает только локальную версию сборки. Планируется добавить распределенную сборку, для чего зарезервирована опция `--dist`.

### Локальная сборка ya make

Локальная сборка — это процесс сборки проекта, выполняемый непосредственно на машине разработчика. Эта опция идеально подходит для небольших проектов или в ситуациях, когда необходима быстрая итерация в процессе разработки.

Особенности локальная сборки:

- [Сборочные директории и файлы](#Директории-и-файлы)
- [Контентные UIDы](#Контентные-UIDы)
- [Локальная работа с тестами](#Локальная-работа-с-тестами)

#### Директории и файлы 

Директории, которые использует локальная сборка настраиваются следующими ключами:

- `-S=CUSTOM_SOURCE_ROOT`, `--source-root=CUSTOM_SOURCE_ROOT` — путь до проекта из которой производить сборку. По умолчанию определяется автоматически по текущему пути, в котором запущена команда `ya make`.
- `-B=CUSTOM_BUILD_DIRECTORY`, `--build-dir=CUSTOM_BUILD_DIRECTORY` — корень сборочных директорий. Каждая сборочная команда исполняется в собственной директории, поэтому задаётся корень для всех таких директорий. По умолчанию эти директории размещаются внутри `~/.ya/build/`

Директории для результатов сборки можно указать следующими параметрами:

- `-o=OUTPUT_ROOT`, `--output=OUTPUT_ROOT` — путь, куда будут сложены результаты сборки (на Linux и macOS будут использованы хардлинки). Результаты будут размещены по путям.
- `I=INSTALL_DIR`, `--install=INSTALL_DIR` — **не рекомендуется** путь, куда будут сложены результаты сборки. Результаты будут сложены непосредственно в указанную директорию.

При локальной сборке можно переопределить куда будут складываться лог сборки и лог событий.

- `--log-file=LOG_FILE` — добавлять подробный лог к указанному файлу. По умолчанию на каждую сборку создаётся свой лог внутри `~/.ya/logs/`
- `--evlog-file=EVLOG_FILE` — записать лог событий в указанный файл. По умолчанию на каждую сборку создаётся свой лог внутри `~/.ya/evlogs/`

#### Контентные UIDы

Локальная сборка работает в режиме [контетных UIDов](https://github.com/mtv2000/yatool/blob/newstyle/docs/UIDwork.md)

В этом режиме она не перезапускает команды если результаты её команд-зависимостей не поменялись. Для этого используется дополнительное кэширование по контентному (динамическому) UID.

Режим отключается опцией `--no-content-uids` или настройкой `content_uids = false` в `ya.conf`.

[О генерации конфигурационного файла инструмента](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_conf.md)

Использование контентных uid-ов видно в запуске с `--stat`

```
[=] ya make path/test/content_uids_cache/simple/original --stat

Cache hit ratio is 71.43% (5 of 7). Local: 2 (28.57%), dist: 0 (0.00%), >>> by dynamic uids: 3 (42.86%) <<< `
. . .
[CC-DYN_UID_CACHE] - 6 ms.  <<<
[LD-DYN_UID_CACHE] - 2 ms.  <<<
```

#### Локальная работа с тестами 

Полный перечень опций тестирования и их описание можно найти [здесь](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_test.md).

По умолчанию локально результаты тестов не кэширутся.

На данный момент локальный запуск тестов учитывает таймауты в соответствии с размером (1 минута для SMALL, 10 для MEDIUM, час для LARGE), но не ограничивает ресурсы в соответствии с `REQUIREMENTS`.

По умолчанию, локальная сборка производится в конфигурации `debug`, а в автосборке `relwithdebinfo` (релизная с ассёртами), поэтому поведение и производительность тестов может отличаться. 

Результаты тестов локально складываются в директорию `test-results`, которая появляется символьной ссылкой в рабочей копии в директории теста (кроме Windows или при использовании флага `--no-src-links`).

Внутри находится директория `<suittype>/testing_out_stuff` в которой находятся логи тестов и прочие файлы, которые тесты порождают. 

Если тесты не прошли успешно, в консоль может быть выведена информация о путях в реальных директориях внутри сборочного каталога, где выполнялись тесты. Чтобы сохранить эти данные после завершения тестов, сборочные директории не очищаются сразу, а только при следующем запуске сборки. Таким образом, данные в этих каталогах доступны до следующей сборки или запуска тестов. Если вам необходимо сохранить эти данные, скопируйте их заранее.

##### Запуск тестов (-t, -tt, -ttt, -A)

- `-t`: Эта базовая опция запускает все тесты, отмеченные как “маленькие” (SMALL). Это быстрые тесты, обычно требующие мало ресурсов и времени для выполнения.

- `-tt`: Расширение базовой опции `-t`, которое включает в себя запуск тестов как “маленьких”, так и “средних” (MEDIUM) размеров. Средние тесты обычно занимают больше времени и ресурсов.

- `-ttt`: Данная опция запускает тесты всех размеров, включая “большие” (LARGE). Большие тесты часто включают в себя интеграционные и нагрузочные тесты, требующие значительного времени для выполнения и могут включать внешние зависимости.

- `-A, --run-all-tests`: Аналогично `-ttt`, запускает все тесты независимо от размера.

##### Управление выводом результатов

- `-L, --list-tests`: Выводит список тестов, которые будут выполнены, без их фактического запуска. Помогает разработчикам быстро проверить, какие тесты включены в план тестирования.

- `–fail-fast`: Прекращает выполнение тестового прогона сразу после первой встреченной неудачи. Эта опция полезна для экономии времени и ресурсов, особенно когда разработчики ищут конкретную ошибку.

##### Выборочное тестирование

- `–test-filter=TESTS_FILTERS`: Эта опция позволяет ограничить тестирование только определенными тестами, соответствующими указанным фильтрам. Это может быть имя теста, его часть или другой идентифицирующий шаблон.

- `–test-tag=TEST_TAGS_FILTER`: Позволяет запускать только те тесты, которые помечены определенными тегами. Теги — это пользовательские метки, которые могут быть нанесены на тесты для их группировки по определенным признакам или функциональности.

- `–test-size=TEST_SIZE_FILTERS`: Фильтр для запуска тестов определенного размера (SMALL, MEDIUM, LARGE), позволяющий более точно настроить объем запускаемых тестов в зависимости от текущих потребностей.

- `–test-type=TEST_TYPE_FILTERS`: Ограничивает запуск только теми тестами, которые относятся к указанным типам (например, UNITTEST, PYTEST). Удобно при необходимости проведения специфичных видов тестирования.

## Кросс-компиляция

При сборке кода под платформой понимают аппаратную платформу (CPU, набор машинных инструкций, которые должны быть использованы в бинарном коде), операционную систему, на который должна работать программа, и программные средства, которые должны быть использованы для сборки (компилятор и т. п.). Система сборки ya make не исключение. Платформа для неё — это тройка <компилятор, OS, архитектура>, например <clang11, Windows, x86_64> или <clang10, Android, armv8a>.

По умолчанию в качестве целевой и сборочной платформ выбирается та, где запущена сборка. Т. е. в качестве операционной системы будет выбрана та, где вы работаете (Linux, Darwin (macOS) или Windows), в качестве архитектуры x86_64 или arm64 (для маков на процессоре m1), а в качестве компилятора будет использован вариант по умолчанию (default) для данной OS.

Поменять целевую платформу можно флагом `--target-platform`. В качестве значения нужно указать тройку <компилятор, OS, архитектура>, соединив значения через дефис. Также можно указать какое-то подмножество компонент этой тройки (остальные элементы подставятся по умолчанию). Для выбора компилятора по умолчанию можно указать специальное значение DEFAULT.

Примеры:

`--target-platform clang-win-x86_64` — собрать по Intel 64bit Windows компилятором Clang;
`--target-platform default-android-armv8a` — собрать под Android на ARM (в версии armv8a) компилятором по умолчанию;
`--target-platform windows` — собрать под Windows (и архитектуру по умолчанию x86-64) компилятором по умолчанию.

## Сборочные переменные

В команде `ya make` можно указать дополнительные флаги (переменные) с помощью опции `-DVAR[=VALUE]`. Если не указывать значение переменной, по умолчанию оно будет выставлено в yes.

Можно определить:

Предопределённые переменные, позволяющие передать флаги для сборки `ya make` `-DLDFLAGS="-fblabla=foo -fbar"`, `ya make -DCFLAGS="-DNN_DOUBLE_PRECISION -Wno-strict-aliasing"`.
Предопределённые переменные, управляющие конфигурацией, например `ya make -DCATBOOST_OPENSOURCE` (сборка как для open source) или `ya make -DCUDA_VERSION=10.1` (сборка с CUDA).
Переменные для использования в `ya.make` `ya make -DMACRO1 -DMACRO2=42`, где в `ya.make` написано, например `IF (MACRO1)`.
Список доступных переменных достаточно большой и часто меняется. Самые часто используемые переменные можно найти в соответствующих разделах [руководства по системе сборки](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_yamake.md)

## Настройки сборки 

### Структура файла ya.make

Файлы `ya.make` являются основой для определения инструкций сборки в проектах, использующих `ya make`. Каждый такой файл содержит набор макросов, которые описывают, как должны быть скомпилированы модули, управляют зависимостями и определяют параметры тестирования. В типичном файле `ya.make` можно указать:

- Владельца модуля (OWNER) – обычно это имя пользователя или группа, ответственная за модуль.
- Тип сборки (PROGRAM, LIBRARY, PY3_LIBRARY и т.д.) – указывает, является ли модуль исполняемым файлом, библиотекой или чем-то иным.
- Источники (SRCS) – перечень файлов исходного кода, которые следует скомпилировать.
- Зависимости (PEERDIR, DEPENDS) – другие модули или библиотеки, от которых зависит текущий модуль.
- Параметры и флаги компиляции (CFLAGS, LDFLAGS и др.) для настройки процесса сборки.

Пример базового файла ya.make:
```
OWNER(user)
PROGRAM()
SRCS(main.cpp util.cpp)
PEERDIR(library/util)
```
#### Определение модулей и их свойств

Модули в `ya.make` обычно определяются с помощью макросов, указывающих тип модуля (PROGRAM, LIBRARY и т.д.). Каждый модуль в проекте описывается в отдельном файле ya.make, который включает в себя все необходимые инструкции для его сборки.

Свойства модуля, такие как исходные файлы (SRCS), зависимости (PEERDIR) и специфичные для компилятора флаги (CFLAGS), настраиваются внутри блока макросов от PROGRAM или LIBRARY до END().

#### Объявление зависимостей и ресурсов

Для управления зависимостями между различными компонентами проекта в файлах `ya.make` используются макросы `PEERDIR` и `DEPENDS`. Макрос `PEERDIR` указывает на другие модули внутри проекта, необходимые для сборки текущего модуля, обеспечивая правильное разрешение локальных зависимостей. `DEPENDS` может использоваться для объявления внешних зависимостей, которые требуют загрузки или специфической обработки перед сборкой.

Ресурсы, такие как изображения, конфигурации и данные для тестов, могут быть также объявлены в `ya.make` для корректного включения их в процесс сборки или тестирования с помощью макросов, предназначенных для работы с ресурсами (RES).

Работа с файлами `ya.make` требует понимания структуры и синтаксиса этих файлов, что позволяет гибко настраивать процесс сборки проекта и управлять сложными системами зависимостей. С более подробной информацией, как писать `ya.make` можно ознакомится [здесь](ya_make_yamake.md)

Для создания или изменения файлов `ya.make` служит команда [`ya project`](project.md)

### Настройки исполнения сборки

Настройки исполнения сборки включают следующие параметры:
  - Отображение прогресса: Настройка вывода информации о текущем состоянии сборки в консоль.
  - Управление результатами сборки: Параметры, касающиеся обработки и сохранения результатов сборки.
  - Строгий контроль зависимостей: Обеспечение строгого контроля и проверки зависимости модулей.
  - [Локальное кэширование](cache.md): Настройка кэша для локальных сборок, чтобы ускорить процесс при повторных запусках.
  - Локальное исполнение сборки: Конфигурация и параметры для выполнения сборки на локальной машине.

#### Отображение прогресса: 

Настройка вывода информации о текущем состоянии сборки в консоль.

По умолчанию система сборки выводит прогресс в стиле ninja, использует одну строку для статуса сборки. Статус отображается только для одной из команд, выполняющихся параллельно, со сведениями о других командах в конце строки (+X more). Этот формат позволяет эффективно отслеживать выполнение сборки в средах с ограниченным пространством на экране.

Пример вывода прогресса:
```
  |99.3%| [JV] {debug} $(B)/devtools/bob/test/tests/tags/data/java/data-java.jar +12 more / 76.8GiB
   ^^^^        ^^^^^^^                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^   ^^^^^^^
  Прогресс     Конфигурация и платформа Вход или результат команды              Количество Занято 
                                                                               команд     место в кэше
```
[Конфигурирование](ya_make_confbuild.md) имеет собственный индикатор прогресса:
```
[2 ymakes processing] [150/180 modules configured] [4675 files read] [60/100 modules rendered]
```
В нём отображается:

1. Число активных процессов анализа зависимостей (ymake).

  - Анализ зависимостей делается утилитой ymake для каждой конфигурации отдельно. Для Linux анализируем в одной сборке 4 конфигурации `([target,host] x [pic,nopic])`. Часть из этого делается последовательно, часть параллельно, поэтому чаще всего будет 2 ymakes processing.
  - Числа для остальных пунктов суммируются для всех конфигураций.

2. Совокупное число модулей, для которых проведён анализ зависимостей;

  - При конфигурировании система сборки оперирует понятием модуля. При чтении ya.make и конфигурировании модулей система сборки узнаёт, что есть ещё модули в зависимостях, и конфигурирует их. Поэтому у modules configured бегут обе цифры.
  - Под анализом зависимостей есть кэш и если он используется, то цифры бегут очень быстро.

3. Число прочитанных системой сборки файлов (отображается, только если файлы читаются медленно);

  - Для расчёта UIDов и анализа зависимостей система сборки читает не только `ya.make` файлы, но и файлы исходного кода. В зависимости от ситуации, файлы могут не читаться вовсе, читаться из кэша файловой системы, читаться с диска или читаться по сети. Заранее число файлов неизвестно, поэтому отображается только одна цифра.

4. Количество модулей, для которых построены сборочные команды.

  - Когда граф зависимостей построен, он превращается в граф команд. Преобразование делается по-модульно, но здесь уже система сборки знает, сколько работы ей надо сделать. Поэтому у `modules rendered` вторая цифра меняется, только когда система сборки начинает рендерить следующую конфигурацию, в остальное время она статична.
  - Под рендерингом есть кэш и при работе с ним цифры меняются очень быстро.

Изменить вывод статуса на построчный можно опцией `-T`. Этот же режим включается при перенаправлении вывода команды `ya make` в файл.

Вывод команды ya make можно расширить следующими опциями:
  * `-v`, `--verbose` — выводить текст исполнившихся сборочных команд
  * `--do-not-output-stderrs` — не выводить stderr команд
  * `--show-timings` — выводить времена исполнения команд в статус, работает только с опцией `-T`
  * `--show-extra-progress` — выводить расширенный прогресс (количество исполненных команд) в статус. Работает только с `-T`
  * `--cache-stat` — перед сборкой выдать статистику по наполнению локального кэша
  * `--stat` — в конце сборки выдать статистику по сборке. Статистика включает использование кэшей, критический путь, самые долгие сборочные шаги и т.п.

#### Управление результатами сборки

Параметры, касающиеся обработки и сохранения результатов сборки. По умолчанию все результаты локальной сборки (как промежуточные, так и финальные) кэшируются для ускорения последующих сборок. Эти результаты могут быть полностью отключены от кэширования с использованием опции --rebuild, что позволяет выполнять сборку полностью с нуля.

##### Результаты Сборки

Результаты сборки формируются на основании файлов [ya.make](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_yamake.md), собранных командой `ya make`, с учетом следующих параметров:
  - Значения опций --target/-C
  - Свободных опций
  - Рабочей директории
  - Путей в макросах RECURSE и DEPENDS

По умолчанию целями сборки являются модули, непосредственно указанные в `ya.make` директорий в командной строке, а также рекурсивно во всех макросах RECURSE, доступных из ya.make директорий в командной строке.

Это поведение может быть изменено следующими опциями:

  - `-t` или `-A` — запуск тестов добавляет к сборке то, что достижимо из макросов RECURSE_FOR_TESTS и DEPENDS. Правила поиска тестов такие же, как описано выше, т.е. RECURSE_FOR_TESTS в ya.make модулей, доступных по PEERDIR, не учитываются. Кроме добавления модулей к сборке, эти макросы приводят к запуску тестов.
  - `--force-build-depends` — добавить в сборку все, что нужно для запуска тестов (как с опциями -t/-A), но тесты не запускать.
  - `-DTRAVERSE_RECURSE_FOR_TESTS` — трактовать RECURSE_FOR_TESTS при поиске сборочных целей как обычный RECURSE.
  - `--ignore-recurses` — не использовать RECURSE, строить только модули, непосредственно указанные в командной строке.

Результаты сборки могут быть сложены на постоянное хранение в выходную директорию, указанную с помощью опции `-o/--output <path>`. Система сборки не отслеживает файлы в директории <path>, и их удаление необходимо производить вручную.

На Linux/MacOS, если не указана опция `--no-src-links`, результаты будут сложены во временное хранилище — кэш результатов. В этом случае файлы и директории из кэша результатов доступны по символическим ссылкам из рабочей копии репозитория.

Иногда нужно сохранить файлы прямо там, где исполнялась сборка (в сборочных директориях), например, чтобы воспроизвести отдельные команды сборки. Для этого используется опция `--keep-temps`.

По умолчанию в множество результатов сборки включаются только конечные артефакты для целей сборки, такие как программа, результат запуска теста и т.д. Важно понимать, что только результаты и все, что нужно для их построения, действительно строится. Поэтому если что-то не достижимо из результатов сборки, строиться оно не будет.

Иногда нужно сохранить промежуточные результаты или, наоборот, отфильтровать ненужные конечные результаты. Перечисленные ниже опции влияют на следующие аспекты поведения:

- Файлы, доступные как символические ссылки на Linux и macOS (если не указана опция `--no-src-links`)
- Файлы, попадающие в директорию результатов сборки

Для расширения набора результатов сборки, можно использовать опцию `--add-result=.<suff>`. В конфигурационном файле `ya.conf`можно задать `add_result = [".suff"]`. 

Пример команды:
`ya make -o=<output> <target> --add-result=.o --add-result=.obj`
Складывает объектные файлы в директорию <output> и (на Linux и MacOS) создает ссылки на файлы из кэша результатов в директории с исходниками.

##### Дополнительные Опции:
  - `--add-protobuf-result` — Добавить все результаты генерации для Protobuf.
  - `--add-flatbuf-result` — Добавить результаты генерации Flatbuffers.
  - `--add-modules-to-results` — Сделать все модули (включая зависимые по PEERDIR) результатами сборки.
  - `--add-host-result=.<suff>` — Добавить выбранные результаты из сборочной платформы.
  - `--all-outputs-to-result` — Не фильтровать результаты команд. Обычно `--add-result` фильтрует результаты команд по расширениям, с помощью этой опции можно запросить все результаты для команд, подходящих под `--add-result`.

Примеры:
    - `ya make --add-result=.pb.h` - результат только файлы `.pb.h`
    - `ya make --add-result=.pb.h --all-outputs-to-result` - результат как `.pb.h`, так и `.pb.cc`. 

Иногда хочется построить только генерируемые файлы, но не библиотеки/программы. Для этого служит опция `--replace-result`. Она оставит в результатах сборки только то, что выбрано в `--add-result`, все остальное будет удалено и не будет строиться совсем.

##### Ограничение множества результатов:

Множество отображаемых результатов можно ограничить с помощью:
  - `--no-output-for=.<suff>` — Ограничить множество отображаемых результатов.
  - `suppress_outputs = [".suff"]` — Параметр конфигурационного файла.

Эти опции не исключают файлы из сборки, они лишь говорят системе сборки, что результаты не надо складывать в рабочую копию и выходную директорию. Опция `--no-output-for` не взаимодействует с `--replace-result`. Файлы, исключенные из результатов, все равно будут построены и останутся в кэше.
 
### Строгий контроль зависимостей

По умолчанию локальная сборка выполняется в режиме, где каждый сборочный узел имеет доступ на чтение ко всему репозиторию. 
Контроль зависимостей осуществляется на этапе конфигурирования: этот этап анализирует зависимости команд и присваивает всем необходимым файлам уникальные идентификаторы (UID). Дополнительную информацию можно найти по этой [ссылке](https://github.com/mtv2000/yatool/blob/newstyle/docs/UIDwork.md).

Однако такое поведение может вызвать проблемы, если какая-либо зависимость сборки упущена. Если это зависимость от другой команды, её результат не будет доступен, и команда с упущенной зависимостью завершится с ошибкой. Это легко выявить и исправить. Хуже обстоит дело, если упущена зависимость от файла в репозитории. В этом случае конфигурирование не учтёт содержимое файла в UID, но команда сможет его прочитать. Кэширование состояния будет зависеть от содержимого файла, что вызовет множество проблем:

1. Сборочный кэш будет “отравлен” содержимым файла, и поведение сборки станет непредсказуемым в зависимости от закэшированного состояния.
2. Изменение файла не будет инициировать пересборку зависимых компонентов, хотя это должно происходить.
3. В конечном итоге возможно попадание в релиз системы с неактуальным содержимым файла.

Для решения таких проблем рекомендуется использовать строгий контроль зависимостей. Этот подход обеспечивает тщательную проверку и контроль зависимостей модулей. Настройка гарантирует корректное установление и проверку всех зависимостей модуля перед началом сборки, что помогает избежать проблем с отсутствующими или несовместимыми зависимостями и обеспечивает стабильность сборочного процесса.

## Сообщения об ошибках

`ya make` предоставляет подробные сообщения об ошибках и предупреждениях, которые помогают идентифицировать и устранять проблемы в процессе сборки и тестирования. Эти сообщения могут включать информацию о недостающих файлах, циклических зависимостях, проблемах в конфигурации и многом другом. 
 
  * Конфигурационные ошибки (BadAuto, BadDir, и т.д.): Эти ошибки свидетельствуют о проблемах в настройках сборки, например, неправильно указанных директориях или файлах. Убедитесь, что все пути указаны корректно, и что ваши конфигурации соответствуют требованиям вашего проекта.
  * Ошибки зависимостей (DEPENDENCY_MANAGEMENT, DupSrc): Такие ошибки указывают на проблемы с управлением зависимостями, включая дублирование источников или некорректное управление зависимыми модулями. Для решения таких проблем проверьте объявления ваших зависимостей в файлах `ya.make` и устраните дубликаты или некорректные ссылки.
  * Синтаксические ошибки (Syntax): Ошибки синтаксиса часто возникают из-за неверного использования макросов или опечаток в файлах `ya.make`. Внимательно проверьте синтаксис ваших конфигурационных файлов на соответствие документации `ya make`.
  * Пользовательские ошибки (UserErr, UserWarn): Эти сообщения генерируются, когда `ya make` сталкивается с проблемами, непосредственно связанными с действиями пользователя, такими как неверное использование опций или несоответствие требованиям проекта.

## Популярные рецепты

* `ya make -r` - собрать код c оптимизациями и отладочной информацией 
* `ya make -v` - собрать в verbose-режиме. **Обратите внимание:** `ya -v make` и `ya make -v` имеют разный эффект. Первая добавляет вывод утилиты `ya`, вторая — сборки.
* `ya make -T` - собрать, не перезатирая выполняемые команды в выводе
* `ya make --add-result=".h" --add-result=".cpp"` - собрать, добавив в результаты сгенерированные в процессе сборки cpp- и h-файлы.
* `ya make --add-result=".pb.h" --add-result=".pb.cc" --replace-result`- запустить только кодогенерацию протобуфов.
* `ya make -t`  - запустить только быстрые тесты
* `ya make -tL` - вывести список быстрых тестов
* `ya make -A`  - запустить все тесты
