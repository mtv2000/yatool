# ya make: основной сборочный инструмент

Система сборки `ya make` –  основная команда утилиты  `ya`, обеспечивающее автоматизацию сборки проекта, которая позволяет  компилировать код, управлять зависимостями, запускать тесты и генерировать исполняемые файлы в едином и согласованном окружении независимо от сложности проекта.

Чтобы подробно обсудить структуру и процесс работы нашей системы сборки, важно сначала познакомиться с рядом специфических терминов и концепций, которые мы будем использовать. Это поможет лучше понять, как функционирует система и какие преимущества она предоставляет.

Давайте начнем с основных терминов:
1. Сборочная цель (модуль): Программа, библиотека или пакет, которые будут собираться. Она может быть интерпретирована как конкретный результат сборки (артефакт) или как описание сборки, заданное в файле `ya.make`.
2. Артефакт - реальный результат сборки, такой как файл программы или библиотеки, либо директория с файлами пакета.
3. Описание сборки: Файл`ya.make`, который содержит инструкции по сборке программы, библиотеки или пакета.
4. Символьная ссылка: Специальный тип файла, который ссылается на другой файл или директорию.
5. Мультимодули: Специальные сборочные цели, которые могут создавать разные артефакты в зависимости от контекста их использования.
6. Промежуточный модуль: Библиотека или иной компонент, используемый для сборки финальных модулей. Промежуточные модули не предназначены для самостоятельного использования.
7. Финальный модуль: Программа, динамическая библиотека, тест или другой артефакт, который может исполняться и использоваться самостоятельно.
8. UID (Unique Identifier): Уникальный идентификатор для каждой сборочной команды, основанный на всех факторах, влияющих на её результат.
9. Герметичность сборки: Принцип, согласно которому сборка зависит только от данных, известных системе сборки, и не зависит от внешних факторов или файлов, не фиксированных в конфигурации сборки.
10. Конфигурирование: Процесс анализа зависимостей и построения графа сборочных команд в системе `ya make`.
11. Граф сборочных команд: Структура данных, представляющая зависимости между сборочными командами. В узлах графа расположены команды, а ребра указывают на порядок выполнения команд.
12. Макрос: Инструкция в `ya.make`, которая описывает конкретные аспекты сборки, такие как исходный код, зависимости, а также управляет логикой интерпретации файла.
13. PEERDIR: Макрос, указывающий на межмодульную зависимость; говорит системе сборки, что для сборки текущей цели необходима другая сборочная цель.
14. RECURSE/RECURSE_FOR_TESTS: Макросы, используемые для того, чтобы включить одно или несколько сборочных целей в текущий сборочный процесс.

Со всеми базовыми определениями и принципами системы сборки можно ознакомится в соответствующем разделе [документации](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_principle.md)

`ya make` позволяет очень гибко настраивать параметры сборки. Список настраиваемых возможностей включает:

- [Выбор типа и вида сборки](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_buildtype.md) — debug/release, LTO, sanitizers и т. п.
- Параметры платформ — целевые аппаратная платформа и OS, настройки сборочной платформы и т. п.
- Установку сборочных переменных — Например, `-DCFLAGS=-Wall`, `-DDEBUGINFO_LINES_ONLY` и т. п.
- Настройки сборки - выбор дополнительных результатов сборки и т. п.
- Запуск и работу с тестами

## Синтаксис

Ознакомтесь с возможностями сборки: `ya make  -h, --help`  печатает справку . Используйте `-hh` для большего количества опций и `-hhh` для ещё большего.

Со встроенной справкой можно также ознакомиться по [ссылке](helpfilemake.md)

### Общая форма команды

`ya make [OPTIONS]… [TARGET]…`

`[OPTIONS]` обозначает одну или несколько опций команды, предназначенных для изменения поведения сборки или тестирования. Опции могут управлять такими параметрами, как тип сборки (например, отладочный или релиз), применение оптимизации, использование инструментов анализа кода и многое другое.

`[TARGET]…` указывает на одну или несколько целей сборки. Целью может быть конкретный модуль в проекте, директория, содержащая компоненты для сборки, или специально заданный аргумент, определяющий действие (например, запуск тестов). Если цель не указана, ya make обычно выполняет сборку всего проекта, начиная с текущего каталога.

## Опции

Для систематизации многообразия опций, сделать информацию о них более доступной для пользователей опции можно разбить на следующие основные категории:

1.	Основные опции
2.	Опции сборки
3.	Опции Java - сборки
4.	Опции оптимизации
5.	Опции тестирования
6.	Опции вывода и логирования
7.	Опции кеширования
8.	Интеграция с внешними ресурсами
9.	Фаззинг
10.	Опции авторизации

Также опции разделяют по типам:

1.	Основные
2.	Расширенные 
3.	Экспертные

Полный список основных опций и примеры их использования можно найти в этой [документации](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_options.md).

Система сборки предлагает широкие возможности для тестирования, полный перечень опций и их описание можно найти [здесь](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_test.md).

### Опции сборки

Настройки сборки в ya make позволяют детально управлять процессом сборки проекта, оптимизировать его для разных сценариев использования и достичь требуемого баланса между скоростью сборки и требованиями к качеству исходного кода. 

Основные опции:

* `-d, --debug`
Опция `-d` или `--debug` активирует сборку в режиме отладки. В этом режиме компилятор включает отладочную информацию в генерируемые исполняемые файлы и снижает уровень оптимизации кода, что делает процесс отладки приложения более удобным и эффективным за счет улучшенной интерпретации и отслеживания ошибок.

* `-r, --release`
Использование флага `-r` или `--release` инициирует сборку проекта в режиме релиза. В этом режиме команда сосредоточена на оптимизации исполняемого кода для достижения максимальной производительности приложения, часто за счет размера выпускной версии и отсутствия отладочной информации.

* `-v, --verbose`
Флаг `-v` или `--verbose` инициирует подробный режим вывода, благодаря которому становится доступной дополнительная информация о процессе сборки. Подробный вывод может быть полезен для диагностики и устранения проблем, связанных со сборкой проекта.

* `--rebuild`
Опция `--rebuild` указывает команде `ya make` игнорировать результаты предыдущих сборок и начать процесс сборки с нуля. Это может быть полезно в случаях, когда кэшированные результаты повреждены или когда требуется полная пересборка проекта для устранения несоответствий.

Данная версия `ya make` поддерживает только локальную версию сборки. Планируется добавить распределенную сборку, для чего зарезервирована опция `--dist`.

### Локальная сборка ya make

По умолчанию сборка запускается локально на той же машине, где запущена команда `ya make`.

Особенности локальная сборки:

- [Сборочные директории и файлы](#Директории-и-файлы)
- [Управление параллелизмом при исполнении сборки](#параллелизм-в-локальной-сборке)
- [Локальное кэширование](local_ya_cache.md#local-results)
- [Распределённое кэширование](yt_store.md)
- [Сборка с предпостроенными тулами](#prebuilt_tools)
- [Локальная работа с тестами](#tests)
- [Получение данных из SVN для сборки](#selective_co)

## Директории и файлы 

Директории, которые использует локальная сборка настраиваются следующими ключами:

- `-S=CUSTOM_SOURCE_ROOT`, `--source-root=CUSTOM_SOURCE_ROOT` — путь до Аркадии из которой производить сборку. По умолчанию определяется автоматически по текущему пути, в котором запущена команда `ya make`.
- `-B=CUSTOM_BUILD_DIRECTORY`, `--build-dir=CUSTOM_BUILD_DIRECTORY` — корень сборочных директорий. Каждая сборочная команда исполняется в собственной директории, поэтому задаётся корень для всех таких директорий. По умолчанию эти директории размещаются внутри `~/.ya/build/`

Директории для результатов сборки можно указать следующими параметрами:

- `-o=OUTPUT_ROOT`, `--output=OUTPUT_ROOT` — путь, куда будут сложены результаты сборки (на Linux и macOS будут использованы хардлинки). Результаты будут размещены по путям, соответствующим размещению описаний сборки в Аркадии.
- `I=INSTALL_DIR`, `--install=INSTALL_DIR` — **не рекомендуется** путь, куда будут сложены результаты сборки. Результаты будут сложены непосредственно в указанную директорию.

При локальной сборке можно переопределить куда будут складываться лог сборки и лог событий.

- `--log-file=LOG_FILE` — добавлять подробный лог к указанному файлу. По умолчанию на каждую сборку создаётся свой лог внутри `~/.ya/logs/`
- `--evlog-file=EVLOG_FILE` — записать лог событий в указанный файл. По умолчанию на каждую сборку создаётся свой лог внутри `~/.ya/evlogs/`

## Параллелизм в локальной сборке { #par }

Локальная сборка исполняет независимые сборочные команды параллельно. Для разных сборочных узлов доступен разный уровень параллелизма:

- Для обычной компиляции, генерации кода и скачивания ресурсов из Sandbox доступен самый высокий параллелизм. По умолчанию система сборки будет пытаться столько таких команд одновременно, 
  сколько есть ядер на сборочной машине. В большинстве случаев это разумное поведение. Однако, на системах с большим числом ядер и небольшим объёмам памяти при тяжёлых сборках это может
  приводить к ошибкам *Out of memory* (OOM). Кроме того, при сильной загрузке системы другой работой при таком параллелизме может снижаться отзывчивость. Для управления параллелизмом таких команд
  есть ключ `-j` (`--num-threads`) командной строки. Если хочется зафиксировать ограничение числа потоков на постоянной основе можно выставить параметр `num_threads` в файле `ya.conf`.

 
  Поскольку ограничение разумнее иметь на систему, а не на пользователя параметр лучше писать в файл `$HOME/.ya/ya.conf`, а не коммитить в `junk/<user>/ya.conf`

 
- Тесты тоже могу запускаться параллельно, однако предполагается, что они создают более высокую нагрузку и потому по умолчанию в параллель запускается не больше 2х тестов.
  Для управления параллелизмом запуска тестов служит параметр 	`--test-threads`.

- Аналогично тяжёлыми сборочными узлами считаются линковки. Их также запускают в параллель не больше 2х в обычном режиме и не больше одной в режимах `--lto`/`--thinlto`
  (Link-time optimization — режим, в котором вся компиляция происходит во время линковки для более глубокой оптимизации кода). Этот параллелизм настраивается ключом `--link-threads`.

- Отдельно настраивается параллелизм для скачивания с YT при использовании [распределённого кэша](./yt_store.md) параметром `--yt-store-threads`.

## Сборка с предпостроенными тулами { #prebuilt_tools }

По умолчанию локальная сборка для основных платформ (Linux, Darwin, Windows) в Аркадии выполняется с предпостроенными тулами. Это значит, что часть сборочных инструментов, которые собираются из Аркадии, приезжают в сборку в бинарном виде (как sandbox ресурсы). Список актуальных предпостроенных тулов можно найти [здесь](https://a.yandex-team.ru/arc/trunk/arcadia/build/prebuilt/ya.make). Такой механизм существенно сокращает время локальной сборки и снижает нагрузку на сборочные кэши, особенно после обновления рабочей копии. Дело в том, что сборочные тулы как правило зависят от util или стандартной библиотеки C++, которые, в свою очередь, обновляются достаточно часто. А это значит, что тулы будут перестраиваться тоже достаточно часто... И как следствие, будет перестраиваться всё что строится этими тулами в Аркадии - а это достаточное большое количество пересборок. 



Если по каким-то причинам хочется отключить использование предпостроенных тулов в локальной сборке, то в командной строке сборки необходимо добавить следующий набор флагов: `-DUSE_PREBUILT_TOOLS=no --host-platform-flag=USE_PREBUILT_TOOLS=no`



Дополнительные подробности о сборке с предпостроенными тулами можно прочитать [здесь](https://clubs.at.yandex-team.ru/arcadia/23540).

### Обновление предпостроенных тулов { #prebuilt_tools_update }

Для обновления предпостроенного тула предлагается использовать следующий алгоритм (на примере event2cpp):

1. Создайте ревью, закомментив там prebuild: [https://a.yandex-team.ru/review/2551740/details#comment-3520636](https://a.yandex-team.ru/review/2551740/details#comment-3520636)

2. Когда ревью финализируется, создайте тикет в DEVTOOLSSUPPORT с просьбой пересобрать нужный тул и приложите к нему pr

3. После получения id ресурсов (в саппортном тикете), раскомментриуйте prebuild и пропишите новые ресуры: [https://a.yandex-team.ru/review/2551740/files/3-4](https://a.yandex-team.ru/review/2551740/files/3-4)


В первом пункте рекомендуется прожать block merge, чтобы случайно не замержить.


## Контентные (динамические) UIDы

Локальная сборка работает в режиме [контетных UIDов](../../general/how_it_works#content_uids). В этом режиме она не перезапускает команды если результаты её команд-зависимостей не поменялись. Для этого используется дополнительное кэширование по контентному (динамическому) UID.

Режим отключается опцией `--no-content-uids` или настройкой `content_uids = false` в `ya.conf`.

Распределённая сборка имеет другую организацию кэшей и исполнения, данную опцию не поддерживает и молча её игнорирует.
Поскольку автосборка использует распределённую сборку, то в автосборке эта опция отключена. 

Использование контентных uid-ов видно в запуске с `--stat`

```
[=] ya make devtools/dummy_arcadia/test/content_uids_cache/simple/original --stat

Cache hit ratio is 71.43% (5 of 7). Local: 2 (28.57%), dist: 0 (0.00%), >>> by dynamic uids: 3 (42.86%) <<< `
. . .
[CC-DYN_UID_CACHE] - 6 ms.  <<<
[LD-DYN_UID_CACHE] - 2 ms.  <<<
```

## Локальная работа с тестами 

Локальный запуск тестов имеет ряд отличий от запуска в CI:

- По умолчанию локально результаты тестов не кэширутся. Т.е. независимо от изменений по команде `ya make -t` тесты будут запущены всегда.

- На данный момент локальный запуск тестов учитывает таймауты в соответствии с размером (1 минута для SMALL, 10 для MEDIUM, час для LARGE), но не ограничивает ресурсы в соответствии с `REQUIREMENTS`.

- По умолчанию локальная сборка производится в конфигурации `debug`, а в автосборке `relwithdebinfo` (релизная с ассёртами), поэтому поведение и производительность тестов может отличаться. Кроме этого, 
  в автосборке есть и другие отличия в конфигурации.

Результаты тестов локально складываются в директорию `test-results`, которая появляется символьной ссылкой в рабочей копии в директории теста (кроме Windows или флага `--no-src-links`).
Внутри находится директория `<suittype>/testing_out_stuff` в которой находятся логи тестов и прочие файлы, которые тесты порождают. 

При падении тестов на консоль также могут быть выданы пути из реальных директорий, в директории сборки, где тесты выполнялись. Чтобы эти данные были доступны после работы тестов,
сборочные директории где исполняются тесты чистятся не сразу, а при следующей сборке. Т.е. данные в такой директории доступны только до следующей сборки/запуска тестов.
Если данные могут вам понадобиться, скопируйте их.


#### Популярные рецепты

* `ya make -r` - собрать код c оптимизациями и отладочной информацией 
* `ya make -v` - собрать в verbose-режиме. **Обратите внимание:** `ya -v make` и `ya make -v` имеют разный эффект. Первая добавляет вывод утилиты `ya`, вторая — сборки.
* `ya make -T` - собрать, не перезатирая выполняемые команды в выводе
* `ya make --dist` - собрать код на кластере [распределённой сборки](ссылка)
* `ya make --add-result=".h" --add-result=".cpp"` - собрать, добавив в результаты сгенерированные в процессе сборки cpp- и h-файлы.
* `ya make --add-result=".pb.h" --add-result=".pb.cc" --replace-result`- запустить только кодогенерацию протобуфов.
* `ya make -t`  - запустить только быстрые тесты
* `ya make -tL` - вывести список быстрых тестов
* `ya make -A`  - запустить все тесты

## Платформы 

При сборке кода под платформой понимают аппаратную платформу (CPU, набор машинных инструкций, которые должны быть использованы в бинарном коде), операционную систему, на который должна работать программа, и программные средства, которые должны быть использованы для сборки (компилятор и т. п.). Система сборки ya make не исключение. Платформа для неё — это тройка <компилятор, OS, архитектура>, например <clang11, Windows, x86_64> или <clang10, Android, armv8a>.

По умолчанию в качестве целевой и сборочной платформ выбирается та, где запущена сборка. Т. е. в качестве операционной системы будет выбрана та, где вы работаете (Linux, Darwin (macOS) или Windows), в качестве архитектуры x86_64 или arm64 (для маков на процессоре m1), а в качестве компилятора будет использован вариант по умолчанию (default) для данной OS.

Поменять целевую платформу можно флагом `--target-platform`. В качестве значения нужно указать тройку <компилятор, OS, архитектура>, соединив значения через дефис. Также можно указать какое-то подмножество компонент этой тройки (остальные элементы подставятся по умолчанию). Для выбора компилятора по умолчанию можно указать специальное значение DEFAULT.

Примеры:

`--target-platform clang-win-x86_64` — собрать по Intel 64bit Windows компилятором Clang;
`--target-platform default-android-armv8a` — собрать под Android на ARM (в версии armv8a) компилятором по умолчанию;
`--target-platform windows` — собрать под Windows (и архитектуру по умолчанию x86-64) компилятором по умолчанию.

