# ya make: основной сборочный инструмент

Команда утилиты `ya`, которая позволяет  компилировать код, управлять зависимостями, запускать тесты и генерировать исполняемые файлы в едином и согласованном окружении независимо от сложности проекта.

`ya make` позволяет очень гибко настраивать параметры сборки. Список настраиваемых возможностей включает:

- Выбор типа и вида сборки](ссылка) — debug/release, LTO, sanitizers и т. п.
- Параметры платформ](ссылка) — целевые аппаратная платформа и OS, настройки сборочной платформы и т. п.
- Установку сборочных переменных](ссылка) — Например, `-DCFLAGS=-Wall`, `-DDEBUGINFO_LINES_ONLY` и т. п.
- Настройки сборки](ссылка) - выбор дополнительных результатов сборки и т. п.
- Запуск и работу с тестами](ссылка)

## Синтаксис

Ознакомтесь с возможностями сборки: `ya make  -h, --help`  печатает справку . Используйте `-hh` для большего количества опций и `-hhh` для ещё большего.

С описанием всех функций можно ознакомится по [ссылке](helpfilemake.md)

### Общая форма команды

`ya make [OPTIONS]… [TARGET]…`

`[OPTIONS]` обозначает одну или несколько опций команды, предназначенных для изменения поведения сборки или тестирования. Опции могут управлять такими параметрами, как тип сборки (например, отладочный или релиз), применение оптимизации, использование инструментов анализа кода и многое другое.

`[TARGET]…` указывает на одну или несколько целей сборки. Целью может быть конкретный модуль в проекте, директория, содержащая компоненты для сборки, или специально заданный аргумент, определяющий действие (например, запуск тестов). Если цель не указана, ya make обычно выполняет сборку всего проекта, начиная с текущего каталога.

## Опции

Для систематизации многообразия опций, сделать информацию о них более доступной для пользователей опции можно разбить на следующие основные категории:

1.	Основные опции
2.	Селективное извлечение (Selective checkout)
3.	Опции сборки
4.	Опции Java - сборки
5.	Опции оптимизации
6.	Опции тестирования
7.	Опции вывода и логирования
8.	Опции кеширования
9.	Интеграция с внешними ресурсами
10.	Фаззинг
11.	Опции авторизации

Также опции разделяют по типам:

1.	Основные
2.	Расширенные 
3.	Экспертные

### Основные опции

**Основные:**
* `--rebuild`  - Указывает команде `ya make` игнорировать результаты предыдущих сборок и начать процесс сборки с нуля.
  Это может быть полезно в случаях, когда кэшированные результаты повреждены или когда требуется полная пересборка проекта для устранения несоответствий.
* `-C=BUILD_TARGETS`, `--target=BUILD_TARGETS` - Используется для указания конкретных целей сборки, которые должны быть построены или обработаны. В этом контексте “цель сборки” (BUILD_TARGET) относится к конкретному продукту сборки, например, исполняемому файлу, статической либо динамической библиотеке, которые генерируются в результате процесса компиляции и связывания исходного кода. 
Опция полезна в случаях, когда вам необходимо собрать не весь проект целиком, а только определенные его части. Это может быть необходимо, например, для экономии времени при разработке, когда изменения вносятся лишь в один модуль, или когда нужно собрать только определенные библиотеки или исполняемые файлы для дистрибутива.
Это особенно актуально в больших проектах с множеством компонентов и сложной структурой зависимостей.
* `-k`, `--keep-going` - Инструктирует инструмент продолжать процесс сборки даже после возникновения ошибок в одной из целей сборки. По умолчанию, когда процесс сборки сталкивается с ошибкой, он немедленно прекращается, чтобы пользователь мог исправить обнаруженные проблемы. Опция --keep-going изменяет это поведение, позволяя сборке продолжиться и пытаться построить как можно больше целей, несмотря на ошибки в других частях проекта.  
Использование `-k` или `--keep-going` может быть полезно в нескольких случаях:
  1. Определение всех ошибок: В больших проектах может быть удобно увидеть все ошибки компиляции за один проход сборки, чтобы исправить их одновременно, вместо того чтобы делать это по одной ошибке за раз.
  2. Сборка независимых компонентов: При работе над большим проектом, разбитым на модули или подсистемы, которые могут собираться независимо, опция `--keep-going` позволяет завершить сборку тех частей проекта, которые не затрагиваются текущими ошибками.
  3. Автоматизация: В сценариях автоматической сборки и тестирования может быть полезно собрать как можно больше компонентов, даже если некоторые из них не могут быть собраны из-за ошибок, чтобы затем автоматически запустить тесты на успешно собранных целях.
При использовании `-k` или `--keep-going`, сборка всё равно завершится с ошибкой, если были обнаружены проблемы. Однако, в процессе будут сделаны все возможные попытки построить другие цели сборки, которые не зависят от возникших ошибок.
*	`-j=BUILD_THREADS`, `--threads=BUILD_THREADS` Опция используется для указания количества потоков сборки, которые должны быть задействованы в процессе компиляции и сборки проекта. По умолчанию используется значение 2, т.е. процесс сборки должен использовать 2 параллельных потока или “ядра”. Это означает, что до 2 задач сборки (например, компиляции различных частей проекта) могут выполняться одновременно, что может значительно ускорить общее время сборки, особенно на многоядерных процессорах. 
Параллелизм сборки позволяет более эффективно использовать ресурсы современных многоядерных процессоров, уменьшая время, необходимое для компиляции больших или сложных проектов.
В идеале, количество потоков сборки должно соответствовать количеству ядер процессора, на котором выполняется сборка, хотя в некоторых случаях может быть полезно задать значение больше или меньше, в зависимости от характеристик проекта и доступной оперативной памяти.
Необходимо помнить, что некоторые задачи, такие как линковка (связывание), могут быть ограничены одним потоком и не получат преимущества от запуска в параллельном режиме.
*	`--clear` Очистить временные данные. Опция используется для указания на необходимость удаления временных данных, созданных в процессе работы. Такие временные данные могут включать объектные файлы, промежуточные результаты компиляции, кэшированные данные и любые другие файлы или директории, которые генерируются инструментом в процессе его выполнения, но не требуются после завершения работы или в начале новой сборки. Использование опции --clear может быть полезно в нескольких случаях:
    1. Освобождение места на диске: Временные файлы, особенно в больших проектах, могут занимать значительный объем дискового пространства. Их удаление помогает управлять доступным пространством на диске.
    2. Предотвращение конфликтов: В некоторых ситуациях оставшиеся от предыдущих сборок временные файлы могут вызвать проблемы или конфликты при последующих сборках. Очистка гарантирует, что каждая сборка начинается в “чистом” окружении.
    3. Убедительность результата: Пользователи могут использовать --clear для того, чтобы убедиться, что все результаты сборки актуальны и были получены из текущего состояния исходного кода, без остаточных данных предыдущих процессов сборки.

**Расширенные опции:**

* --sandboxing Выполнить команду в изолированном корне исходного кода - Не описываем (разработчикам в комментарии)
* `--link-threads=LINK_THREADS` Количество потоков для линковки (по умолчанию: 0)
* `--no-clonefile` Отключить опцию clonefile
* `--nice=SET_NICE_VALUE` Установить значение nice для процессов сборки (по умолчанию: 10)
* `--warning-mode=WARN_MODE` Режим предупреждений

**Опции для экспертов**
--fetcher-params=FETCHER_PARAMS_STR Приоритеты и параметры загрузчиков
-B=CUSTOM_BUILD_DIRECTORY, --build-dir=CUSTOM_BUILD_DIRECTORY
Пользовательская директория сборки (определяется автоматически по умолчанию)
--force-use-copy-instead-hardlink-macos-arm64 Использовать копирование вместо хардлинка, когда clonefile недоступен
--no-content-uids Отключить дополнительный кэш на основе UIDов, основанных только на содержимом
--keep-temps Не удалять временные корни сборки. Выводить рабочий каталог теста в stderr (используйте --test-stderr, чтобы убедиться, что он выводится в начале теста)

###  Селективное извлечение (Selective checkout)
Selective checkout (селективное извлечение) используется в разработке программного обеспечения для оптимизации процесса извлечения кода из системы управления версиями (например, Git) в процессе сборки или развертывания. 
Основная цель селективного извлечения заключается в том, чтобы извлекать из репозитория только те части кода, которые действительно необходимы для текущей задачи или сборки, что позволяет сократить время и ресурсы, необходимые для этого процесса.
**Расширенные опции**
--prefetch Предзагрузка директорий, необходимых для сборки
--no-prefetch Не предзагружать директории, необходимые для сборки
Опции для экспертов
--thin Извлечение минимального скелета


