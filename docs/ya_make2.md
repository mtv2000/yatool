# ya make: основной сборочный инструмент

Система сборки `ya make` –  основная команда утилиты  `ya`, обеспечивающее автоматизацию сборки проекта, которая позволяет  компилировать код, управлять зависимостями, запускать тесты и генерировать исполняемые файлы в едином и согласованном окружении независимо от сложности проекта.

Чтобы подробно обсудить структуру и процесс работы нашей системы сборки, важно сначала познакомиться с рядом специфических терминов и концепций, которые мы будем использовать. Это поможет лучше понять, как функционирует система и какие преимущества она предоставляет.

Давайте начнем с основных терминов:
1. Сборочная цель (модуль): Программа, библиотека или пакет, которые будут собираться. Она может быть интерпретирована как конкретный результат сборки (артефакт) или как описание сборки, заданное в файле `ya.make`.
2. Артефакт - реальный результат сборки, такой как файл программы или библиотеки, либо директория с файлами пакета.
3. Описание сборки: Файл`ya.make`, который содержит инструкции по сборке программы, библиотеки или пакета.
4. Символьная ссылка: Специальный тип файла, который ссылается на другой файл или директорию.
5. Мультимодули: Специальные сборочные цели, которые могут создавать разные артефакты в зависимости от контекста их использования.
6. Промежуточный модуль: Библиотека или иной компонент, используемый для сборки финальных модулей. Промежуточные модули не предназначены для самостоятельного использования.
7. Финальный модуль: Программа, динамическая библиотека, тест или другой артефакт, который может исполняться и использоваться самостоятельно.
8. UID (Unique Identifier): Уникальный идентификатор для каждой сборочной команды, основанный на всех факторах, влияющих на её результат.
9. Герметичность сборки: Принцип, согласно которому сборка зависит только от данных, известных системе сборки, и не зависит от внешних факторов или файлов, не фиксированных в конфигурации сборки.
10. Конфигурирование: Процесс анализа зависимостей и построения графа сборочных команд в системе `ya make`.
11. Граф сборочных команд: Структура данных, представляющая зависимости между сборочными командами. В узлах графа расположены команды, а ребра указывают на порядок выполнения команд.
12. Макрос: Инструкция в `ya.make`, которая описывает конкретные аспекты сборки, такие как исходный код, зависимости, а также управляет логикой интерпретации файла.
13. PEERDIR: Макрос, указывающий на межмодульную зависимость; говорит системе сборки, что для сборки текущей цели необходима другая сборочная цель.
14. RECURSE/RECURSE_FOR_TESTS: Макросы, используемые для того, чтобы включить одно или несколько сборочных целей в текущий сборочный процесс.

Со всеми базовыми определениями и принципами системы сборки можно ознакомится в соответствующем разделе [документации](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_principle.md)

`ya make` позволяет очень гибко настраивать параметры сборки. Список настраиваемых возможностей включает:

- [Выбор типа и вида сборки](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_buildtype.md) — debug/release, LTO, sanitizers и т. п.
- [Параметры платформ](#Кросс-компиляция) — целевые аппаратная платформа и OS, настройки сборочной платформы и т. п.
- [Установку сборочных переменных](#Сборочные-переменные) — Например, `-DCFLAGS=-Wall`, `-DDEBUGINFO_LINES_ONLY` и т. п.
- Настройки сборки - выбор дополнительных результатов сборки и т. п.
- [Запуск и работу с тестами](#Локальная-работа-с-тестами) 

## Синтаксис

Ознакомтесь с возможностями сборки: `ya make  -h, --help`  печатает справку . Используйте `-hh` для большего количества опций и `-hhh` для ещё большего.

Со встроенной справкой можно также ознакомиться по [ссылке](helpfilemake.md)

### Общая форма команды

`ya make [OPTIONS]… [TARGET]…`

`[OPTIONS]` обозначает одну или несколько опций команды, предназначенных для изменения поведения сборки или тестирования. Опции могут управлять такими параметрами, как тип сборки (например, отладочный или релиз), применение оптимизации, использование инструментов анализа кода и многое другое.

`[TARGET]…` указывает на одну или несколько целей сборки. Целью может быть конкретный модуль в проекте, директория, содержащая компоненты для сборки, или специально заданный аргумент, определяющий действие (например, запуск тестов). Если цель не указана, ya make обычно выполняет сборку всего проекта, начиная с текущего каталога.

## Опции

Для систематизации многообразия опций, сделать информацию о них более доступной для пользователей опции можно разбить на следующие основные категории:

1.	Основные опции
2.	Опции сборки
3.	Опции Java - сборки
4.	Опции оптимизации
5.	Опции тестирования
6.	Опции вывода и логирования
7.	Опции кеширования
8.	Интеграция с внешними ресурсами
9.	Фаззинг
10.	Опции авторизации

Также опции разделяют по типам:

1.	Основные
2.	Расширенные 
3.	Экспертные

Полный список основных опций и примеры их использования можно найти в этой [документации](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_options.md).

Система сборки предлагает широкие возможности для тестирования, полный перечень опций и их описание можно найти [здесь](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_test.md).

### Опции сборки

Настройки сборки в ya make позволяют детально управлять процессом сборки проекта, оптимизировать его для разных сценариев использования и достичь требуемого баланса между скоростью сборки и требованиями к качеству исходного кода. 

Основные опции:

* `-d, --debug`
Опция `-d` или `--debug` активирует сборку в режиме отладки. В этом режиме компилятор включает отладочную информацию в генерируемые исполняемые файлы и снижает уровень оптимизации кода, что делает процесс отладки приложения более удобным и эффективным за счет улучшенной интерпретации и отслеживания ошибок.

* `-r, --release`
Использование флага `-r` или `--release` инициирует сборку проекта в режиме релиза. В этом режиме команда сосредоточена на оптимизации исполняемого кода для достижения максимальной производительности приложения, часто за счет размера выпускной версии и отсутствия отладочной информации.

* `-v, --verbose`
Флаг `-v` или `--verbose` инициирует подробный режим вывода, благодаря которому становится доступной дополнительная информация о процессе сборки. Подробный вывод может быть полезен для диагностики и устранения проблем, связанных со сборкой проекта.

* `--rebuild`
Опция `--rebuild` указывает команде `ya make` игнорировать результаты предыдущих сборок и начать процесс сборки с нуля.

Данная версия `ya make` поддерживает только локальную версию сборки. Планируется добавить распределенную сборку, для чего зарезервирована опция `--dist`.

### Локальная сборка ya make

Локальная сборка — это процесс сборки проекта, выполняемый непосредственно на машине разработчика. Эта опция идеально подходит для небольших проектов или в ситуациях, когда необходима быстрая итерация в процессе разработки.

Особенности локальная сборки:

- [Сборочные директории и файлы](#Директории-и-файлы)
- [Контентные UIDы](#Контентные-UIDы)
- [Локальная работа с тестами](#Локальная-работа-с-тестами)

#### Директории и файлы 

Директории, которые использует локальная сборка настраиваются следующими ключами:

- `-S=CUSTOM_SOURCE_ROOT`, `--source-root=CUSTOM_SOURCE_ROOT` — путь до проекта из которой производить сборку. По умолчанию определяется автоматически по текущему пути, в котором запущена команда `ya make`.
- `-B=CUSTOM_BUILD_DIRECTORY`, `--build-dir=CUSTOM_BUILD_DIRECTORY` — корень сборочных директорий. Каждая сборочная команда исполняется в собственной директории, поэтому задаётся корень для всех таких директорий. По умолчанию эти директории размещаются внутри `~/.ya/build/`

Директории для результатов сборки можно указать следующими параметрами:

- `-o=OUTPUT_ROOT`, `--output=OUTPUT_ROOT` — путь, куда будут сложены результаты сборки (на Linux и macOS будут использованы хардлинки). Результаты будут размещены по путям.
- `I=INSTALL_DIR`, `--install=INSTALL_DIR` — **не рекомендуется** путь, куда будут сложены результаты сборки. Результаты будут сложены непосредственно в указанную директорию.

При локальной сборке можно переопределить куда будут складываться лог сборки и лог событий.

- `--log-file=LOG_FILE` — добавлять подробный лог к указанному файлу. По умолчанию на каждую сборку создаётся свой лог внутри `~/.ya/logs/`
- `--evlog-file=EVLOG_FILE` — записать лог событий в указанный файл. По умолчанию на каждую сборку создаётся свой лог внутри `~/.ya/evlogs/`

#### Контентные UIDы

Локальная сборка работает в режиме [контетных UIDов](https://github.com/mtv2000/yatool/blob/newstyle/docs/UIDwork.md)

В этом режиме она не перезапускает команды если результаты её команд-зависимостей не поменялись. Для этого используется дополнительное кэширование по контентному (динамическому) UID.

Режим отключается опцией `--no-content-uids` или настройкой `content_uids = false` в `ya.conf`.

[О генерация конфигурационного файла инструмента(https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_conf.md)

Использование контентных uid-ов видно в запуске с `--stat`

```
[=] ya make path/test/content_uids_cache/simple/original --stat

Cache hit ratio is 71.43% (5 of 7). Local: 2 (28.57%), dist: 0 (0.00%), >>> by dynamic uids: 3 (42.86%) <<< `
. . .
[CC-DYN_UID_CACHE] - 6 ms.  <<<
[LD-DYN_UID_CACHE] - 2 ms.  <<<
```

#### Локальная работа с тестами 

Полный перечень опций тестирования и их описание можно найти [здесь](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_test.md).

По умолчанию локально результаты тестов не кэширутся.

На данный момент локальный запуск тестов учитывает таймауты в соответствии с размером (1 минута для SMALL, 10 для MEDIUM, час для LARGE), но не ограничивает ресурсы в соответствии с `REQUIREMENTS`.

По умолчанию, локальная сборка производится в конфигурации `debug`, а в автосборке `relwithdebinfo` (релизная с ассёртами), поэтому поведение и производительность тестов может отличаться. 

Результаты тестов локально складываются в директорию `test-results`, которая появляется символьной ссылкой в рабочей копии в директории теста (кроме Windows или при использовании флага `--no-src-links`).

Внутри находится директория `<suittype>/testing_out_stuff` в которой находятся логи тестов и прочие файлы, которые тесты порождают. 

Если тесты не прошли успешно, в консоль может быть выведена информация о путях в реальных директориях внутри сборочного каталога, где выполнялись тесты. Чтобы сохранить эти данные после завершения тестов, сборочные директории не очищаются сразу, а только при следующем запуске сборки. Таким образом, данные в этих каталогах доступны до следующей сборки или запуска тестов. Если вам необходимо сохранить эти данные, скопируйте их заранее.

##### Запуск тестов (-t, -tt, -ttt, -A)

- `-t`: Эта базовая опция запускает все тесты, отмеченные как “маленькие” (SMALL). Это быстрые тесты, обычно требующие мало ресурсов и времени для выполнения.

- `-tt`: Расширение базовой опции `-t`, которое включает в себя запуск тестов как “маленьких”, так и “средних” (MEDIUM) размеров. Средние тесты обычно занимают больше времени и ресурсов.

- `-ttt`: Данная опция запускает тесты всех размеров, включая “большие” (LARGE). Большие тесты часто включают в себя интеграционные и нагрузочные тесты, требующие значительного времени для выполнения и могут включать внешние зависимости.

- `-A, --run-all-tests`: Аналогично `-ttt`, запускает все тесты независимо от размера.

##### Управление выводом результатов

- `-L, --list-tests`: Выводит список тестов, которые будут выполнены, без их фактического запуска. Помогает разработчикам быстро проверить, какие тесты включены в план тестирования.

- `–fail-fast`: Прекращает выполнение тестового прогона сразу после первой встреченной неудачи. Эта опция полезна для экономии времени и ресурсов, особенно когда разработчики ищут конкретную ошибку.

##### Выборочное тестирование

- `–test-filter=TESTS_FILTERS`: Эта опция позволяет ограничить тестирование только определенными тестами, соответствующими указанным фильтрам. Это может быть имя теста, его часть или другой идентифицирующий шаблон.

- `–test-tag=TEST_TAGS_FILTER`: Позволяет запускать только те тесты, которые помечены определенными тегами. Теги — это пользовательские метки, которые могут быть нанесены на тесты для их группировки по определенным признакам или функциональности.

- `–test-size=TEST_SIZE_FILTERS`: Фильтр для запуска тестов определенного размера (SMALL, MEDIUM, LARGE), позволяющий более точно настроить объем запускаемых тестов в зависимости от текущих потребностей.

- `–test-type=TEST_TYPE_FILTERS`: Ограничивает запуск только теми тестами, которые относятся к указанным типам (например, UNITTEST, PYTEST). Удобно при необходимости проведения специфичных видов тестирования.

## Кросс-компиляция

При сборке кода под платформой понимают аппаратную платформу (CPU, набор машинных инструкций, которые должны быть использованы в бинарном коде), операционную систему, на который должна работать программа, и программные средства, которые должны быть использованы для сборки (компилятор и т. п.). Система сборки ya make не исключение. Платформа для неё — это тройка <компилятор, OS, архитектура>, например <clang11, Windows, x86_64> или <clang10, Android, armv8a>.

По умолчанию в качестве целевой и сборочной платформ выбирается та, где запущена сборка. Т. е. в качестве операционной системы будет выбрана та, где вы работаете (Linux, Darwin (macOS) или Windows), в качестве архитектуры x86_64 или arm64 (для маков на процессоре m1), а в качестве компилятора будет использован вариант по умолчанию (default) для данной OS.

Поменять целевую платформу можно флагом `--target-platform`. В качестве значения нужно указать тройку <компилятор, OS, архитектура>, соединив значения через дефис. Также можно указать какое-то подмножество компонент этой тройки (остальные элементы подставятся по умолчанию). Для выбора компилятора по умолчанию можно указать специальное значение DEFAULT.

Примеры:

`--target-platform clang-win-x86_64` — собрать по Intel 64bit Windows компилятором Clang;
`--target-platform default-android-armv8a` — собрать под Android на ARM (в версии armv8a) компилятором по умолчанию;
`--target-platform windows` — собрать под Windows (и архитектуру по умолчанию x86-64) компилятором по умолчанию.

## Сборочные переменные

В команде `ya make` можно указать дополнительные флаги (переменные) с помощью опции `-DVAR[=VALUE]`. Если не указывать значение переменной, по умолчанию оно будет выставлено в yes.

Можно определить:

Предопределённые переменные, позволяющие передать флаги для сборки `ya make` `-DLDFLAGS="-fblabla=foo -fbar"`, `ya make -DCFLAGS="-DNN_DOUBLE_PRECISION -Wno-strict-aliasing"`.
Предопределённые переменные, управляющие конфигурацией, например `ya make -DCATBOOST_OPENSOURCE` (сборка как для open source) или `ya make -DCUDA_VERSION=10.1` (сборка с CUDA).
Переменные для использования в `ya.make` `ya make -DMACRO1 -DMACRO2=42`, где в `ya.make` написано, например `IF (MACRO1)`.
Список доступных переменных достаточно большой и часто меняется. Самые часто используемые переменные можно найти в соответствующих разделах [руководства по системе сборки](https://github.com/mtv2000/yatool/blob/newstyle/docs/ya_make_yamake.md)

### Популярные рецепты

* `ya make -r` - собрать код c оптимизациями и отладочной информацией 
* `ya make -v` - собрать в verbose-режиме. **Обратите внимание:** `ya -v make` и `ya make -v` имеют разный эффект. Первая добавляет вывод утилиты `ya`, вторая — сборки.
* `ya make -T` - собрать, не перезатирая выполняемые команды в выводе
* `ya make --dist` - собрать код на кластере [распределённой сборки](ссылка)
* `ya make --add-result=".h" --add-result=".cpp"` - собрать, добавив в результаты сгенерированные в процессе сборки cpp- и h-файлы.
* `ya make --add-result=".pb.h" --add-result=".pb.cc" --replace-result`- запустить только кодогенерацию протобуфов.
* `ya make -t`  - запустить только быстрые тесты
* `ya make -tL` - вывести список быстрых тестов
* `ya make -A`  - запустить все тесты
