## Основные опции `ya make`

### Основные опции

**Основные:**

* Опция `--rebuild` применяется командой `ya make` для выполнения полной пересборки проекта, игнорируя все ранее сгенерированные результаты. 
Удаляются все промежуточные и итоговые файлы, созданные во время прошлых процессов сборки, чтобы исключить влияние устаревших или некорректных данных на новую сборку.

В результате использования опции  `--rebuild` гарантируется, что все составные части проекта будут скомпилированы заново, что способствует исключению ошибок, связанных с конфликтами или несогласованностями в файлах, и обеспечивает точное соответствие текущего состояния исходного кода скомпилированным компонентам. Служит инструментом качества и поддержания валидности разработки.
* Опции `-C=BUILD_TARGETS`, `--target=BUILD_TARGETS`  применяются, для установки конкретных целей сборки, указанных в файле ya.make и задаваемых значением `BUILD_TARGETS`.

Актуально в больших проектах с множеством компонентов и сложной структурой зависимостей, как один из спобов описать цель для сборки.
* Опции `-k`, `--keep-going` - служат для поддержания процесса сборки активным, даже если некоторые цели сборки не удается выполнить из-за ошибок. По умолчанию, когда процесс сборки сталкивается с ошибкой, он немедленно прекращается, чтобы пользователь мог исправить обнаруженные проблемы. Опции `-k` или `--keep-going` изменяют это поведение, позволяя сборке продолжиться и пытаться построить как можно больше целей, несмотря на ошибки в других частях проекта.

При использовании `-k` или `--keep-going`, сборка всё равно завершится с ошибкой, если были обнаружены проблемы. Однако, в процессе будут сделаны все возможные попытки построить другие цели сборки, которые не зависят от возникших ошибок.
* Параметры `-j=BUILD_THREADS`, `--threads=BUILD_THREADS`  используются для указания число рабочих потоков сборки, которые должны быть задействованы в процессе сборки проекта, соответственно ресурсам вашего процессора. Рекомендуется устанавливать количество потоков, равное количеству ядер вашего процессора, чтобы оптимизировать процедуру сборки
При отсутствии явных указаний используется два потока сборки по умолчанию, и один поток при включении опции --lto. Это позволяет запускать до двух сборочных операций параллельно, что может существенно сократить общее время, необходимое для сборки проекта.
* `--clear` Очистить временные данные. Опция используется для указания на необходимость удаления временных данных, созданных в процессе работы. Такие временные данные могут включать объектные файлы, промежуточные результаты компиляции, кэшированные данные и любые другие файлы или директории, которые генерируются инструментом в процессе его выполнения, но не требуются после завершения работы или в начале новой сборки. Использование опции --clear может быть полезно в нескольких случаях:
  1. Освобождение места на диске: Временные файлы, особенно в больших проектах, могут занимать значительный объем дискового пространства. Их удаление помогает управлять доступным пространством на диске.
  2. Предотвращение конфликтов: В некоторых ситуациях оставшиеся от предыдущих сборок временные файлы могут вызвать проблемы или конфликты при последующих сборках. Очистка гарантирует, что каждая сборка начинается в “чистом” окружении.
  3. Убедительность результата: Пользователи могут использовать --clear для того, чтобы убедиться, что все результаты сборки актуальны и были получены из текущего состояния исходного кода, без остаточных данных предыдущих процессов сборки.

**Расширенные опции:**

* --sandboxing Выполнить команду в изолированном корне исходного кода

* `--link-threads=LINK_THREADS` Количество потоков для линковки (по умолчанию: 0)
  Линковка — это процесс, при котором различные модули и библиотеки, сгенерированные в ходе компиляции, объединяются в один исполняемый файл или библиотеку
  Опция  используется для указания количества потоков (или параллельных задач), которые должны быть задействованы в процессе линковки (связывания) исполняемых файлов и/или библиотек.
  При локальной сборке линковки запускают в параллель не больше 2х в обычном режиме и не больше одной в режимах `--lto/--thinlto` (Link-time optimization — режим, в котором вся компиляция происходит во время линковки для более глубокой оптимизации кода).

* `--no-clonefile` Отключить опцию clonefile
  Клонирование файлов — это процесс, при котором создаётся новый файл, который на уровне файловой системы использует те же блоки данных на диске, что и исходный файл (hardlink). Этот процесс позволяет избежать дублирования данных при копировании, экономя место на диске и время на операцию копирования. Фактические данные копируются только тогда, когда в одном из клонированных файлов происходят изменения.
  Отключение `clonefile` необходимо в ситуациях, когда требуется гарантировать физическое разделение копий файлов на уровне блоков диска для обеспечения полной изоляции копий файлов друг от друга.

* `--nice=SET_NICE_VALUE` Установить значение nice для процессов сборки (по умолчанию: 10)
  Опция  предназначена для управления приоритетом процессов сборки в операционной системе. Данная опция позволяет настроить, с каким приоритетом будут работать процессы сборки, тем самым влияя на распределение ресурсов процессора между процессами сборки и другими задачами, выполняющимися на машине.
  В Linux и других UNIX-подобных операционных системах значение “nice” определяет приоритетность процесса: чем выше значение, тем ниже приоритет выполнения. Это означает, что процессы с более высоким значением nice будут уступать ресурсы процессора другим процессам с более низким значением.
  Опция особенно полезна в средах, где необходимо одновременно выполнять компиляцию больших проектов и важные задачи, требующие высокой отзывчивости системы. Например, на серверах сборки, обслуживающих множество проектов, или на рабочих станциях разработчиков, которые продолжают работать над кодом, в то время как идет процесс сборки.

* `--warning-mode=WARN_MODE` Режим предупреждений
  Опция позволяет настраивать, как система сборки должна реагировать на различные предупреждения, возникающие в процессе сборки.
  Общие значения для WARN_MODE могут включать:

* `all` - Выводить все предупреждения. Этот режим полезен для максимального контроля качества кода, обеспечивая, что каждое предупреждение будет рассмотрено и обработано разработчиком.

**Опции для экспертов**

* --fetcher-params=FETCHER_PARAMS_STR Приоритеты и параметры загрузчиков
  Опция служит для указания дополнительных параметров  отвечающих за загрузку (фетчинг) данных, зависимостей, кода и других ресурсов из внешних источников.
  Строка `FETCHER_PARAMS_STR`  представляет собой список ключ=значение параметров, разделенных символами, удобными для разбора (как запятые, пробелы или другие).
  Например: `--fetcher-params="mirror=http://example.com,mirror.priority=100,use_proxy=true".`
* `-B=CUSTOM_BUILD_DIRECTORY`, `--build-dir=CUSTOM_BUILD_DIRECTORY` Пользовательская директория сборки (определяется автоматически по умолчанию)
  Опции для указания пользовательской директории сборки, вместо использования стандартной или автоматически определяемой директории. Каждая сборочная команда исполняется в собственной директории, поэтому задаётся корень для всех таких директорий. По умолчанию эти директории размещаются внутри `~/.ya/build/`
  В некоторых случаях разработчикам может потребоваться изменить стандартное местоположение по разным причинам, например:
  * Для разделения исходного кода и артефактов сборки на разные дисковые разделы или устройства для улучшения производительности.
  * Для удобства управления артефактами сборки, особенно когда требуется легко очищать сборку, не затрагивая исходный код.
  * Для создания нескольких конфигураций сборки в рамках одного проекта (например, отладочной и релизной), каждая из которых будет храниться в своей собственной директории
* `--force-use-copy-instead-hardlink-macos-arm64` Использовать копирование вместо хардлинка, когда clonefile недоступен.
  Опция представляет собой специфический параметр, который может быть использован при сборке, работающей на архитектуре macOS с процессорами ARM64.
  Этот параметр указывает использовать операцию копирования файлов вместо создания жёстких ссылок (hard links), в ситуациях, когда невозможно использовать clonefile.
  Опция является очень специфической и её применение должно быть оправдано конкретными требованиями процесса сборки или развертывания в среде macOS на ARM64.
* `--no-content-uids` Отключить дополнительный кэш на основе UIDов, основанных только на содержимом.
  Опция предназначена для отключения использования специфического кэша, который строится на  уникальных идентификаторах (UID), генерируемых на основе графа команд.
  UIDы используются для эффективного управления кэшом и определения необходимости пересборки конкретных частей проекта. Основываясь на содержимом, такой кэш позволяет оптимизировать процесс сборки, выполняя пересборку только тех частей проекта, которые действительно изменились, исходя из изменений в их UID, связанных с содержимым.
  Отключение кэша на основе UIDов может быть целесообразным в определенных сценариях, таких как:
  * Тестирование и отладка: Когда разработчику необходимо убедиться, что все компоненты проекта собираются с нуля, чтобы исключить влияние кэширования на процесс сборки.
  * Инициализация чистой среды: В новых или временных средах сборки, где не требуется экономия времени сборки за счет кэширования.
  * Решение конфликтов: Когда в проекте возникли проблемы, связанные с кэшем, и нужно временно обойтись без него для их диагностики и устранения.
    Иногда, в случае проблем может потребоваться полная пересборка с удалением кэша или --rebuild.
    Ознакомится с информацией как строится и исполняется сборочный граф
* `--keep-temps` Не удалять временные корни сборки. Выводить рабочий каталог теста в stderr (используйте --test-stderr, чтобы убедиться, что он выводится в начале теста)
  Опция указывает на необходимость сохранения временных файлов и директорий, создаваемых в процессе сборки или выполнения тестов. Эти временные файлы могут включать промежуточные артефакты, логи компиляции, выходные данные тестов и другие файлы, которые обычно удаляются после успешного завершения сборки или тестирования для освобождения дискового пространства. Позволяет разработчикам и тестировщикам (инженерам по качеству) детально проанализировать эти файлы для диагностики ошибок, оптимизации процесса сборки и улучшения качества кода.
  Использование опции `--test-stderr` в сочетании с `--keep-temps` подчеркивает важность анализа вывода процессов. `--test-stderr` гарантирует, что `stderr` теста будет выведен в начале его выполнения, что может быть полезно для быстрого обнаружения и устранения ошибок, особенно в сочетании с сохранением временных файлов.

  {% cut "--add-result=ADD_RESULT - Process selected build output as a result" %}

\--add-result=ADD_RESULT Обработать выбранный вывод сборки как результат

Опция --add-result=ADD_RESULT предназначена для управления результатами, выдаваемыми системой сборки. Она дает возможность точно определить, какие файлы следует включать в итоговый набор результатов.

Этот параметр оказывается особенно полезным, когда возникает потребность в просмотре или анализе кода файлов, сгенерированных в ходе сборки.

Примеры

* `ya make --add-result=".h"`  `--add-result=".cpp"` - собрать, добавив в результаты сгенерированные в процессе сборки cpp- и h-файлы.
* `ya make --add-result=".pb.h"` `--add-result=".pb.cc"` `--replace-result` - запустить только кодогенерацию протобуфов.

Чтобы посмотреть код сгенерированных файлов можно давить флаг `--add-result .pb.gw.go`

{% endcut %}

{% cut "--add-protobuf-result -  Process protobuf output as a result" %}

\--add-protobuf-result Обработать вывод protobuf как результат

Опция `--add-protobuf-result` позволяет системе сборки явно  получить сгенерированный исходный код `Protobuf` для соответствующих языков программирования.

[Protobuf](https://protobuf.dev/) предоставляют эффективный и удобный способ описания структурированных данных, который не привязан к конкретному языку программирования или платформе.

Они позволяют определить структуру данных в специальном формате `.proto`, после чего можно автоматически генерировать код для сериализации и десериализации этих данных на поддерживаемых языках программирования, таких как C\+\+, Java, Python и других.

{% endcut %}

{% cut "--add-flatbuf-result - Process flatbuf output as a result" %}

\--add-flatbuf-result Обработать вывод flatbuf как результат

Опция `--add-flatbuf-result` предназначена для того, чтобы система сборки могла  автоматически получить сгенерированный исходный код выходных файлов FlatBuffers (flatc) для соответствующих языков программирования

[FlatBuffers](https://flatbuffers.dev/) - это сериализационная система, разработанная для обеспечения высокой производительности и эффективности при работе с структурированными данными, позволяя оперировать данными прямо в бинарном формате без необходимости предварительного парсинга или десериализации. Это делает FlatBuffers особенно подходящим для приложений, где требуется минимизация задержек и перерасхода памяти, например, в встроенных системах, играх, или приложениях реального времени.

{% endcut %}

{% cut "--replace-result - Build only --add-result targets" %}

\--replace-result Собирать только цели, указанные в --add-result

Опция `--replace-result` применяется в системах сборки для чёткого ограничения процесса компиляции объектами, определёнными в параметре `--add-result`. С ее помощью система будет собирать исключительно те элементы, которые были явно указаны в `--add-result`, исключая все остальные составные части проекта, такие как библиотеки или исполняемые файлы программ.

Это полезно в случаях, когда необходимо осуществить сборку только определённых генерируемых файлов, что может значительно уменьшить общее время сборки.

{% endcut %}

{% cut "--force-build-depends - Build by DEPENDS anyway" %}

\--force-build-depends Принудительно собирать зависимости, указанные в `DEPENDS`

Опция `--force-build-depends` специально разработана для того, чтобы обеспечить комплексную подготовку к тестированию за счет принудительной сборки всех зависимостей, объявленных в `DEPENDS`.

Это означает, что даже если некоторые из этих зависимостей не требуют обновления в обычном режиме сборки, они будут собраны заново для гарантирования актуальности тестового окружения. При этом непосредственно само тестирование не проводиться .

Таким образом, перед выполнением тестов разработчик получает возможность убедиться в том, что все компоненты системы находятся в последних версиях и совместимы между собой.

{% endcut %}

{% cut "-R, --ignore-recurses - Do not build by RECURSES" %}

\-R, --ignore-recurses Не собирать рекурсивно указанные зависимости

Опции `-R` и `--ignore-recurses` применяются при запуске системы сборки для управления вложенным процессом компиляции проекта. Эти параметры предотвратят автоматическую сборку проектов, объявленных с использованием макроса `RECURSE` в файлах ya.make.

Макрос `RECURSE` обычно используется для объявления вложенных сборочных целей, которые необходимо скомпилировать одновременно. Однако это не создает жестких зависимостей между различными целями сборки. Когда требуется ограничить процесс сборки только конкретно указанными целью или модулем, без рекурсивного включения дополнительных сборочных задач, опции `-R` и `--ignore-recurses` приказывают системе сборки игнорировать макрос `RECURSE`.

Это означает, что если в проекте используются вложенные макросы `RECURSE`, которые могут повлечь за собой дополнительные неявные процессы сборки, опции `-R` и `--ignore-recurses` обеспечивают более точный контроль над процессом, позволяя собрать только те цели, которые явно заданы, минимизируя тем самым потенциальные сложности из-за неожиданных зависимостей.

{% endcut %}

{% cut "--no-src-links - Do not create any symlink in source directory" %}

\--no-src-links Не создавать символические ссылки в исходной директории

Опция `--no-src-links` отменяет создание символических ссылок для доступа к результатам сборки или тестов, которые обычно размещаются во временных хранилищах, таких как кэш результатов. Это является стандартным способом организации доступа к собранным артефактам на Unix-подобных системах, таких как Linux или MacOS, позволяя быстро ссылаться из исходной директории на данные и результаты, хранящиеся в другом месте.

При запуске сборки или тестов без `--no-src-links`, система создает символические ссылки в рабочей копии исходного репозитория, которые указывают на соответствующие файлы или директории в кэше результатов.

Использование `--no-src-links` означает, что система будет сохранять все артефакты напрямую в предназначенные для этого директории на локальной файловой системе, не создавая символических ссылок. Это может быть особенно актуально в Windows, где механизм работы с символическими ссылками отличается и может быть не таким прямым или надежным, как в Unix-подобных системах.

{% endcut %}

Разработчикам **--ignore-recurses Повторяется в справке, уже описана выше  на 2 пункта**

{% cut "-o=OUTPUT_ROOT, --output=OUTPUT_ROOT - Directory with build results" %}

\-o=OUTPUT_ROOT, --output=OUTPUT_ROOT Директория с результатами сборки

`-o=OUTPUT_ROOT`, `--output=OUTPUT_ROOT` — путь, куда будут сложены результаты сборки (на Linux и macOS будут использованы хардлинки). Результаты будут размещены по путям, соответствующим размещению описаний сборки

{% endcut %}

**Расширенные опции**

{% cut "-I=INSTALL_DIR, --install=INSTALL_DIR - Path to accumulate resulting binaries and libraries" %}

\-I=INSTALL_DIR, --install=INSTALL_DIR Путь для накопления результирующих бинарных файлов и библиотек

I=INSTALL_DIR, --install=INSTALL_DIR — не рекомендуется использовать. Путь, куда будут сложены результаты сборки. Результаты будут сложены непосредственно в указанную директорию.

{% endcut %}

**Опции для экспертов**

{% cut "--add-host-result=ADD_HOST_RESULT - Process selected host build output as a result" %}

\--add-host-result=ADD_HOST_RESULT - Обработать выбранный вывод хост-сборки как результат

Опция `--add-host-result=ADD_HOST_RESULT` конфигурирует сборочный процесс таким образом, что определенные результаты сборки на хост-машине (то есть та машина, которая используется для выполнения сборки) могут быть явно отобраны как финальные артефакты. Это обеспечивает точность и контроль за теми артефактами, которые вы считаете важными и хотите сохранить после процесса сборки.

Использование `--add-host-result=ADD_HOST_RESULT` особенно полезно, когда необходимо выделить важные результаты, такие как исполняемые файлы, библиотеки, документация или отчеты, гарантируя, что они не будут утеряны среди прочих временных файлов сборки. Этот параметр позволяет определить пути или шаблоны путей, которые должны быть включены в итоговый набор.

{% endcut %}

{% cut "--all-outputs-to-result - Process all outputs of the node along with selected build output as a result" %}

\--all-outputs-to-result - Обрабатывать все выходные данные узла вместе с выбранным результатом сборки

Опция `--all-outputs-to-result` модифицирует поведение сборочной системы так, что вместо фильтрации и извлечения лишь специфичных выходных файлов, определенных через другие параметры (как `--add-result`), она указывает сборочной системе включать все выходные файлы, связанные с заданными командами.

Классически, при использовании `--add-result`, система сборки фильтрует выходные данные, основываясь на их расширениях или других критериях, определенных пользователем. Так, если использовать `--add-result=.pb.h`, система извлечет и предоставит только файлы с расширением `.pb.h`. Однако, добавление `--all-outputs-to-result` к команде изменит эту логику и даст в результате все связанные выходные файлы, включая, например, `.pb.cc`, которые могут быть необходимы для полного функционирования сборки или при дальнейшем использовании.

{% endcut %}

{% cut "--add-modules-to-results - Process all modules as results" %}

\--add-modules-to-results - Обрабатывать все модули как результаты

Опция `--add-modules-to-results` применяется для того, чтобы указать системе сборки рассматривать каждый модуль в проекте, включая те, что указаны как зависимости через `PEERDIR`, как целевые результаты сборки.

В стандартном режиме сборки только определенные типы артефактов, такие как исполняемые файлы, библиотеки или результаты тестов, считаются конечными результатами. Однако, активация `--add-modules-to-results` меняет это поведение, делая каждый модуль, который может быть представлен индивидуальным блоком кода и компилироваться в отдельные объектные файлы или пакеты, отдельным результатом сборки.

{% endcut %}

`--strip-packages-from-results -`**НЕ НАШЕЛ В ДОКУМЕНТАЦИИ. ДЕЛАЛ ПО АНАЛОГИИ**

{% cut "--strip-packages-from-results - Strip all packages from results" %}

\--strip-packages-from-results -Удалить все пакеты из результатов

Опция `--strip-packages-from-results` применяется в процессе сборки для исключения пакетов из итоговых результатов сборки. Это означает, что при использовании данной опции, система сборки произведет удаление всех пакетов, которые  могли бы в противном случае рассматривать как конечные результаты.

Как правило, пакеты (packages) могут содержать бинарные файлы, библиотеки, скрипты конфигураций и другие компоненты, которые являются результатами сборочного процесса.

Может быть полезно, например,  для выполнения тестов и проверок, где наличие пакетов не требуется.

{% endcut %}

{% cut "--no-output-for=SUPPRESS_OUTPUTS - Do not symlink/copy output for files with given suffix, they may still be save in cache as result" %}

Опция `--no-output-for=SUPPRESS_OUTPUTS` обеспечивает управление отображением и доступностью результатов сборки, позволяя исключить создание символических ссылок или физическое копирование файлов с определенным суффиксом в выходную директорию, сохраняя их в кеше системы сборки.

При вызове `ya make`, добавление параметра `--no-output-for=<.suffix>`, где `<.suffix>` представляет суффиксы файлов, для которых не следует создавать выходные ссылки или копии, позволяет точно управлять содержимым выходных директорий.

Ключевые моменты использования `--no-output-for=SUPPRESS_OUTPUTS`:

* Файлы с указанным суффиксом не отображаются после сборки, но остаются в кэше.
* Опция не влияет на `--replace-result`, поэтому исключение файлов из выходных результатов не предотвращает их сборку, они будут скачаны и сложены в кэш, но не будут отображены как результаты сборки.

{% endcut %}

`--with-credits` - **НЕ НАШЕЛ В ДОКУМЕНТАЦИИ. ДЕЛАЛ ПО АНАЛОГИИ**

{% cut "--with-credits - Enable CREDITS file generation" %}

\--with-credits - Включить генерацию файла CREDITS

Опция `--with-credits` используется при проведении сборки с целью включить в процесс создание файла `CREDITS`. Этот файл обычно содержит информацию о вкладчиках, авторах, лицензиях и другие подобные сведения, которые касаются используемых зависимостей и компонентов в проекте.

Включение этой опции заставит систему сборки автоматически генерировать файл `CREDITS`, который будет собирать такие данные из различных источников в процессе сборки. Это может быть необходимо для соответствия лицензионным требованиям открытого программного обеспечения, для обеспечения прозрачности использования сторонних библиотек или просто в целях предоставления информации о вкладе разработчиков.

{% endcut %}

## Вывод (Printing) 


Опция `--stat` используется с командой `ya make` для отображения статистики выполнения сборки. Когда эта опция включена, пользователи могут получить сведения о процессе сборки без учета дополнительных шагов, таких как конфигурирование, пакетирование и других аналогичных процессов. Это полезно для анализа производительности и оптимизации времени сборки.

В добавок к использованию командной строки, вы можете автоматически активировать этот режим для всех сборок, выполняемых через `ya make`, `ya package` и так далее, путем установки параметра `print_statistics = true` в конфигурационном файле. Это означает, что каждый раз, когда выполняется сборка через `ya make` с любыми его опциями, статистика сборки будет автоматически выводиться в конце процесса.

Использование этой опции может быть особенно ценным в условиях интенсивной разработки или оптимизации существующих процессов сборки, так как оно предоставляет ключевые данные, которые могут быть использованы для улучшения скорости и эффективности сборок.

Опция `-v` или `--verbose`, применяемая с командой `ya make` и аналогичными инструментами сборки, служит для активации режима подробного вывода. Когда эта опция включена, в консоль будут дополнительно выводиться тексты всех выполняемых сборочных команд, что позволяет пользователям более детально следить за процессом сборки и диагностировать возможные проблемы.

Использование режима подробного вывода особенно полезно в следующих случаях:
\- Диагностика ошибок: Позволяет увидеть точные команды, приводящие к ошибкам в процессе сборки, что упрощает отладку.
\- Оптимизация сборки: Понимание того, какие команды выполняются и сколько времени они занимают, может помочь в оптимизации скриптов сборки для ускорения процесса.
\- Обучение и документирование: Подробный вывод дает лучшее понимание того, как работает процесс сборки, что может быть полезно при написании документации или обучении новых членов команды.

Таким образом, опция `-v` или `--verbose` добавляет дополнительный уровень прозрачности к процессу сборки, позволяя более глубоко понять и контролировать его этапы.

Опция `-T` применяется в контексте команды `ya make` и служит для изменения способа вывода статуса процесса сборки. По умолчанию, многие инструменты сборки, включая `make` и `ninja`, обновляют статус выполнения в одной и той же строке терминала, чтобы сохранить вывод компактным и организованным. Однако, в некоторых случаях, например, при записи вывода сборки в файл или при использовании инструментов CI/CD, которые лучше обрабатывают построчный вывод, этот режим может быть неудобен.

Активация опции `-T` приводит к тому, что статус сборки выводится в построчном режиме, при этом каждое новое сообщение выводится на новой строке без перезаписывания предыдущего. Это делает вывод более подходящим для логирования и последующего анализа.

Кроме того, при перенаправлении вывода команды `ya make` в файл (например, через `ya make &gt; build.log`), режим построчного вывода статуса включается автоматически, учитывая, что перезаписи строки не имеют смысла в контексте файла лога. Это позволяет сохранить весь вывод процесса сборки в удобочитаемом формате для последующего анализа или архивации.

Использование `-T` упрощает работу с логами, делая их более структурированными и информативными, особенно когда построчная запись сообщений предпочтительнее для визуализации процесса сборки в различных средах и инструментах.

Опция `--show-command=SHOW_COMMAND` используется в контексте команды `ya make` и позволяет пользователям получить информацию о конкретной сборочной команде, которая была использована для создания выбранного результата сборки. Этот параметр очень полезен при необходимости детального анализа процесса сборки и понимания того, какие именно команды и аргументы применялись для получения конечного артефакта.

Когда запускается с опцией `--show-command`, инструмент извлекает и выводит конкретную команду сборки из базы данных сборки или кэша.
Возможность видеть точные команды помогает разработчикам понять процесс сборки и облегчает отладку, оптимизацию сборочных скриптов, а также помогает новым членам команды лучше разбираться в сборочных процессах проекта.
Сценарии использования:
\- **Отладка сборки**: Помогает выявить причины неудачных сборок, показывая, какие команды привели к ошибкам.
\- **Оптимизация сборки**: Вы можете идентифицировать неэффективные или избыточные команды сборки, что дает возможность ускорить процесс сборки.
\- **Документирование**: Создание документации или руководств по сборке, представляющее точные команды для воспроизведения или модификации сборки.

Опция `--show-timings` предназначена для использования с инструментом сборки `ya make` и позволяет пользователям получить информацию о времени выполнения каждой команды в процессе сборки. Это может включать времена компиляции отдельных модулей, время линковки, выполнение скриптов пред- и пост-сборки и другие сборочные задачи.

Как работает опция:
При активации опции `--show-timings`, после каждой выполненной сборочной команды `ya make` добавляет в вывод время, потребовавшееся на её выполнение. Это позволяет разработчикам идентифицировать узкие места в процессе сборки, которые требуют оптимизации, чтобы ускорить общее время сборки проекта.

Опция `--show-timings` должна использоваться совместно с опцией `-T`, которая изменяет вывод статуса на построчный, чтобы обеспечить корректное отображение времени выполнения команд.
Опция `-T` предотвращает перезапись вывода в терминале, что обеспечивает читаемость результатов времени выполнения для каждой команды.
Сценарии использования:
\- **Оптимизация процесса сборки**: Понимание времени выполнения конкретных команд помогает выявить потенциально неэффективные задачи, которые могут быть оптимизированы для сокращения общего времени сборки.
\- **Анализ производительности**: Идентификация команд с наибольшим временем выполнения может указать на проблемы с производительностью в определенных частях кода или в конфигурации сборки.
\- **Отладка**: В случае неожиданно долгой сборки определенных компонентов, опция может помочь понять, на каком шаге тратится больше всего времени.

Опция `--log-file=LOG_FILE` в контексте использования с инструментом `ya make` предоставляет возможность перенаправления подробного журнала выполнения сборки в указанный пользователем файл. Это позволяет сохранить все детали процесса сборки для последующего анализа, аудита или использования в системах мониторинга и уведомлений.

При запуске `ya make` с этой опцией, все сообщения, обычно выводимые на стандартный вывод (stdout) и стандартный вывод ошибок (stderr), будут также дополнительно записаны в файл, путь к которому указан в параметре `LOG_FILE`. Это включает в себя вывод команд, предупреждения, сообщения об ошибках и любую другую информацию, генерируемую во время сборки.

Пример использования:
ya make --log-file=build.log
В этом примере все данные сборки, включая подробный вывод, будут сохранены в файл `build.log`.

Сценарии использования:
\- **Отладка и анализ**: Подробные журналы сборки могут содержать ценную информацию для диагностики и устранения проблем. Сохранение этой информации в файле упрощает процесс анализа и совместной работы над исправлением ошибок.
\- **Аудит**: В некоторых средах разработки требуется вести журнал всех операций сборки для аудита или соответствия нормативным требованиям. Журналы сборки могут служить доказательством того, что определённые проверки прошли успешно.
\- **Мониторинг**: В системах непрерывной интеграции и доставки (CI/CD) файлы журналов могут быть автоматически анализированы для выявления предупреждений и ошибок, а также для определения тенденций ухудшения или улучшения качества кода.
\- **Документирование**: Журналы сборки могут служить документацией выполненных операций, облегчая понимание истории проекта и изменений в его структуре или зависимостях.

Опция `--stat-dir=STATISTICS_OUT_DIR` используется с инструментом `ya make` для указания директории, в которую будут выводиться дополнительные статистические данные о процессе сборки. Эта функциональность позволяет разработчикам сохранять различные метрики и аналитические данные о сборке в отдельное место, что способствует более удобному доступу и анализу последующими инструментами или для внутреннего аудита.

При запуске `ya make` с использованием `--stat-dir=STATISTICS_OUT_DIR`, система сборки автоматически создает указанную директорию (если она уже не существует) и начинает записывать в нее файлы со статистической информацией о процессе сборки. Статистика может включать данные о времени выполнения, использовании кэшей, деталях критического пути, долгих сборочных шагах и других аналитических метриках.

Пример использования:
ya make --stat-dir=./build_stats
В этом случае все статистические данные сборки будут сохранены в директорию `./build_stats` относительно текущей рабочей директории.

Опция `--no-emit-status` применяется с инструментом `ya make` для управления выводом статуса процесса сборки в командной строке. Когда эта опция активирована, `ya make` не будет выводить в терминал регулярные обновления статуса сборки, которые обычно информируют пользователя о текущем действии, выполняемом сборочной системой. Это может включать начало выполнения определенной задачи, завершение задачи, ошибки сборки и предупреждения.

Активация `--no-emit-status` существенно сокращает количество информации, выводимой в процессе выполнения сборки, оставляя лишь критически важные сообщения или результаты выполнения. Стандартные обновления прогресса, которые обычно предоставляются для информирования пользователя о ходе сборки, будут подавлены.

ya make --no-emit-status
В этом случае, при выполнении сборки, не будет выводится текущий статус сборки, что делает вывод менее загруженным и может быть предпочтительным в сценариях, где важны только результаты сборки или сообщения об ошибках.

Опция `--do-not-output-stderrs` используется  для подавления вывода всех сообщений об ошибках в стандартный поток ошибок (stderr). Эта функция позволяет пользователям и системам автоматизации управлять логированием ошибок, особенно в сценариях, где подробная диагностика ошибок в реальном времени не требуется или когда предпочтительно анализировать ошибки и предупреждения в специально отведенных для этого файлах.

Как работает опция:
При выполнении `ya make` с активированной опцией `--do-not-output-stderrs`, все сообщения, которые обычно направляются в стандартный поток ошибок (например, компиляторные ошибки, предупреждения, ошибки исполнения и т.д.), не будут отображаться в терминале. Это не влияет на стандартный поток вывода (stdout), который может продолжать выводить другие сообщения, не связанные с ошибками.

Пример использования:
ya make --do-not-output-stderrs
Это может быть полезно, например, в автоматизированных сценариях сборки, где ошибки логируются в файл и анализируются отдельно от процесса сборки, или в средах, где чрезмерный вывод ошибок в реальном времени может привести к ненужным задержкам или осложнениям.

Опция `--mask-roots` предназначена для скрытия или маскирования путей к исходным и сборочным директориям в сообщениях об ошибках, которые выводятся в стандартный поток ошибок (stderr). Это делается для улучшения безопасности и портативности вывода ошибок, а также для упрощения чтения и анализа сообщений об ошибках при сборке.

При активации опции `--mask-roots`, всякий раз, когда в выводе ошибок должен будет отображаться полный путь к файлу или директории (например, путь к файлу, в котором произошла ошибка компиляции), `ya make` автоматически заменяет его на относительный путь или маскированное представление. Это позволяет скрыть абсолютные пути, которые могут содержать имена пользователей, специфичные для системы имена директорий или другую чувствительную информацию.

ya make --mask-roots
Этот параметр особенно полезен при обмене логами сборки с другими разработчиками или при публикации их в открытом доступе (например, в рамках отчетов об ошибках в интернете), поскольку предотвращает ненужное раскрытие информации о структуре файловой системы, настройках среды разработки или личных данных.
Сценарии использования:
\- **Публикация ошибок**: При публикации сообщений об ошибках в интернете, например, на форумах поддержки или в системах отслеживания ошибок, скрытие реальных путей улучшает безопасность и обеспечивает более универсальный формат сообщений.
\- **Обеспечение конфиденциальности**: В случаях, когда абсолютные пути могут содержать конфиденциальную информацию о структуре проекта, пользовательские имена или другие чувствительные данные, маскировка путей предотвращает их нежелательное распространение.

Опция позволяет более безопасно и удобно работать с сообщениями об ошибках.

При использовании `--no-mask-roots`, пути к исходным и сборочным директориям будут отображаться в полном виде в сообщениях об ошибках, направляемых в стандартный поток ошибок (stderr). Таким образом, в логах ошибок будут видны абсолютные пути, включая всю информацию о структуре директорий.

Когда `ya make` выполняется с данной опцией, система сборки не сокращает и не маскирует пути в сообщениях об ошибках. Вместо использования относительных или маскированных путей, в stderr будут выводиться полные абсолютные пути, что может быть полезно для углубленной диагностики и отладки проблем.

 Пример использования:
ya make --no-mask-roots
Этот способ часто используется в ситуациях, когда разработчикам необходимо точно знать, где находится файл или директория, вызвавшая определенную ошибку сборки, для быстрого доступа и внесения корректив.

Необходимо быть осторожным при использовании этой опции, чтобы избежать непреднамеренного раскрытия слишком подробной или чувствительной информации, особенно при обмене логами сборки с внешними сторонами или при публикации журналов в открытых источниках.

Опция `--html-display=HTML_DISPLAY` активирует генерацию вывода процесса сборки в формате HTML. Этот режим предназначен для создания визуально более доступной и удобочитаемой версии логов сборки, которую можно просматривать в веб-браузере. Включение этой опции приводит к тому, что результаты выполнения команд сборки, включая сообщения об ошибках, предупреждения, а также информацию о прогрессе сборки, будут представлены в виде HTML-документа.

Значение, передаваемое с опцией (`HTML_DISPLAY`), обычно указывает путь к файлу или директории, где должен быть сохранен сгенерированный HTML-файл. После завершения процесса сборки пользователь может открыть указанный HTML-файл в любом веб-браузере и просмотреть результаты сборки в удобном и наглядном формате.

Пример использования:
ya make --html-display=./build_report.html
В этом примере весь вывод сборки будет записан в файл `build_report.html` в текущей директории. После завершения сборки файл можно открыть для просмотра в браузере.

Использование этой опции предоставляет дополнительные возможности для визуализации и анализа процесса сборки, делает информацию более доступной и легко интерпретируемой для различных категорий пользователей.

Про эту уточнить

Опция `--teamcity` активирует генерацию и вывод специализированных сервисных сообщений для системы непрерывной интеграции TeamCity. TeamCity использует эти сервисные сообщения для расширенного управления сборками, тестирования и отображения детализированной информации о процессе сборки прямо в пользовательском интерфейсе TeamCity.

Когда `ya make` выполняется с опцией `--teamcity`, он включает в свой вывод дополнительные сервисные сообщения, понимаемые TeamCity. Эти сообщения могут содержать данные об успехе или ошибке выполнения задач, статистику прохождения тестов, информацию о начале и конце различных этапов сборки и так далее. Использование этого формата сообщений позволяет TeamCity более точно интерпретировать результаты выполнения сборки и предоставлять разработчикам расширенные возможности для мониторинга и анализа процесса сборки и тестирования.


## Конфигурация платформы/сборки 

Опция `-d` (также указываемая как `--debug` или `--build debug`) задает режим сборки отладки (Debug Build) для проекта. Этот режим предназначен для разработки и отладки программы, поскольку обеспечивает наиболее полную информацию для анализа и исправления ошибок. Такой режим установлен по умолчанию.

Особенности сборки отладки:
\- **Без оптимизаций**: Для кода на C\+\+, например, уровень оптимизации компилятором устанавливается как `-O0`, что гарантирует отсутствие оптимизаций кода. Это облегчает процесс отладки, так как каждая строка исходного кода может быть прямо отнесена к определенному месту в скомпилированном бинарном файле.
\- **С отладочной информацией**: Сборка включает в себя отладочную информацию, что позволяет отладчикам и другим инструментам анализа предоставлять более подробную информацию об объектах, функциях, переменных и так далее.
\- **С ассертами**: Включение ассертов (утверждений) облегчает проверку предусловий, постусловий и инвариантов в коде во время его исполнения. Это помогает быстрее находить и исправлять ошибки логики программы.
\- **Дополнительные флаги защиты**: Для кода на C\+\+ добавляется флаг `-fstack-protector`, который активирует функции защиты стека, помогая предотвратить определенные виды атак на переполнение буфера.

Пример использования:
ya make -d или ya make --debug или ya make --build debug
Эти команды инициируют процесс сборки в режиме отладки, обеспечивая создание бинарных файлов, оптимизированных для отладки, а не для выпуска в продакшн.

Опция `--build=BUILD_TYPE`  позволяет указать конкретный тип сборки, определяющий уровень оптимизации, наличие отладочной информации, использование различных инструментов анализа и диагностики. В зависимости от выбранного `BUILD_TYPE`, сборка может быть адаптирована для различных целей: от разработки и отладки до тестирования производительности и подготовки к выпуску.

Варианты `BUILD_TYPE`:
\- `debug` (по умолчанию): Сборка без оптимизаций, с полной отладочной информацией и ассертами. Оптимизирована для разработки и отладки.
\- `release`: Сборка с максимальным уровнем оптимизации и ограниченной отладочной информацией. Предназначена для выпуска продукта.
\- `profile`: Специализированный тип сборки, оптимизированный для профилирования приложения.(Сборка с профилировкой - https://ru.wikipedia.org/wiki/Profile-guided_optimization )
\- `gprof`: Сборка предназначена для использования с GNU Profiler (gprof), инструментом профилирования производительности.
\- `valgrind`: Сборка, адаптированная для работы с Valgrind, инструментом для обнаружения утечек памяти и других ошибок.
\- `valgrind-release`: Оптимизированная версия сборки для использования с Valgrind, совмещающая оптимизации релизной сборки.
\- `coverage`: Сборка, инструментированная для сбора данных о покрытии кода тестами.
\- `relwithdebinfo`: Релизная сборка с отладочной информацией и ассертами, используется для основных проверок в CI.
\- `minsizerel`: Сборка, оптимизированная для минимизации размера исполняемого файла.
\- `debugnoasserts`: Сборка отладки без ассертов, что может быть полезно для производительности при отладке.
\- `fastdebug`: Отладочная сборка с некоторыми оптимизациями для ускорения процесса отладки.

Сценарии использования:
\- Разработчики используют разные типы сборок для достижения различных целей на разных этапах разработки программного обеспечения:
\- `debug` для повседневной разработки и отладки.
\- `release` для тестирования производительности или подготовки к выпуску.
\- `coverage` для анализа покрытия тестами.
\- `valgrind` или `valgrind-release` для детального анализа исполнения и поиска проблем, связанных с управлением памятью.
\- Специализированные типы сборок, такие как `profile` или `gprof`, могут использоваться для детального профилирования приложения с целью оптимизации его производительности.

Опция `--sanitize=SANITIZE` используетсядля активации инструментов санитайзера, которые предоставляют различные виды проверок на ошибки в программе на стадии выполнения. Санитайзеры — это мощные инструменты, предназначенные для обнаружения различных типов ошибок, таких как доступы к выходу за границы массивов, использование неинициализированных данных, утечки памяти, нарушения работы с потоками и другие. Они особенно полезны для выявления сложных для отладки проблем и повышения качества кода.

Варианты `SANITIZE`:
\- `address`: Санитайзер адресов (`AddressSanitizer`), помогает находить ошибки связанные с памятью, такие как выходы за границы массивов, использование после освобождения и двойное освобождение.
\- `memory`: Санитайзер памяти (`MemorySanitizer`), предназначен для обнаружения использований неинициализированной памяти.
\- `thread`: Санитайзер потоков (`ThreadSanitizer`), используется для выявления гонок данных и других проблем многопоточности.
\- `undefined`: Санитайзер неопределенного поведения (`UndefinedBehaviorSanitizer`), можно использовать для поиска неопределенных поведений в коде по стандарту языка программирования, таких как переполнение целочисленных значений или неправильное использование null-указателей.
\- `leak`: Санитайзер утечек памяти (`LeakSanitizer`), служит для обнаружения утечек памяти в программе.

Пример использования:
ya make --sanitize=address
Эта команда активирует `AddressSanitizer` для обнаружения ошибок, связанных с неправильным обращением к памяти, таких как выход за границы массива или использование уже освобожденной памяти.

Использование санитайзеров является эффективным средством для повышения качества и безопасности кода.

Опция `--race` предназначена для активации детектора гонок (race detector) при компиляции и сборке проектов, написанных на языке программирования Go. Детектор гонок — это инструмент, который помогает разработчикам обнаруживать проблемы синхронизации в многопоточных или конкурентных программах, такие как состояние гонки (race condition), когда результат выполнения программы непредсказуемо зависит от порядка, в котором выполняются операции.

Когда вы компилируете и запускаете программу с включенным детектором гонок, инструмент анализирует операции чтения и записи общих данных между горутинами или потоками на предмет неправильного доступа, который может привести к гонкам. Это достигается за счет внедрения дополнительного инструментального кода в целевую программу, который наблюдает за операциями с памятью и отслеживает синхронизацию при доступе к данным. Если детектор обнаруживает потенциальную гонку, он выводит предупреждение с информацией о месте в коде, где возможна проблема.

Применение опции `--race`:
ya make --race
Эта команда инициирует сборку проекта на Go с активированным детектором гонок. Это позволяет автоматически выявлять сложные для обнаружения ошибки, связанные с конкуренцией и многопоточностью, на фазе тестирования и разработки, еще до развертывания программы в производственной среде.

ПЕРЕПИСАТЬ

Опция `-D=FLAGS` в контексте использования инструмента сборки `ya make` позволяет определять или переопределять переменные среды сборки или компиляции, задавая их имя и значение. Это мощный инструмент для настройки процесса сборки, который даёт возможность динамически изменять параметры, влияющие на выбор конфигураций, условную компиляцию и другие аспекты компиляции и сборки без необходимости изменения исходного кода или структуры проекта.

Как работает `-D=FLAGS`:
\- Параметр `name` указывает на имя переменной, которую вы хотите определить или переопределить.
\- Параметр `val` задаёт значение этой переменной. Если значение не указано (т.е., используется формат `-Dname`), то переменной автоматически присваивается значение “yes”.
\- Возможно указание нескольких переменных, разделяя их пробелом и используя кавычки, либо повторное использование опции `-D` для каждой переменной.

Примеры использования:
ya make -DDEBUG
В этом примере переменной `DEBUG` присваивается значение “yes”, что может быть использовано в коде для активации дополнительной отладочной информации или включения условно компилируемого кода.

ya make -DVAR_NAME=value
Здесь переменной `VAR_NAME` присваивается `value`, что может влиять на различные аспекты сборки, например, на включение специфичных для платформы опций компиляции.

ya make -D"FLAG1=1 FLAG2=option FLAG3=yes"
В этом случае определяются три переменные `FLAG1`, `FLAG2` и `FLAG3` со значениями “1”, “option” и “yes” соответственно. Заметьте использование кавычек для указания нескольких переменных в одном `-D` аргументе.

В команде `ya make` можно указать дополнительные флаги (переменные) с помощью опции `-DVAR[=VALUE]`. Если не указывать значение переменной, по умолчанию оно будет выставлено в `yes`.

Можно определить:

* Предопределённые переменные, позволяющие передать флаги для сборки `ya make -DLDFLAGS="-fblabla=foo -fbar"`, `ya make -DCFLAGS="-DNN_DOUBLE_PRECISION -Wno-strict-aliasing"` и т. п.

* Предопределённые переменные, управляющие конфигурацией, например `ya make -DCATBOOST_OPENSOURCE` (сборка как для open source) или `ya make -DCUDA_VERSION=10.1` (сборка с CUDA).

* Переменные для использования в ya.make `ya make -DMACRO1 -DMACRO2=42`, где в `ya.make` написано, например `IF (MACRO1)`.

Список доступных переменных достаточно большой и часто меняется. Самые часто используемые переменные можно найти в соответствующих разделах [руководства по системе сборки]

Система сборки ya make поддерживает *одновременную сборку* под несколько платформ (`--target-platform` можно указать несколько раз). Более того, для каждой целевой платформы доступны разные дополнительные настройки (`--target-platform-flags` позволяет задать [`-D`-флаги], а `--target-platform-build-type` — [тип сборки] для платформы, указанной перед этими опциями). Однако

* Для каждой платформы будет получен отдельный артефакт. ya make не поддерживает *мультиплатформенную сборку* — результаты не будут запакованы в fat binary для macOS или Android APK.

* Артефакты для разных платформ могут иметь одинаковые имена, при складывании результатов они могут наложиться друг на друга и результат будет непредсказуем.

Опция `--host-platform-flag=HOST_PLATFORM_FLAGS` позволяет указывать специфические флаги или настройки, которые применяются к сборочной платформе, то есть к системе, на которой запускается процесс сборки. В отличие от обычных флагов, которые направлены на конфигурацию процесса сборки для целевой платформы (то есть для системы, на которой будет запущен собранный продукт), опция `--host-platform-flag` влияет на то, как собираются инструменты и зависимости, используемые непосредственно при сборке.

Примеры использования:
\- `--host-platform-flag MUSL`
Этот флаг указывает на необходимость использования `musl libc` вместо стандартной библиотеки `glibc` для сборки инструментов, которые требуются для создания продукта. Это может быть полезно для тестирования совместимости программы с различными библиотеками C или в ситуациях, когда конечный продукт разрабатывается или разворачивается на системах, где предпочтение отдаётся `musl libc`.

`-DUSE_PREBUILT_TOOLS=no --host-platform-flag=USE_PREBUILT_TOOLS=no`
Эти флаги обеспечивают полное отключение использования предпостроенных инструментов в процессе сборки, требуя вместо этого компиляции всех необходимых инструментов из исходного кода непосредственно во время сборки. Это может быть необходимо для обеспечения максимальной совместимости сборочных инструментов с текущей сборочной средой или для гарантии того, что весь инструментарий будет собран с использованием конкретных настроек или опций компиляции.

Зачем это нужно:
\- **Гибкая настройка сборки**: `--host-platform-flag` предоставляет разработчикам возможность тонко настраивать процесс сборки, особенно когда требуется контроль над особенностями сборки используемых инструментов.
\- **Специфическая совместимость**: Некоторые проекты могут требовать особенной совместимости или использования конкретных версий инструментов и библиотек. Опция позволяет решить эти задачи, предоставляя необходимую гибкость.

Опция `--target-platform=TARGET_PLATFORMS` в инструменте сборки `ya make` позволяет явно указать целевую платформу для сборки проекта, определяемую тройкой значений: компилятор, операционная система (OS) и архитектура процессора. Целевая платформа — это платформа, для которой предназначен итоговый продукт или артефакт сборки. Платформа определяет ключевые характеристики сборки, включая используемый компилятор, архитектуру CPU и операционную систему, что влияет на процесс компиляции и настройки линковки.

Как работает опция:

\- Указание целевой платформы в формате `<компилятор-OS-архитектура>` позволяет настроить сборку для специфических требований и учета особенностей разных платформ.
\- Можно задать подмножество тройки, например, только OS или архитектуру, при этом оставшиеся аспекты будут выбраны по умолчанию, основываясь на текущей среде сборки или предустановленных значениях.
\- Специальное значение `DEFAULT` для компилятора позволяет использовать стандартный компилятор, который обычно используется в данной операционной системе для целевой архитектуры.

\### Примеры использования:

1\. `--target-platform clang-win-x86_64`
Собрать программу для Windows на Intel 64bit используя компилятор Clang.

2\. `--target-platform default-android-armv8a`
Собрать приложение для Android на архитектуре ARM версии armv8a, используя компилятор по умолчанию для этой платформы.

3\. `--target-platform windows`
Собрать проект для Windows, используя архитектуру по умолчанию (обычно x86_64) и стандартный компилятор для Windows.

Особенности использования при сборке под macOS:

\- При сборке для macOS в качестве OS указывается `DARWIN`.
\- Для Apple Silicon (процессоры M1) используется `default-darwin-arm64`, так как архитектура по умолчанию для macOS - это x86-64.

Совместимость и доступные варианты:

\- Хотя `ya make` поддерживает множество различных целевых платформ и компиляторов, не все их комбинации возможны. В случае, если указана неверная или несовместимая платформа, `ya make` стремится предложить ближайшие доступные варианты.
\- Система сборки поддерживает одновременную сборку под несколько платформ, что позволяет использовать `--target-platform` несколько раз для разных вариантов сборки в одной команде.

Важные замечания:

\- Каждая указанная целевая платформа приведет к генерации отдельного артефакта. `ya make` не поддерживает создание мультиплатформенных бинарных файлов (fat binaries) автоматически.
\- Если артефакты для разных платформ имеют одинаковые имена, их результаты могут конфликтовать или перезаписывать друг друга, что может привести к непредсказуемым результатам сборки.

Опция `--target-platform-flag=TARGET_PLATFORM_FLAG` представляет собой расширенную функциональность в конфигурации процесса сборки с помощью инструмента `ya make`, которая позволяет задать специфические флаги или параметры конфигурации для определённой целевой платформы. Эта возможность особенно важна при работе с проектами, требующими тонкой настройки сборки или специальной обработки в зависимости от архитектуры целевых систем или их операционных систем.

Принцип работы:

Опция `--target-platform-flag` позволяет управлять поведением сборки на уровне конкретной платформы, передавая в процесс сборки параметры, специфичные для данной платформы. Используемое значение `TARGET_PLATFORM_FLAG` определяет, какие именно флаги или параметры будут применены.

Пример использования:

\- Предположим, требуется собрать проект таким образом, чтобы для целевой платформы Android использовались определённые настройки компилятора или параметры оптимизации, отличные от настроек по умолчанию. Это может быть достигнуто с помощью следующей команды:

ya make --target-platform=android-armv7 --target-platform-flag=“OPTIMIZE=-O2”

Здесь OPTIMIZE=-O2 задаёт уровень оптимизации компилятора специфически для целевой платформы Android ARMv7.

Расширенные сценарии использования:

\- Настройка поведения компилятора:\
Например, можно указать, чтобы для компиляции кода под определённой платформой использовались специальные флаги компилятора, что актуально для кросс-платформенной разработки.

\- Управление зависимостями:\
Можно включать или исключать определённые модули, библиотеки или файлы из сборки в зависимости от целевой платформы.

\- Адаптация под специфики платформы:\
Иногда требуется учитывать особенности платформы, например, использование специальной библиотеки системных вызовов или управление памятью, и это может быть реализовано через --target-platform-flag.

Замечания:

\- Для каждой целевой платформы могут быть заданы свои уникальные флаги.
\- Порядок указания флагов имеет значение, так как последующие опции могут перезаписывать или дополнять предыдущие.
\- Используйте [ya package] для предсказуемой сборки под несколько платформ.

все оттестировать, флаги взял по аналогии

Опция `--sanitizer-flag=SANITIZER_FLAGS` используется в контексте инструмента сборки `ya make` для задания дополнительных параметров или флагов, которые будут переданы инструментам санитайзера. Санитайзеры — это специальные инструменты, встроенные в компиляторы (например, в GCC или Clang), предназначенные для автоматического обнаружения различных видов ошибок в программе на этапе выполнения, таких как использование неинициализированной памяти, выход за границы массивов, утечки памяти, гонки данных и другие типы неопределенного поведения.

Принцип работы:

При компиляции исходного кода с использованием санитайзера, компилятор встраивает в бинарный код специальные проверки, которые во время выполнения программы могут обнаруживать различные типы ошибок. Опция `--sanitizer-flag` позволяет настроить работу санитайзеров, уточнив или расширив список выполняемых проверок, или же сконфигурировать поведение санитайзера более тонко.

Примеры использования SANITIZER_FLAGS:

\- `leak_check_at_exit=0` для AddressSanitizer может быть использовано для отключения проверки утечек памяти при завершении работы программы.
\- `halt_on_error=1` заставляет программу немедленно завершать работу при обнаружении первой ошибки, что может быть полезно при автоматизированном тестировании.
\- `detect_stack_use_after_return=1` активирует в AddressSanitizer режим обнаружения обращений к стеку после возврата из функции, что является более дорогой по ресурсам проверкой.

Как задать дополнительные флаги санитайзера:

ya make --sanitizer-flag=“detect_leaks=1” --sanitizer-flag=“halt_on_error=0”

В этом примере заданы два флага для управления поведением санитайзера: активация обнаружения утечек памяти и отключение аварийного завершения программы при обнаружении ошибок.

Сценарии использования:

\- **Разработка и отладка**: На этапе разработки и тестирования программы использование различных флагов санитайзера может помочь быстрее обнаружить и исправить ошибки.
\- **Интеграционное и приемочное тестирование**: При автоматизированном тестировании использование специализированных флагов санитайзера позволяет настраивать уровень детализации отчетов об ошибках и поведение тестируемых приложений в условиях ошибок.
\- **Проверка безопасности и производительности**: Настройка санитайзеров для выполнения конкретных проверок может быть частью процесса аудита безопасности и оптимизации производительности.

Важное замечание:

Использование `--sanitizer-flag` требует знания возможных параметров конкретного санитайзера и понимания их влияния на процесс проверки. Некоторые флаги могут существенно повлиять на производительность и вывод программы, поэтому их следует выбирать в соответствии с текущими задачами и целями тестирования.

Опция `--lto` используется , чтобы включить в процесс компиляции и линковки Link Time Optimization (LTO). LTO — это метод оптимизации, выполняемый компоновщиком (линкером) при сборке исполняемых файлов или библиотек, что позволяет улучшить производительность и уменьшить размер итогового бинарного файла за счет анализа и оптимизации всего кода приложения в целом, а не отдельных его модулей.

Как работает LTO:

Традиционно, компиляция исходного кода на языках C/C\+\+ происходит по модулям или единицам трансляции, после чего компоновщик (линкер) собирает все объектные файлы в один исполняемый файл или библиотеку. Оптимизации, доступные компилятору, ограничены областью одной единицы трансляции. В отличие от этого, LTO позволяет линкеру анализировать и оптимизировать код на более глобальном уровне, имея доступ ко всему “плоскому” (т.е., уже развернутому) представлению программы.

При включении LTO компилятор генерирует дополнительные метаданные для каждой единицы трансляции, что позволяет линкеру применять межмодульные оптимизации. Это может включать удаление неиспользуемого кода (“dead code elimination”), инлайнинг функций между модулями, оптимизацию обращений к памяти и другие трансформации.

Преимущества использования LTO:

1\. **Улучшение производительности:** Межмодульные оптимизации могут значительно сократить количество инструкций и обращений к памяти, что приводит к повышению скорости работы программы.
2\. **Сокращение размера:** Удаление неиспользуемого кода и инлайнинг функций может уменьшить размер итогового бинарного файла.
3\. **Повышение безопасности:** Оптимизации позволяют устранить код, который может содержать потенциальные уязвимости.

Пример

ya make --lto

Эта команда запускает сборку проекта с включенным LTO, что предполагает оптимизацию на этапе линковки.

Важные замечания:

\- **Время сборки:** Включение LTO может существенно увеличить время компиляции и линковки, так как требуется дополнительный анализ и оптимизация всего кода.
\- **Требования к памяти:** Процесс с LTO потребляет больше оперативной памяти из-за необходимости загрузки и обработки большего количества данных.
\- **Совместимость:** Не все сторонние библиотеки могут корректно поддерживать LTO, особенно если они предполагают определённые “соглашения” на уровне двоичного кода, которые могут быть нарушены межмодульными оптимизациями.

Опция `--thinlto` активирует использование технологии Thin Link Time Optimization (ThinLTO) при компиляции и линковке проекта. ThinLTO является усовершенствованной версией стандартного Link Time Optimization (LTO), предлагая баланс между скоростью сборки и эффективностью оптимизации кода, что делает её особенно привлекательной для крупных и сложных проектов.

Как работает ThinLTO:

ThinLTO улучшает процесс LTO, внедряя концепцию “разбавленного” (thin) представления модулей. В отличие от полного LTO, которое требует передачи всего кода каждого модуля компоновщику для глобальной оптимизации, ThinLTO создаёт сокращённые сводки модулей, содержащие достаточно информации для проведения межмодульных оптимизаций, таких как инлайнинг функций и удаление неиспользуемого кода. Эти сводки значительно меньше полных модулей по размеру и позволяют распараллелить обработку разных модулей, что ускоряет процесс оптимизации без значительной потери в её качестве.

Опция `--afl`  указывает на использование American Fuzzy Lop (AFL) в качестве инструмента для фаззинга (fuzz testing) вместо стандартно используемого libFuzzer. Фаззинг — это автоматизированный метод тестирования программного обеспечения, который заключается в подаче непредсказуемых или случайных данных на вход программам с целью обнаружения ошибок, уязвимостей или нестандартного поведения программа.

American Fuzzy Lop (AFL):

AFL — это широко известный и эффективный инструмент фаззинга, который автоматически генерирует входные данные, пытаясь вызвать сбои, зависания или другие ошибки в тестируемом программном обеспечении. AFL отслеживает изменения в поведении программы, вызванные различными вводимыми данными, используя техники, такие как инструментирование кода и генетические алгоритмы, чтобы эффективно исследовать пространство потенциальных входных данных. AFL часто используется для проверки устойчивости системы безопасности, поиска уязвимостей в бинарных файлах и анализа выполнения кода.

libFuzzer:

libFuzzer, с другой стороны, является библиотекой фаззинга, эффективно интегрированной с LLVM/Clang. Она предоставляет фреймворк для реализации фазз-тестов непосредственно в коде программы с использованием специальных “фазз-таргетов” — функций, принимающих на вход массив байтов как данные для тестирования. libFuzzer автоматически генерирует входные данные и управляет процессом исполнения тестов, анализируя покрытие кода и автоматически оптимизируя процесс поиска ошибок.

Пример использования опции `--afl`:

ya make --afl

Использование этой опции переключает контекст тестирования так, чтобы для фаззинга выбирался не libFuzzer, а AFL, что может быть предпочтительным в зависимости от конкретных требований проекта, специфики тестируемого программного обеспечения или предпочтений команды разработчиков.

Преимущества использования `--afl`:

\- **Широкий охват тестирования**: AFL известен своей способностью эффективно исследовать большие области кода и находить уникальные ошибки, что делает его мощным инструментом для повышения качества и безопасности программного обеспечения.
\- **Универсальность**: AFL может быть использован для тестирования программ на различных языках программирования и в разных средах выполнения.
\- **Автоматизация**: Как и libFuzzer, AFL стремится максимально автоматизировать процесс нахождения ошибок, но делает это, используя свой уникальный подход и алгоритмы, что может привести к обнаружению ошибок, пропущенных другими инструментами.

Выбор между AFL и libFuzzer (или их совместное использование) зависит от конкретных задач тестирования, требований к проекту, а также от доступной инфраструктуры. Каждый инструмент имеет свои сильные стороны и может быть более эффективен в различных сценариях.

Опция `--musl`  указывает на необходимость сборки проекта с использованием библиотеки musl libc вместо стандартной C библиотеки (glibc в большинстве Linux дистрибутивов). musl libc — это легковесная, высокопроизводительная и стандартно-совместимая реализация стандартной библиотеки языка программирования С, предназначенная для обеспечения простоты и эффективности.

Как работает musl libc:

musl libc предоставляет функционал, эквивалентный традиционной glibc, но с упором на простоту реализации, меньший размер бинарных файлов и меньшее потребление ресурсов системы. Это делает musl libc популярным выбором для статически собранных приложений, контейнеризации, встраиваемых систем и других сценариев, где важна минимизация зависимостей и ресурсов.

Преимущества использования musl libc:

1\. **Портативность**: Программы, собранные со статической линковкой musl libc, могут выполняться на любом Linux дистрибутиве без необходимости в дополнительных зависимостях.
2\. **Меньший размер исходного кода и бинарных файлов**: musl имеет компактную реализацию, что ведет к созданию более мелких бинарных файлов.
3\. **Совместимость с POSIX**: musl стремится быть совместимым с POSIX, что обеспечивает хорошую переносимость кода между различными системами.
4\. **Безопасность и простота**: Благодаря своей простой структуре и ограниченному количеству кода, musl libc облегчает аудит кода и уменьшает площадь атаки, повышая таким образом безопасность приложений.

Важные замечания:

\- При переключении на musl libc разработчики должны учитывать, что некоторые особенности, эксклюзивные для glibc, могут быть недоступны.
\- Не все сторонние библиотеки и зависимости могут быть совместимы с musl libc без внесения изменений.
\- Использование musl может потребовать адаптации кода, особенно в частях, где ранее эксплуатировались специфичные для glibc особенности или расширения.

Опция `--hardening`  применяется для активации дополнительных механизмов защиты в процессе компиляции и линковки проекта. Эти механизмы защиты направлены на повышение безопасности исполняемого файла за счёт предотвращения или усложнения определённых типов атак, особенно связанных с переполнениями буфера, исполнением кода и другими уязвимостями, связанными с неправильной обработкой памяти.

Усиление защиты обычно включает в себя компиляцию с флагами, которые активируют специфические опции компилятора и линкера. Эти опции могут включать:

\- **Stack Protector**: Активация защиты стека с помощью `Stack Canary`, предотвращающей переполнения буфера на стеке.
\- **Position Independent Code (PIC) и Position Independent Executables (PIE)**: Создание кода, который может быть загружен в произвольное место в памяти, увеличивая эффективность использования ASLR (Address Space Layout Randomization), что затрудняет выполнение атак с переполнением буфера и возвратом в libc.
\- **Non-executable stack (NX)**: Помечает области стека как невыполнимые, что предотвращает исполнение произвольного кода в этих областях.
\- **Control Flow Integrity (CFI)**: Предотвращает атаки, изменяющие ход выполнения программы, путём ограничения мест, куда может быть перенаправлено выполнение (например, путём проверки адресов возврата и таблиц виртуальных функций).
\- **Relocation Read-Only (RELRO)**: Повышает уровень защиты динамически связанных программ путём ограничения изменяемости определённых сегментов данных.

Опция `--cuda=CUDA_PLATFORM` в контексте инструмента сборки `ya make` позволяет управлять интеграцией и использованием технологии NVIDIA CUDA при сборке проекта. CUDA (Compute Unified Device Architecture) — это параллельная вычислительная платформа и программная модель, разработанная NVIDIA, позволяющая значительно увеличить вычислительную производительность за счёт использования мощности графических процессоров (GPU).

Опция `--cuda` может принимать одно из трёх значений: `optional`, `required`, `disabled`, что определяет способ обращения сборочного процесса к функциональности CUDA.

\### Значения опции `--cuda`:

\- **optional** (по умолчанию): Сборка будет пытаться найти и использовать CUDA, если она доступна в системе. Если CUDA не найдена, сборка продолжится, исключив функции, зависящие от CUDA. Этот режим полезен, когда проект может использовать CUDA для ускорения, но не зависит от неё полностью, и может быть собран и функционировать без CUDA.

\- **required**: Указывает, что использование CUDA необходимо для сборки проекта. Сборка будет прервана с ошибкой, если компоненты CUDA недоступны. Применяется в случаях, когда функциональность или компоненты проекта строго зависят от CUDA и не могут быть реализованы без неё.

\- **disabled**: Полностью отключает поддержку и использование CUDA в проекте, даже если она доступна. Это может быть полезно, когда требуется гарантировать, что проект собран исключительно без использования GPU или для сборки проекта в среде, где CUDA не желательна или не может быть использована по лицензионным или другим соображениям.

Примеры использования опции `--cuda`:

ya make --cuda=required
Эта команда настаивает на необходимости использования CUDA, и сборка будет прервана, если CUDA не доступна.

ya make --cuda=disabled
Эта команда запрещает использование CUDA, обеспечивая, что в процессе сборки не будет попыток её использования.

Практическое применение:

\- **Разработка приложений с интенсивными вычислениями**: Программы, занимающиеся обработкой изображений, машинным обучением, научными расчётами, могут значительно выиграть от использования CUDA для ускорения расчётов.
\- **Кросс-платформенная разработка**: Опции позволяют гибко подходить к сборке проектов, которые должны работать как на системах с поддержкой CUDA, так и без неё.
\- **Тестирование и разработка ПО**: Отключение CUDA может быть полезно для тестирования производительности программ на CPU, в сравнении с GPU, или для обеспечения работы программы в разных средах.

Опция `--host-build-type=HOST_BUILD_TYPE` позволяет явно указать тип сборки, который должен быть применён к компонентам, работающим на платформе хоста — то есть, на системе, где производится компиляция кода проекта. Эта опция предоставляет возможность точно настроить, какие оптимизации, флаги компиляции и другие параметры сборки будут использоваться для создания исполняемых файлов и библиотек, влияющих на процесс сборки, но не на само приложение, предназначенное для запуска на целевой платформе.

Значения `HOST_BUILD_TYPE`:

\- `debug`: Сборка без оптимизаций и с полной отладочной информацией. Идеально подходит для отладки сборочного процесса или инструментов сборки, когда требуется полное понимание происходящего в процессе компиляции и линковки.

\- `release`: Этот тип сборки активирует оптимизации компилятора и может сокращать отладочную информацию для повышения производительности исполняемых файлов, используемых в процессе сборки. Более подходит для ускорения самого процесса сборки.

\- `profile`, `gprof`, `valgrind`, `valgrind-release`, `coverage`, `relwithdebinfo`, `minsizerel`, `debugnoasserts`, `fastdebug`: Эти типы определяют различные специализированные режимы сборки, адаптированные под профилирование, анализ производительности, проверку покрытия кода и т.п. Они позволяют настраивать процесс сборки с инструментами и опциями, оптимизированными под конкретные цели разработки и отладки.

Опция `--host-platform=HOST_PLATFORM` позволяет указать, для какой хостовой платформы (то есть платформы, на которой непосредственно выполняется сборка) должны быть собраны инструменты и зависимости проекта. Эта опция важна при кросс-компиляции, когда код, написанный и собираемый на одной платформе (хост), предназначен для выполнения на другой платформе (целевой).

Система сборки ya make позволяет отделить процесс [конфигурирования] от сборки и потому кроме задания *целевой платформы* можно указать *сборочную платформу* (опция `--host-platform`). Однако, эта возможность вам вряд ли понадобится в повседневной работе - для локальной сборки это имеет мало смысла, потому что, по умолчанию в качестве [целевой и сборочной платформ] выбирается та, где запущена сборка.

Как работает опция `--host-platform`:

Компиляторы и другие инструменты, необходимые для сборки проекта, могут иметь различную поддержку и поведение в зависимости от операционной системы и архитектуры хоста. Указание хостовой платформы помогает системе сборки выбрать подходящие версии инструментов и правильно настроить процесс сборки.

Примеры значений `HOST_PLATFORM`:

\- `linux-x86_64`: Указывает на Linux хост с архитектурой x86_64.
\- `darwin-arm64`: Обозначает хостовую платформу macOS с процессорами Apple Silicon (M1, M2 и т.д.).
\- `windows-x86_64`: Относится к хосту с операционной системой Windows и архитектурой x86_64.

Пример использования опции:

ya make --host-platform=linux-x86_64

Этот пример укажет системе сборки на необходимость использовать или собрать инструменты, оптимизированные для хоста с Linux и архитектурой x86_64.

Выбор правильной хостовой платформы важен для оптимизации процесса разработки и устранения потенциальных проблем с совместимостью. Однако, неправильное указание хостовой платформы может привести к осложнениям в сборке и, в некоторых случаях, к невозможности успешного выполнения сборки. Поэтому следует с осторожностью подходить к использованию этой опции, убедившись в корректности выбираемых значений для конкретной задачи.

Опция `--c-compiler=C_COMPILER` используется для указания конкретного компилятора языка C, который должен быть использован при компиляции исходного кода проекта. Это позволяет разработчику или сборочной системе выбрать определённую версию компилятора C или использовать альтернативные реализации вместо стандартного компилятора, предоставляемого средой разработки или операционной системой.

\### Пояснение:

Компиляторы C, такие как GCC (GNU Compiler Collection), Clang (разработанный проектом LLVM), и другие, могут иметь различия в реализации стандартов языка C, поддержке расширений, оптимизациях и предупреждениях. Выбор определённого компилятора может быть обусловлен необходимостью воспользоваться его уникальными возможностями или обеспечить совместимость с определённой кодовой базой или библиотеками.

\### Примеры использования:

1\. **Указание использовать компилятор GCC для сборки проекта:**

ya make --c-compiler=gcc

2\. **Указание использовать компилятор Clang для сборки проекта:**

ya make --c-compiler=clang

\- Необходимо убедиться, что выбранный компилятор установлен и настроен корректно на хостовой системе, где происходит сборка.
\- Миграция проекта с одного компилятора на другой может потребовать дополнительных усилий на адаптацию кода и конфигурации проекта из-за различий в реализации стандартов и поддержке расширений.
\- Для кросс-платформенных проектов может быть полезно иметь возможность собирать проект с использованием разных компиляторов в зависимости от целевой платформы и требований к производительности и совместимости.

Опция `--cxx-compiler=CXX_COMPILER` в контексте инструмента сборки `ya make`, используется для указания конкретного компилятора C\+\+, который должен использоваться для компиляции исходного кода проекта. Эта опция позволяет явно задать как абсолютный путь к исполняемому файлу компилятора, так и имя компилятора (в случае, если он доступен в стандартном пути поиска исполняемых файлов в операционной системе), для сборки как на платформе хоста, так и для целевой платформы.

Как работает опция `--cxx-compiler`:

При сборке проектов на C\+\+ необходимо использовать компилятор, который может быть специфичен для проекта или окружения, в котором он разрабатывается. Опция `--cxx-compiler` позволяет переопределить стандартный выбор компилятора системы сборки на заданный пользователем, что особенно полезно в следующих случаях:

Пример использования:

Допустим, у вас есть специально собранный компилятор Clang, расположенный в `/opt/clang/bin/clang++`, и вы хотите, чтобы именно он использовался для сборки вашего проекта:

ya make --cxx-compiler=/opt/clang/bin/clang\+\+

Или если вы хотите использовать конкретную версию g\+\+, доступную в вашей системе под именем `g++-9`:

ya make --cxx-compiler=g\+±9

Опция `--pgo-add` в контексте инструмента сборки `ya make` используется для активации процесса создания Profile-Guided Optimization (PGO) профиля для вашего проекта. PGO — это техника оптимизации, которая позволяет компилятору собрать данные о выполнении программы при её реальной работе, а затем использовать эту информацию для более эффективной оптимизации на стадии последующей компиляции.

Как работает PGO:

1\. **Инструментирование**: Сначала происходит сборка исполняемого файла с включенным инструментированием. Это означает, что в исполняемый файл добавляется код, который во время выполнения программы собирает статистику о её работе, например, как часто вызываются определённые функции, пути выполнения кода и пр.

2\. **Сбор данных о выполнении**: Затем исполняемый файл запускается в нормальных для него условиях (или специально подготовленных сценариях), чтобы собрать данные о его работе. Эти данные автоматически сохраняются в файл профиля (по умолчанию — `default.profraw`).

3\. **Анализ и оптимизация**: Полученные профили используются для последующей сборки проекта с оптимизацией, учитывающей реальное использование кода. Это позволяет компилятору более эффективно оптимизировать программу, например, выполняя агрессивный инлайнинг часто вызываемых функций или оптимизируя ветвления кода.

Пример использования:

ya make --pgo-add

Эта команда соберёт инструментированную версию вашего проекта, готовую для сбора данных о выполнении.

Процесс использования PGO:

\- **Сбор профиля**: Выполните инструментированную сборку вашего проекта под нагрузкой или тестами, которые представляют типичные сценарии использования программы. Данные о выполнении будут автоматически записаны в файл профиля.
\- **Анализ профиля и оптимизация**: После сбора профиля используйте его для повторной сборки проекта с помощью опции `--pgo-use=<profile>`, чтобы оптимизировать программу, учитывая полученные реальные данные о её работе.

Замечания:

\- **Имя файла профиля**: Вы можете управлять именем и расположением файла профиля с помощью переменной окружения `LLVM_PROFILE_FILE`, используя шаблоны для указания имени и пути файла.
\- **Завершение работы программы**: Важно, чтобы программа завершала своё выполнение успешно, т.к. запись профиля в файл происходит в момент корректного завершения работы программы. Принудительное завершение может привести к потере или неполному сбору данных.

Использование PGO дает значительное улучшение производительности для многих программ, особенно тех, где критические участки кода или пути выполнения могут быть эффективно идентифицированы только при выполнении.

Опция `--pgo-use=PGO_USER_PATH` используется для указания пути к файлам профиля, сгенерированным в результате предыдущего выполнения программы с включенным [Profile-Guided Optimization](https://ru.wikipedia.org/wiki/Profile-guided_optimization) (PGO). Эти профили содержат ценные данные о выполнении программы, собранные в процессе работы инструментированной версии программы, собранной с опцией `--pgo-add`. Затем эти данные используются для оптимизации сборки проекта, позволяя компилятору производить более информированные и точные оптимизации на основе реального использования кода.

Работа PGO:

1\. **Сбор данных о выполнении**: Вначале, для сбора статистики о выполнении кода, проект компилируется с инструментацией PGO (`--pgo-add`), после чего исполняемый файл запускается для выполнения типичных задач или прохода через стандартные тестовые сценарии. В результате в файле (или файлах) профиля сохраняется информация о частоте выполнения различных частей кода.

2\. **Использование профиля для оптимизации**: На втором этапе, сборка проекта осуществляется с указанием пути к собранным профилям (`--pgo-use=PGO_USER_PATH`), что позволяет компилятору использовать эти данные для оптимизации генерируемого кода.

Пример использования:

Если предположить, что данные профиля сохранены в файле `profile-data/default.profraw`, то для использования этих данных в процессе оптимизации команда будет выглядеть следующим образом:

ya make --pgo-use=profile-data/default.profraw

Важные замечания:

\- **Формат файла**: Профили PGO должны быть в формате, совместимом с используемым компилятором. В примере с LLVM/Clang профиль должен быть предварительно сконвертирован в подходящий формат с помощью инструмента `llvm-profdata`.
\- **Путь к профилю**: Указывается абсолютный или относительный путь к профилю. Если используются glob-шаблоны, это позволяет легко указывать несколько профилей одновременно.
\- **Объединение профилей**: Для максимальной эффективности рекомендуется использовать объединённый набор данных из нескольких запусков программы, чтобы обеспечить всестороннюю оптимизацию.

Опция `--pic`  указывает на необходимость принудительного использования режима Position-Independent Code (PIC) в процессе компиляции исходного кода проекта. Этот режим широко используется при создании динамических библиотек, обеспечивая их совместимость и эффективность работы в различных адресных пространствах памяти, независимо от того, куда они были загружены при выполнении программы.

Что такое Position-Independent Code (PIC)?

Position-Independent Code — это тип машинного кода, выполнение которого не зависит от его физического адреса в памяти. Это достигается за счёт использования относительной адресации для инструкций перехода, доступа к данным и работы со статическими переменными, вместо абсолютной адресации. Такой подход позволяет программному коду быть более модульным, переносимым и легко внедряемым в другие приложения или системы в качестве динамически подключаемых библиотек или модулей.

Преимущества использования PIC:

1\. **Безопасность**: PIC уменьшает риск конфликтов адресов при загрузке библиотек в память, что повышает стабильность и безопасность приложений.
2\. **Эффективность памяти**: Один и тот же экземпляр кода библиотеки, собранной как PIC, может быть использован несколькими выполняющимися процессами, что снижает общее потребление оперативной памяти.
3\. **Переносимость**: PIC упрощает создание и использование библиотек в различных операционных системах и архитектурах, так как код не зависит от физического расположения в памяти.

Пример использования:

ya make --pic

Это указание системе сборки `ya make` компилировать весь код с флагами, необходимыми для генерации Position-Independent Code, ожидая, что полученные объектные файлы или библиотеки будут использоваться в качестве части более крупных, возможно динамически подключаемых систем.

Применение:

Режим PIC особенно важен и широко применяется при разработке:
\- Динамически подключаемых библиотек (shared libraries) для операционных систем на основе Unix и Linux, так как такие библиотеки часто загружаются в произвольные области адресного пространства.
\- Переносимого кода, предназначенного для использования на разных платформах или в пространствах исполнения, где не гарантировано фиксированное распределение адресов.

Важные замечания:

\- **Производительность**: Хотя использование PIC имеет множество преимуществ, оно может незначительно снизить производительность исполнения кода из-за дополнительных вычислений относительных адресов. Важно взвесить преимущества безопасности и переносимости по отношению к потенциальному снижению скорости исполнения при выборе использования PIC для конкретного проекта.
\- **Необходимость для динамических библиотек**: Несмотря на возможное незначительное снижение производительности, для большинства операционных систем PIC является обязательным условием для динамически подключаемых библиотек.

Не нашел

Опция `--maps-mobile`  активирует специальный набор настроек сборки, оптимизированный для разработки мобильных приложений с использованием Карт (Maps for mobile devices). Этот пресет конфигурации включает в себя определённые флаги компиляции, линковки и другие параметры сборки, нацеленные на улучшение производительности, снижение потребления памяти и минимизацию размера итогового кода приложения, что критично для мобильных устройств с ограниченными ресурсами.

Как работает `--maps-mobile`:

При активации этой опции система сборки автоматически настраивает окружение сборки и компиляции проекта таким образом, чтобы максимально соответствовать специфическим требованиям к разработке мобильных приложений. Включение этой опции приводит к применению набора оптимизаций, которые могут включать, но не ограничиваются следующим:

\- **Оптимизация для малого использования памяти**: Применяются техники и методы, нацеленные на уменьшение объёма потребления оперативной памяти приложением.
\- **Сжатие ресурсов**: Активируется автоматическое сжатие графических и других ресурсов, чтобы уменьшить размер исполняемого файла и сократить потребление памяти.
\- **Уменьшение размера исполняемого файла**: Применяются специальные флаги компилятора и линкера, нацеленные на снижение размера бинарных файлов.
\- **Оптимизации производительности для мобильных устройств**: Включение функций и методик оптимизации кода, специфичных для мобильной архитектуры и процессоров, что обеспечивает повышенную эффективность исполнения на мобильных платформах.

Важные замечания:

\- **Целевая платформа**: Необходимо учитывать, что опция `--maps-mobile` нацелена исключительно на разработку мобильных приложений и может быть не совместима или не желательна для проектов, предназначенных для других целевых платформ, например, десктопных приложений или серверного ПО.

{% cut "Под яндекс карты" %}

ПЕреписал под яндекс карты (уточнить у разработчиков)

Опция `--maps-mobile` в контексте системы сборки `ya make`, используемой в проектах Yandex, таких как Аркадия, активирует специальный набор настроек сборки, оптимизированный для разработки мобильных приложений Яндекс Карт (Yandex Maps for mobile devices). Этот пресет конфигурации включает в себя определённые флаги компиляции, линковки и другие параметры сборки, нацеленные на улучшение производительности, снижение потребления памяти и минимизацию размера итогового кода приложения, что критично для мобильных устройств с ограниченными ресурсами.

Как работает `--maps-mobile`:

При активации этой опции система сборки автоматически настраивает окружение сборки и компиляции проекта таким образом, чтобы максимально соответствовать специфическим требованиям к разработке мобильных приложений. Включение этой опции приводит к применению набора оптимизаций, которые могут включать, но не ограничиваются следующим:

\- **Оптимизация для малого использования памяти**: Применяются техники и методы, нацеленные на уменьшение объёма потребления оперативной памяти приложением.
\- **Сжатие ресурсов**: Активируется автоматическое сжатие графических и других ресурсов, чтобы уменьшить размер исполняемого файла и сократить потребление памяти.
\- **Уменьшение размера исполняемого файла**: Применяются специальные флаги компилятора и линкера, нацеленные на снижение размера бинарных файлов.
\- **Оптимизации производительности для мобильных устройств**: Включение функций и методик оптимизации кода, специфичных для мобильной архитектуры и процессоров, что обеспечивает повышенную эффективность исполнения на мобильных платформах.

Пример использования:

ya make --maps-mobile

Эта команда начнёт процесс сборки проекта Яндекс Карт для мобильных устройств с активированными пресетами оптимизаций для мобильных платформ.

\### Важные замечания:

\- **Целевая платформа**: Необходимо учитывать, что опция `--maps-mobile` нацелена исключительно на разработку мобильных приложений и может быть не совместима или не желательна для проектов, предназначенных для других целевых платформ, например, десктопных приложений или серверного ПО.
\- **Документация и поддержка**: Работа с такими специфическими настройками требует хорошего понимания их влияния на процесс сборки и исполнение приложения. Важно ознакомиться с документацией по используемым оптимизациям и протестировать приложение на целевых устройствах для идентификации потенциальных проблем, связанных с оптимизациями.

Использование пресета конфигурации `--maps-mobile` обеспечивает разработчикам доступ к специализированным инструментам и методам оптимизации проектов под конкретные требования мобильных приложений Яндекс Карт, поддерживая высокие стандарты производительности и эффективности использования ресурсов на мобильных устройствах.

{% endcut %}

**Экспертные опции**

Опция `--sanitize-coverage=SANITIZE_COVERAGE`  используется для активации сбора данных о покрытии кода при выполнении инструментами санитайзера. Санитайзеры — это инструменты, встроенные в компиляторы (например, в Clang или GCC), которые предназначены для обнаружения различных видов ошибок в программе, таких как переполнения буфера, использование неинициализированной памяти, утечки памяти и другие.

Что такое покрытие санитайзером:

Покрытие санитайзером (Sanitizer Coverage) — это механизм, который позволяет собирать информацию о том, какие части кода были выполнены во время тестирования. Это предоставляет важные данные для анализа эффективности тестов и обнаружения участков кода, которые не покрыты тестами и потенциально могут содержать необнаруженные ошибки или уязвимости.

Как работает `--sanitize-coverage`:

При активации этой опции компилятор вставляет в бинарный код дополнительные инструкции, которые регистрируют, какие строки кода, функции или условные переходы были выполнены в процессе работы программы. Эти данные могут быть использованы для анализа и создания отчётов о покрытии кода тестами.

Примеры значений `SANITIZE_COVERAGE`: ПЕРЕПРОВЕРИТЬ

\- `func`: Собираются данные о вызовах функций.
\- `bb`: Собирается информация о покрытии базовых блоков программы (базовый блок — это фрагмент кода, который выполняется линейно без ветвлений).
\- `edge`: Регистрируется информация о переходах между базовыми блоками, что позволяет анализировать покрытие различных ветвей выполнения кода.

Пример использования:

ya make --sanitize-coverage=func

Эта команда инициирует сборку проекта с включённым сбором данных о покрытии кода на уровне вызовов функций. Это поможет анализировать, какие функции были задействованы при выполнении тестов.

Практическое значение:

\- **Улучшение качества тестирования**: Подробные отчёты о покрытии кода помогают определить “слепые зоны”, которые не проверяются текущим набором тестов.
\- **Обнаружение мёртвого кода**: Анализ покрытия может выявить код, который никогда не выполняется, что указывает на потенциальный мёртвый или устаревший код.
\- **Оптимизация процесса разработки**: Информация о покрытии помогает сфокусировать усилия разработчиков и тестировщиков на участках кода с недостаточным покрытием, улучшая тем самым общее качество и надёжность программного обеспечения.

Использование опции `--sanitize-coverage` требует внимательного планирования и анализа результатов, так как активация этой опции может незначительно повлиять на производительность исполняемого файла из-за дополнительной нагрузки, связанной с регистрацией данных о покрытии. Однако, преимущества, получаемые от глубокого анализа покрытия кода, как правило, перевешивают эти накладные расходы, делая инструмент весьма полезным в процессе разработки.

Проверка нужна

Опция `--target-platform-build-type=TARGET_PLATFORM_BUILD_TYPE`  позволяет определить тип сборки для конкретной целевой платформы, когда проект компилируется для нескольких различных платформ. Эта опция дает возможность уточнить стратегию компиляции и линковки, применяемую к коду, что позволяет оптимизировать скомпилированное приложение или библиотеку под конкретные характеристики и требования выбранной целевой платформы.

Значение `TARGET_PLATFORM_BUILD_TYPE` указывает на конкретный тип сборки, который может быть одним из следующих или других, зависящих от специфики проекта и доступных опций компилятора:

\- `debug`: Создает сборку с отладочной информацией и без оптимизаций, что упрощает отладку, но может снижать производительность.
\- `release`: Сборка для релиза с активированными оптимизациями компилятора и с минимальной или отсутствующей отладочной информацией, что обеспечивает максимальную производительность.
\- `profile`: Сборка предназначена для профилирования, включает механизмы и метки времени выполнения для измерения производительности различных частей кода.
\- `coverage`: Включает инструменты для измерения покрытия кода тестами, помогает определить, какие строки кода были выполнены во время работы тестов.
\- И другие типы сборок, со специфическими флагами и настройками компилятора, влияющими на производительность, размер исполняемых файлов, безопасность и другие аспекты.

\### Пример использования:

Допустим, ваш проект предназначен для развертывания как на серверах с Linux, так и на устройствах с Windows. Вы хотите, чтобы для Linux использовалась сборка `release`, а для Windows — `debug`. В этом случае вы можете указать:

ya make --target-platform linux-x86_64 --target-platform-build-type=release --target-platform windows-x86_64 --target-platform-build-type=debug

Это гарантирует, что для каждой целевой платформы будут применены оптимальные настройки сборки.

\### Важные замечания:

\- **Гибкость конфигурации**: Эта опция предлагает значительную гибкость в конфигурировании процесса сборки, позволяя разработчикам точно адаптировать поведение и результаты компиляции под специфику каждой целевой платформы.
\- **Контекст опции**: Как правило, `--target-platform-build-type` применяется непосредственно после опции, указывающей на целевую платформу (`--target-platform`), чтобы явно определить тип сборки для этой платформы. Если указано несколько целевых платформ, для каждой из них можно задать свой тип сборки.
\- **Влияние на производительность и размер**: Выбор типа сборки напрямую влияет на производительность и размер итогового исполняемого файла или библиотеки, поэтому крайне важно выбирать тип сборки, соответствующий требованиям приложения и ожиданиям пользователей.

Опция `--target-platform-release` в контексте инструмента сборки `ya make` используется для явного указания, что сборка проекта для последней назначенной целевой платформы должна быть выполнена в режиме `release`. Этот режим сборки оптимизирован для максимальной производительности и минимального размера итогового продукта, поскольку включает в себя различные оптимизации компилятора и, как правило, исключает отладочную информацию, которая может быть не нужна в финальной версии программы.

Пример использования:

Предположим, что проект разрабатывается для нескольких платформ, но для целевой платформы Windows требуется создать более оптимизированную версию для релиза:

ya make --target-platform windows-x86_64 --target-platform-release

Эта команда установит тип сборки в `release` для платформы Windows x86_64, активировав соответствующие оптимизации и настройки сборки.

Значение и использование:

\- **Финальный релиз**: Опция `--target-platform-release` особенно актуальна, когда предстоит подготовка финальной версии продукта к публикации или развертыванию. Она гарантирует, что приложение будет оптимизировано для лучшего взаимодействия с пользователем и более высокой производительности.
\- **Кросс-платформенная разработка**: В среде разработки, где требуется поддержка нескольких платформ, использование `--target-platform-release` позволяет гарантировать, что для каждой из целевых платформ будут применены наиболее подходящие оптимизации.
\- **Тестирование производительности**: Часто релизные сборки также используются при проведении тестов производительности или нагрузочных тестов, чтобы оценить, как программное обеспечение будет работать в условиях, максимально приближенных к реальным.

Опция `--target-platform-debug`  предназначена для установления типа сборки в режим “отладка” (debug mode) для последней указанной целевой платформы. Этот режим обычно используется в процессе разработки и отладки программного обеспечения, поскольку он предоставляет разработчикам расширенную информацию для диагностики и исправления ошибок, а также упрощает процедуру отладки благодаря включению отладочных символов и отключению оптимизаций компилятора.

Когда проект собирается с использованием этой опции, компилятор настраивается на генерацию дополнительной отладочной информации и символов, что позволяет отладчикам получать доступ к именам переменных, строкам исходного кода и стеку вызовов во время выполнения программы.

Если вы работаете над мультиплатформенным проектом и хотите убедиться, что сборка для определенной платформы, например Android, выполнена в режиме отладки, то используйте следующую команду:

ya make --target-platform android-arm64 --target-platform-debug

Опция `--target-platform-tests` предназначена для запуска тестов, специфичных для последней указанной в команде целевой платформы. Эта функциональность позволяет разработчикам и тестировщикам выполнить автоматизированные тесты, которые могут включать юнит-тесты, интеграционные тесты или другие виды тестирования, для проверки корректности работы приложения или библиотеки в условиях выбранной целевой платформы. Это особенно актуально в среде мультиплатформенной разработки, где требуется обеспечить надежное функционирование программного обеспечения на разнообразном оборудовании и операционных системах.

Когда вы используете `--target-platform-tests` в своей команде сборки, `ya make` настраивает среду сборки таким образом, чтобы тестируемое ПО было скомпилировано и подготовлено специально для ранее указанной целевой платформы. После компиляции запускаются тесты, которые были разработаны или настроены для выполнения на этой платформе. Это даёт возможность автоматически проверить, соответствует ли код стандартам качества и работоспособности на конкретном типе оборудования или в определённой операционной системе.

Предположим, что вы разрабатываете приложение, которое должно работать как на Windows, так и на Linux. Чтобы запустить тесты для Windows-версии приложения, вы могли бы использовать следующую команду:

ya make --target-platform windows-x86_64 --target-platform-tests

Это запустит процесс сборки приложения для Windows на архитектуре x86_64, после чего будут запущены тесты, специально предназначенные или адаптированные для этой платформы.

Значение и использование:

\- **Кросс-платформенная совместимость**: Важно проверить, что приложение работает корректно в различных средах. В зависимости от платформы могут возникать уникальные проблемы, связанные с различиями в файловой системе, сетевых настройках, доступности библиотек и т.д.
\- **Автоматизация тестирования**: Автоматический запуск тестов для конкретной платформы экономит время и ресурсы разработчиков и тестировщиков, позволяя быстрее выявлять и исправлять ошибки.

Опция `--target-platform-test-type=TARGET_PLATFORM_TEST_TYPE`  используется для запуска определённого типа тестов для указанной целевой платформы. Этот параметр позволяет более точно настроить тестирование, ограничиваясь определённым типом тестов, что особенно полезно в мультиплатформенной разработке, когда для разных платформ могут быть предусмотрены различные наборы тестов в зависимости от специфики платформы, требований к тестированию или наличия ресурсов.

ПРОВЕРИТЬ

Значение `TARGET_PLATFORM_TEST_TYPE` определяет тип тестов, которые должны быть выполнены. Типы тестов могут включать, но не ограничиваются следующими:

\- `unit`: Запуск юнит-тестов, направленных на проверку отдельных модулей или классов в изоляции от остальной части системы.
\- `integration`: Запуск интеграционных тестов, проверяющих взаимодействие между различными модулями или сервисами.
\- `functional`: Выполнение функциональных тестов, сосредоточенных на проверке определённых функций приложения с точки зрения конечного пользователя.
\- `performance`: Запуск тестов производительности для измерения времени отклика, использования ресурсов и других показателей производительности в рамках заданных сценариев.
\- `acceptance`: Выполнение приемочных тестов, которые проверяют приложение на соответствие требованиям заказчика или спецификациям.

Допустим, вы хотите запустить только юнит-тесты для вашего проекта на целевой платформе Android:

ya make --target-platform android-arm64 --target-platform-test-type=unit

Эта команда настроит среду сборки таким образом, чтобы для Android на архитектуре arm64 были запущены исключительно юнит-тесты.
Несмотря на полезность запуска тестов определённого типа, важно не пренебрегать комплексным тестированием, чтобы обеспечить всестороннее покрытие и качество программного продукта.

Опция `--target-platform-regular-tests`  является специализированной командой, которая инициирует запуск тестов, ограничиваясь предопределенным набором типов тестов, оптимизированных для выполнения на последней указанной целевой платформе. Эта функциональность ценна в средах мультиплатформенной разработки, где важно эффективно распределить ресурсы тестирования и сосредоточить усилия на ключевых аспектах верификации программного обеспечения.

ВОПРОСИК (benchmark boost_test exectest fuzz g_benchmark go_bench go_test gtest hermione java jest py2test py3test pytest unittest)

Типы тестов включенные в `--target-platform-regular-tests`:

\- **benchmark**: Тесты производительности, оценивающие скорость или эффективность различных аспектов программы.
\- **boost_test**: Тесты, основанные на библиотеке Boost.Test, предоставляющей обширные возможности для юнит-тестирования в проектах на C\+\+.
\- **exectest**: Тесты, предполагающие выполнение и анализ результатов работы исполняемых файлов или скриптов.
\- **fuzz**: Фаззинг тесты, ориентированные на автоматическое обнаружение ошибок и уязвимостей путём подачи неожиданных или случайных данных в программу.
\- **g_benchmark**: Тесты Google Benchmark, специализирующиеся на микро-бенчмаркинге компонентов C\+\+ программ.
\- **go_bench**: Тесты производительности для Go, использующие встроенный инструментарий языка для бенчмаркинга.
\- **go_test**: Стандартные юнит-тесты для Go, исполняемые средствами самого языка.
\- **gtest**: Тесты на основе Google Test Framework, широко применяемые для юнит-тестирования C\+\+ кода.
\- **hermione**: Тесты для веб-приложений, использующие Hermione - инструмент для интеграционного тестирования полного стека.
\- **java, jest, py2test, py3test, pytest**: Тесты для соответствующих языков программирования и тестовых фреймворков, ориентированные на юнит и интеграционное тестирование.
\- **unittest**: Стандартные юнит-тесты для многих языков программирования, включая Python и другие, следующие этому соглашению.

Пример использования:

ya make --target-platform=linux-x86_64 --target-platform-regular-tests

Эта команда запускает стандартный набор тестов для проекта, предназначенного для выполнения на Linux с архитектурой x86_64.

Опция `--target-platform-c-compiler=TARGET_PLATFORM_COMPILER` в контексте инструмента сборки `ya make` позволяет определить и установить пользовательский компилятор языка C для компиляции проекта, специфично для указанной целевой платформы. Это означает, что разработчики могут указать конкретный путь к исполняемому файлу компилятора C, который должен использоваться вместо стандартного или иного компилятора по умолчанию, определенного в системе сборки.

Опция предоставляет разработчикам возможность более гибко управлять процессом сборки программного обеспечения на языке C, позволяя использовать различные версии компиляторов или специализированные компиляторы, адаптированные под конкретные требования проекта или особенности целевой платформы.

Практические применения:

1\. **Решение зависимостей проекта**: Некоторые проекты могут зависеть от функций или поведения, специфичных для конкретного компилятора или его версии. Указание конкретного компилятора обеспечивает нужную совместимость и предотвращает возможные ошибки компиляции.

2\. **Кросс-компиляция**: В сценариях кросс-компиляции, где код разрабатываемой программы подготавливается для исполнения на платформе, отличной от хостовой системы разработчика, необходимо указание конкретного компилятора, настроенного на работу с целевой платформой.

3\.  **Обеспечение однородности сборки**: Указание конкретного компилятора гарантирует, что все разработчики и среды сборки используют один и тот же компилятор.

Опция `--target-platform-cxx-compiler=TARGET_PLATFORM_COMPILER`  используется для явного указания компилятора C\+\+, который должен применяться при компиляции исходного кода на C\+\+ для целевой платформы.

При сборке проектов на C\+\+, разработчики могут столкнуться с необходимостью использовать определённые версии компиляторов или специфические компиляторы (например, для использования новых стандартов C\+\+, особенностей компиляции или оптимизации). Определение этого компилятора через опцию `--target-platform-cxx-compiler` позволяет  применить выбранный компилятор для сборки кода, обеспечивая больший контроль над процессом сборки и выходными данными.

Когда разработчики создают приложения, предназначенные для работы на нескольких платформах, возможно, потребуется использование разных компиляторов для оптимальной поддержки каждой из платформ.

Проверить кажется не нашел

Опция `--target-platform-target=TARGET_PLATFORM_TARGET`  позволяет указать конкретные цели сборки (build targets) для последней определённой целевой платформы, в контексте корневого каталога исходного кода проекта. Эта функциональность обеспечивает высокий уровень гранулярности и контроля над процессом сборки, позволяя разработчикам конкретизировать, какие именно компоненты или модули проекта необходимо собрать для указанной платформы.

При использовании системы сборки `ya make`, цели сборки могут включать отдельные исполняемые файлы, библиотеки, тесты или другие ресурсы, которые должны быть скомпилированы или собраны из исходного кода. Через опцию `--target-platform-target` можно явно указать список таких целей, определяя их относительно корневого каталога исходного кода проекта. Это дает возможность точно задать, что именно требуется собрать, ориентировано на конкретные потребности разработки или тестирования для выбранной платформы.

Опция `--target-platform-ignore-recurses` используется для оптимизации процесса сборки путём предотвращения рекурсивной сборки зависимостей для заданных целей в контексте указанной целевой платформы. Эта функциональность особенно полезна в ситуациях, когда требуется собрать конкретные компоненты проекта без автоматической компиляции всех связанных с ними зависимостей, которые обычно обрабатываются системой сборки рекурсивно.

По умолчанию, система сборки `ya make`, идентифицирует и автоматически собирает все зависимости для каждой указанной цели сборки, чтобы гарантировать корректность и полноту конечного продукта. Это означает, что если модуль А зависит от модуля B, система сборки автоматически сначала соберёт модуль B перед сборкой модуля A.

Использование опции `--target-platform-ignore-recurses` позволяет отключить эту автоматическую рекурсивную сборку, ограничив сборку только явно указанными в команде целями, несмотря на их внутренние зависимости. Это может быть полезно для ускорения сборки в средах разработки, когда разработчики работают над конкретной частью проекта и не требуют полной компиляции всех зависимых модулей.

## Локальный кеш

\--cache-stat — перед сборкой выдать статистику по наполнению локального кэша

Опция `--cache-stat` предназначена для получения подробной статистики по состоянию локального кеша сборки. Локальный кеш  — это хранилище на диске, где сохраняются результаты сборок, промежуточные файлы и другие данные, которые могут быть повторно использованы для ускорения последующих процессов сборки.

При запуске сборки с этой опцией, до начала самого процесса сборки, система анализирует содержимое локального кеша и выводит статистику, которая может включать следующую информацию:

\- **Общий размер кеша:** Показывает, сколько дискового пространства занимает локальный кеш. Это полезно для понимания, насколько интенсивно кеш используется и сколько места он занимает на диске.
\- **Число объектов:** Сколько всего файлов или объектов содержится в кеше. Это может включать как результаты сборок, так и промежуточные файлы.
\- **Использование по типам файлов:** Детальное разбиение, показывающее, какие типы файлов занимают больше всего места в кеше.
\- **Время жизни данных:** Насколько давно кеш не обновлялся и сколько времени данные остаются актуальными.
\- **Статистика по истечении срока хранения:** Сколько объектов было автоматически удалено из кеша из-за истечения срока их актуальности или политики очистки.
\- **Степень переиспользования кеша:** Насколько эффективно кеш используется для ускорения сборок, т.е. сколько процентов от общего числа запросов к кешу успешно находит переиспользуемые данные.

Из документации 
`Cache efficiency ratio` - отношение пересобранного к общему числу нод в графе. Из графа построения были исполнены только 87 узлов (14617 - 14530). Результаты остальных узлов пришли из локального или распределенного кэша или оказались не нужны вовсе поскольку результаты их обработки были подняты из кэша (см. `avoided` ниже).

* `local` - количество узлов, результаты которых были взяты из локального кеша

* `dist` - количество узлов, результаты которых были взяты из распределённого кеша

* `by dynamic uid` - количество узлов, результаты которых были взяты из [content uids] кеша.

* `avoided` - количество узлов, до которых не дошло исполнение вовсе - их даже не поднимали из кеша (например в графе `X -> Y -> Z`, `X` будет avoided, если нужно было исполнить `Z`, и для этого поднять `Y` из кеша. `Z` может даже не быть в кеше - он никому не потребовался для выполнения)

Опция `--gc`  используется для проведения операции “сбора мусора” на диске, где хранятся данные кеша сборки. Эта операция предназначена для удаления устаревших или неиспользуемых файлов кеша, что позволяет освободить дисковое пространство и повысить эффективность процесса сборки за счет уменьшения объема данных для просмотра и обработки.

Запуск с этой опцией инициирует процесс, в ходе которого система анализирует содержимое локального кеша сборки и удаляет:

\- Все файлы и объекты, которые не связаны с текущим графом сборки. Граф сборки – это структура данных, отражающая зависимости между различными элементами проекта (например, исходные файлы, объектные файлы, библиотеки) и определяющая порядок выполнения задач сборки.
\- “UID из текущего графа” обозначает, что сохраняется только информация, прямо относящаяся к текущим задачам сборки, определенным в проекте зависимостям и конфигурациям. UID (уникальный идентификатор) используется для идентификации каждого элемента в графе. Удаление исключает те UID, которые не фигурируют в текущем графе сборки, тем самым оставляя только релевантные и потенциально переиспользуемые данные.

ya make --gc

Это указание системе пройтись по локальному кешу, очистить его от ненужных данных, не влияя при этом на актуальный граф сборки, и только после этого начать выполнение запрошенных задач сборки.

Документация

Кроме автоматической очистки кэшей, можно явно почистить диск с помощью команды `ya gc cache`. Вместе с очисткой делаются дополнительные проверки на ошибки.

Команда полностью удаляет

* все вспомогательные файлы, кроме тех, которые чистятся автоматически

* все временные файлы, кроме [локального кэша].

Файлы локального кэша сборки удаляются в соответствии с одним из фильтров:

```
--object-size-limit=OBJECT_SIZE_LIMIT
    Strip build cache from large objects (in MiB if not set explicitly)
--age-limit=AGE_LIMIT
    Strip build cache from old objects (in hours if not set explicitly)

```

Если не задан фильтр, то будет сделана очистка в соответствии с настройкой `cache_size`

Вы так же можете чистить репозиторий от сборочных symlink'ов c помощью команды `ya gc cache --gc-symlinks`.

Опция `--gc-symlinks` предназначена для тщательной очистки кеша сборки, фокусируясь в частности на удалении символических ссылок. Эти символические ссылки обычно указывают на результаты предыдущих сборок и используются для оптимизации процесса сборки за счет переиспользования уже сгенерированных ресурсов. 

Опция `--gc-symlinks` позволяет удалить эти ссылки, не затрагивая файлы, нужные для текущей сборки, определенной текущим графом зависимостей проекта.

При запуске команды с этой опцией система сборки проходит по всем символическим ссылкам, созданным в рамках кеширования результатов сборок, и удаляет те из них, которые уже не соответствуют ни одному элементу в текущем графе сборки. Граф сборки – это структура данных, описывающая все задачи сборки, их зависимости и порядок выполнения. “Текущий граф” относится к задачам и зависимостям, актуальным для запущенного процесса сборки, и определяется на основе анализа исходного кода и конфигураций сборки.

Эта опция применяется в командной строке при запуске процесса сборки или когда требуется выполнить очистку без непосредственного запуска сборки:

ya make --gc-symlinks

Использование `--gc-symlinks` часто комбинируют с другими опциями сборки для достижения более тонкой настройки процесса очистки.

Опция `--gc-symlinks` влияет только на символические ссылки, не затрагивая основных файлов ресурсов и исходного кода. Её использование безопасно в контексте поддержания чистоты и актуальности структуры кеша сборки, но требует понимания текущего состояния проекта и структуры его зависимостей, чтобы эффективно управлять процессом сборки.

Опция `--tools-cache-size=TOOLS_CACHE_SIZE` используется для задания ограничения на максимальный размер кэша инструментов.

Кэш инструментов — это специализированное хранилище на диске, предназначенное для сохранения различных компиляторов, библиотек, SDK, эмуляторов и других инструментов, которые используются в процессе сборки.

Эта опция позволяет управлять объемом дискового пространства, выделенного под кэширование таких инструментов, что помогает оптимизировать использование ресурсов системы.

При задании этой опции с определенным числовым значением, система сборки будет ограничивать использование дискового пространства под кэш инструментов заданным размером. Если в процессе выполнения сборки общий размер кэшированных инструментов превышает указанный лимит, система автоматически удалит наименее часто используемые (или самые старые) данные из кэша, чтобы освободить место и удерживать его размер в заданных рамках.

Пример

В командной строке, перед запуском процесса сборки, добавьте опцию `--tools-cache-size`, за которой следует значение, указывающее максимальный размер кэша инструментов. Например:

ya make --tools-cache-size=10GiB

Эта команда запустит сборку проекта, при этом максимальный размер кэша инструментов будет ограничен 10 гигабайтами.

Максимальный размер кеша инструментов (по умолчанию: 30.0GiB)

Важно помнить:

Необходимо находить баланс между размером кэша и объемом используемых инструментов. Слишком маленький размер кэша может привести к частым удалениям и повторным загрузкам одних и тех же инструментов, что отрицательно скажется на времени сборки.

Опция `--symlinks-ttl=SYMLINKS_TTL` используется для задания времени жизни (TTL, Time-To-Live) кеша результатов сборки, доступного через символические ссылки. Значение TTL указывает, как долго результаты сборки, представленные в виде символических ссылок, должны храниться в кеше, прежде чем будут автоматически удалены системой сборки для освобождения места или обновления данных. Задание TTL позволяет эффективно управлять ресурсами файловой системы, автоматически удаляя устаревшие или малоиспользуемые результаты сборки.

При указании этой опции с конкретным числовым значением, сборочная система будет отслеживать время существования каждой символической ссылки на результаты сборки в кеше. Как только для какой-либо ссылки прошедшее время превысит заданный TTL, соответствующий результат сборки (или ссылка на него) будет автоматически удален из кеша. Это предохраняет систему от переполнения устаревшими данными и помогает поддерживать кеш в актуальном и оптимизированном состоянии.

Эту опцию можно использовать при запуске команды сборки для указания системе, как долго хранить символические ссылки на результаты сборки в кеше. Например:

ya make --symlinks-ttl=72.0

В этом примере результаты сборки будут сохранены в кеше в течение 72 часов (3 суток) после их создания. По истечении этого времени, если они не будут использованы, система сборки автоматически удалит их.

Важно помнить:

\- Указываемое значение `SYMLINKS_TTL` обычно задаётся в часах. По умолчанию, как указано, оно составляет `168.0` часов, что равно одной неделе.

\- Правильное значение TTL будет зависеть от конкретного рабочего процесса разработки, частоты обновлений и ресурсов дискового пространства.

\- Настройка TTL требует уважительного подхода: слишком короткое значение может привести к частым пересборкам и увеличению времени сборки, тогда как слишком долгое — к ненужному занятию дискового пространства.

Опции --cache-size=CACHE_SIZE, --cache-codec=CACHE_CODEC, и --auto-clean=AUTO_CLEAN_RESULTS_CACHE представляют собой настройки, позволяющие детально управлять кешем результатов систем сборки. 

Эти опции позволяют оптимизировать использование дисковых ресурсов и процесс сборки в целом, обеспечивая эффективность и актуальность хранимых данных.

\--cache-size=CACHE_SIZE

Эта опция задаёт максимальный размер кеша результатов сборки, выраженный в гигабайтах или других единицах измерения. С её помощью можно ограничить объём дискового пространства, выделяемого под хранение результатов работы системы сборки, что помогает предотвратить чрезмерное использование дискового пространства.

* Пример использования:

  ya make --cache-size=100GiB

  Эта команда ограничит размер кеша 100 гигабайтами.

Почему это важно: Оптимальный размер кеша позволяет сбалансировать между доступным дисковым пространством и производительностью сборки за счёт минимизации необходимости повторного выполнения вычислительно сложных операций сборки.

\--cache-codec=CACHE_CODEC

Опция указывает на метод (алгоритм) кодирования, используемый для сжатия или прочего преобразования данных в кеше.

Пример использования: Не предоставлен из-за вариативности возможных значений, которые зависят от конкретной системы сборки и её реализации кеширования. 

Однако, это может быть что-то вроде --cache-codec=gzip для сжатого хранения данных.

Почему это важно: Использование кодеков может существенно уменьшить потребление дискового пространства за счёт хранения данных в сжатом виде, при этом потенциально увеличивая время доступа к данным из-за необходимости их распаковки.

\--auto-clean=AUTO_CLEAN_RESULTS_CACHE

Автоматическая очистка кеша результатов (по умолчанию: True)

Включает или отключает автоматическую очистку неактуальных или редко используемых данных в кеше. Когда эта опция активирована, система сборки будет самостоятельно контролировать состояние кеша и удалять из него устаревшие данные.

Пример использования:

* Чтобы включить автоматическую очистку: ya make --auto-clean=True
* Чтобы отключить автоматическую очистку: ya make --auto-clean=False

Почему это важно: Автоматическая очистка помогает поддерживать кеш результатов в актуальном состоянии, освобождая место для новых результатов сборки и предотвращая его бесполезное расширение за счёт устаревших данных. Это улучшает производительность сборки и оптимальное использование дискового пространства.

## Функциональные флаги

Опция `--no-local-executor` указывает системе сборки изменить метод выполнения субпроцессов во время сборки проекта. 

В стандартной конфигурации многие системы сборки, включая такие как `ya make`, используют специализированные “исполнители” или “executor’ы” для управления запуском и выполнением субпроцессов, таких как компиляция кода, линковка библиотек и т.п. 

Эти исполнители могут предоставлять дополнительные возможности для оптимизации и контроля процесса сборки, включая параллелизм, кэширование результатов и мониторинг состояния.

Однако, в некоторых случаях или для определенных задач может потребоваться отказаться от использования встроенного исполнителя в пользу стандартного механизма запуска процессов в операционной системе, предоставляемого модулем Popen из стандартной библиотеки Python. 

Это может быть необходимо из-за специфических требований к среде выполнения или для обеспечения совместимости с определенными внешними системами или инструментами.

Пример использования опции --no-local-executor:

ya make --no-local-executor

Эта команда запустит процесс сборки, где все субпроцессы будут исполнены с использованием Popen, обходя таким образом стандартную логику исполнителя сборочной системы.

Влияние использования Popen:

1. Совместимость: Popen позволяет запускать процессы в более “чистой” среде, что может быть необходимо для совместимости с определенными инструментами или сценариями использования, требующими стандартного поведения окружения ОС.

2. Прозрачность: Запуск субпроцессов через Popen может упростить отладку и анализ процесса сборки, поскольку поведение Popen хорошо документировано и широко известно разработчикам.

3. Ограничения: Отказ от использования специализированных исполнителей может привести к потере некоторых оптимизаций процесса сборки, предоставляемых системой сборки, таких как управление зависимостями на уровне задач и оптимизация параллельного выполнения задач.

Когда может потребоваться --no-local-executor:

* Специфичные требования: Некоторые процессы сборки могут требовать точного контроля над средой выполнения или специфических условий окружения, которые сложно или невозможно обеспечить с использованием стандартных исполнителей системы сборки.

* Интеграция с внешними инструментами: В случаях, когда процесс сборки должен интегрироваться с внешними инструментами или системами, которые ожидают стандартное поведение процессов ОС, использование Popen может облегчить эту интеграцию.

* Отладка и анализ: При решении проблем с процессом сборки использование Popen может упростить анализ и отладку за счет стандартизации способа запуска процессов.

Опция `--dir-outputs-test-mode` предназначена для активации экспериментальных или новых функций, связанных с обработкой вывода сборочных процессов в директории, в системах сборки, поддерживающих такой тип настройки. Это может включать улучшенное управление директориями для хранения результатов сборки, логов, артефактов или иных данных, генерируемых во время процесса сборки.

При использовании этой опции система сборки активирует новые или экспериментальные функции, которые могут быть ещё не включены по умолчанию из-за их тестового статуса или потенциальной нестабильности. Функциональность, связанная с директориями вывода, может варьироваться, но обычно включает в себя следующие аспекты:

\- Улучшенное разделение результатов сборки по директориям для обеспечения большего порядка и лучшей навигации.
\- Автоматическое удаление или архивация устаревших или временных директорий для оптимизации использования дискового пространства.
\- Возможность задания пользовательских правил для именования директорий, их структуры и хранения конкретных типов файлов/артефактов сборки.

Зачем это нужно:

\- **Тестирование нововведений:** Позволяет разработчикам и тестировщикам пробовать новые функции до их официального включения в стабильную версию системы сборки, чтобы оценить их полезность и влияние на процесс сборки.
\- **Оптимизация процесса сборки:** Улучшения, связанные с обработкой директорий вывода, могут способствовать более эффективному используему дискового пространства, упрощению поиска артефактов, а также к более удобной организации результатов сборки.
\- **Получение обратной связи:** Использование экспериментальных функций дает командам разработки инструментов сборки ценную информацию о том, как данные функции работают в различных условиях и насколько они полезны для пользователей.

Как использовать:

Для включения режима тестирования новых функций директорий вывода, необходимо добавить опцию `--dir-outputs-test-mode` при запуске процесса сборки:

ya make --dir-outputs-test-mode

Эта команда активирует режим с использованием новых функций для директорий вывода, предоставляя доступ к тестированию и оценке добавленных возможностей.

Важно помнить:

Экспериментальные функции могут быть изменены или даже удалены в будущих версиях, поэтому при их использовании следует учитывать потенциальный риск и влияние на стабильность сборки. Всегда рекомендуется проводить тестирование в условиях, минимизирующих влияние возможных проблем на важные процессы разработки и сборки.

Опция `--disable-runner-dir-outputs` используется в контексте систем сборки, которые поддерживают определенные особенности работы с выводами процесса сборки, в частности, управление выводами в виде директорий (dir_outputs). Эта настройка позволяет отключить функциональность, связанную с автоматическим управлением директориями для хранения результатов исполнения задач сборки.

В обычных условиях, при выполнении задач сборки, система может автоматически создавать и управлять директориями для хранения вывода каждой задачи, например, скомпилированные объектные файлы, генерируемые исходные коды, или временные файлы, требуемые в процессе. Это делается для упорядочения и оптимизации процесса сборки, а также для облегчения последующей навигации по результатам сборки.

Опция `--disable-runner-dir-outputs` позволяет отключить эту автоматизацию. Это может быть требуемо в случаях, когда автоматическое управление выводами не желательно или когда необходимо самостоятельно контролировать структуру и расположение файлов результатов сборки для интеграции с другими инструментами или из соображений совместимости.

Зачем это нужно:

1\. **Контроль и совместимость:** Ручной контроль над директориями вывода может быть необходим для обеспечения совместимости с определенными инструментами анализа, тестирования или развертывания, которые ожидают результаты сборки в конкретной структуре или расположении.

2\. **Специфические требования к проекту:** Некоторые проекты могут иметь уникальные требования к организации и хранению артефактов сборки, которые не могут быть эффективно выполнены с использованием стандартных механизмов автоматизации.

Как использовать:

Для отключения поддержки `dir_outputs` в исполнителе, необходимо добавить опцию `--disable-runner-dir-outputs` при запуске процесса сборки:

`ya make` --disable-runner-dir-outputs

Опция `--no-dump-debug` предназначена для управления выводом отладочной информации во время выполнения сборки проекта или других задач. Эта настройка позволяет отключить вывод расширенной отладочной информации или “дампов отладки”, которые могут быть генерированы сборочной системой для диагностики и анализа процесса сборки.

В обычном режиме работы система сборки автоматически генерирует различные типы отладочной информации или дампы, когда в процессе сборки возникают ошибки, предупреждения или для целей профилирования и оптимизации. 

К такой информации могут относиться логи вызовов функций, стек вызовов при сбоях, дампы памяти, статистика использования ресурсов и другие типы данных, полезные для разработчиков при диагностике и устранении проблем.

Опция `--no-dump-debug` указывает инструменту сборки не создавать или не сохранять эту расширенную отладочную информацию во время выполнения задач.

 В результате использования этой опции объем генерируемых логов и файлов отладки может существенно сократиться, что может помочь ускорить процесс сборки и уменьшить затраты дискового пространства, особенно в крупных проектах.

Зачем это нужно:

* Ускорение процесса сборки: Отключение генерации отладочных дампов может снизить время выполнения сборки за счет уменьшения количества дополнительных операций записи на диск.
* Сокращение использования дискового пространства: Отлаженные дампы и логи могут занимать значительное место на диске; их отключение помогает оптимизировать использование ресурсов, особенно в ограниченных или общих средах.
* Упрощение процесса разработки: В некоторых случаях, когда разработка уже находится в стадии стабилизации или когда детальный дебаг не требуется, эта опция помогает снизить “шум” от множества логов и дампов, упрощая анализ результатов сборки.

Чтобы включить этот режим, необходимо добавить опцию --no-dump-debug в команду запуска сборки:

ya make --no-dump-debug

Важно помнить:

* Включение этой опции может сделать диагностику ошибок и предупреждений более сложной, поскольку уменьшается количество доступной отладочной информации.
* Прежде чем использовать --no-dump-debug в процессе активной разработки или отладки, рекомендуется взвесить потенциальные преимущества сокращения логов перед возможным ухудшением доступа к полезным данным для диагностики.
* Эта опция может быть особенно полезна на этапах продакшен-сборки или когда требуется оптимизация процесса сборки и использования ресурсов.

## Загрузка

Опция `--ttl=TTL` используется для управления временем жизни (TTL, Time To Live) ресурсов или данных. Эта опция позволяет указать, на какой срок ресурс будет считаться актуальным или живым, после чего он может быть автоматически удален или инвалидирован системой. Время жизни задается в днях.

 Синтаксис:
`--ttl=TTL`

где `TTL` — это время жизни ресурса в днях.

 Значения:
\- **Положительное число:** указывает точное количество дней, в течение которых ресурс будет считаться живым. По истечении этого срока система может автоматически удалить или инвалидировать ресурс. Например, `--ttl=30` означает, что ресурс будет храниться или считаться действительным в течение 30 дней.

\- **`inf`:** специальное значение, обозначающее, что ресурс не должен быть удален или инвалидирован автоматически вообще. Это считается бесконечным временем жизни ресурса. Используется в ситуациях, когда необходимо, чтобы данные или ресурс оставались доступными на неопределенный срок. Пример использования — `--ttl=inf`.

 По умолчанию:
Если опция `--ttl` не указана при создании или настройке ресурса, используется значение по умолчанию, которое обычно равно **14** дней. Это означает, что в отсутствие явного указания TTL, ресурс будет автоматически удален или инвалидирован системой по истечении 14 дней с момента его создания или последнего обновления.

Примеры:
1\. **Создание временного ресурса на 7 дней:**
\- Команда: `ya make --ttl=7`
\- Значение: Ресурс будет автоматически удален по истечении 7 дней.

2\. **Создание постоянного ресурса:**
\- Команда: `ya make --ttl=inf`
\- Значение: Ресурс не будет удален и останется доступным на неопределенный срок.

Использование `--ttl` позволяет  эффективно управлять ресурсами, оптимизировать их хранение и исключить забытые или ненужные данные, что особенно критично для систем с ограниченным пространством для хранения. 

НЕ ОПИСЫВАЕМ

Загрузка в песочницу
Расширенные опции
\--owner=RESOURCE_OWNER
Имя пользователя, которому будут принадлежать данные, сохраненные в песочнице. Требуется в случае if ttl ресурсов в mds.
\--sandbox-url=SANDBOX_URL
URL песочницы для использования при сохранении канонического файла (по умолчанию:)
\--task-kill-timeout=TASK_KILL_TIMEOUT
Тайм-аут в секундах для задачи загрузки в песочницу
\--sandbox Загрузить в Sandbox

НЕ ОПИСЫВАЕМ

Загрузка в mds
Расширенные опции
\--mds Загрузить в MDS
\--mds-host=MDS_HOST Хост MDS (по умолчанию: [storage.yandex-team.ru](http://storage.yandex-team.ru/))
\--mds-port=MDS_PORT Порт MDS (по умолчанию: 80)
\--mds-namespace=MDS_NAMESPACE
Пространство имен MDS (по умолчанию: devtools)
\--mds-token=MDS_TOKEN
Токен Basic Auth для MDS


## Авторизация


**Вопросы**

Два параметра в справке. Уточнить есть ли отличия
--key=SSH_KEYS Путь к приватному SSH ключу для обмена на OAuth токен
--ssh-key=SSH_KEYS Путь к приватному SSH ключу для обмена на OAuth токен

Для себя

OAuth является открытым стандартом для делегирования доступа, позволяя приложениям безопасно делегировать пользовательскую аутентификацию во внешнюю службу, такую как GitHub, GitLab или любое другое API, которое поддерживает OAuth.

OAuth (Open Authorization) — это открытый стандарт для делегирования доступа, который используется в интернете для предоставления приложениям или веб-сайтам возможности запроса доступа к информации на других веб-сайтах, но без необходимости передавать логин и пароль пользователя. Это позволяет пользователям безопасно авторизовать сторонние приложения для доступа к их информации без раскрытия своих учетных данных. OAuth чаще всего используется для входа на сайты через социальные сети, такие как Facebook, Google, Twitter и др.

Основные концепции OAuth:

1. **Ресурсный Владелец (Resource Owner)**: обычно подразумевается пользователь, который может предоставлять доступ к своим защищённым ресурсам.

2. **Клиент (Client)**: приложение или веб-сайт, желающий получить доступ к ресурсам пользователя. Для этого клиент должен быть сначала зарегистрирован у провайдера этих ресурсов.

3. **Сервер Авторизации (Authorization Server)**: сервер, который выдаёт токены клиенту после успешной авторизации ресурсного владельца.

4. **Сервер Ресурсов (Resource Server)**: сервер, на котором хранятся защищённые ресурсы пользователя. Доступ к этим ресурсам осуществляется посредством токена доступа.

Процесс работы OAuth обычно следующий:

1. **Запрос Авторизации**: Когда пользователь хочет войти на сайт или в приложение (клиент) с помощью своего профиля в социальной сети, клиент запрашивает разрешение у пользователя.

2. **Пользовательское Разрешение**: Если пользователь дает своё согласие, сервер авторизации выдаёт клиенту уникальный код авторизации.

3. **Обмен Кода на Токен**: Клиент обменивает полученный код на токен доступа у сервера авторизации.

4. **Доступ к Ресурсам**: Используя токен доступа, клиент может запросить доступ к защищенным ресурсам пользователя на сервере ресурсов.

Благодаря OAuth, пользователи могут контролировать, какие именно данные они делятся с приложениями или сайтами, а также имеют возможность отзывать предоставленный доступ в любой момент. Этот стандарт предоставляет высокую степень безопасности для аутентификации и авторизации, ограничивая риски, связанные с хранением пользовательских паролей третьими сторонами.

Опция `--key=SSH_KEYS` является частью механизма аутентификации и авторизации пользователя при доступе к определенным ресурсам, требующих проверки прав. Данная опция позволяет указать путь к приватному SSH ключу пользователя, который будет использоваться для обмена на OAuth токен. Этот токен, в свою очередь, предоставляет доступ к нужным ресурсам во время сборки.

 Как работает опция --key=SSH_KEYS

1\. **Указание пути к приватному ключу:** Пользователь в командной строке явно указывает системе сборки `ya make` путь к своему приватному SSH ключу при помощи опции `--key=ПУТЬ_К_КЛЮЧУ`. Этот ключ должен быть без парольной фразы или с парольной фразой, если сеанс ssh-agent уже запущен и ключ добавлен в него.

2\. **Обмен на OAuth токен:** Система сборки использует предоставленный приватный ключ для аутентификации пользователя в сервисе, поддерживающем такой механизм обмена (например, внутренние корпоративные сервисы). В результате успешной аутентификации система получает OAuth токен, который далее используется для авторизации доступа к защищенным ресурсам во время сборки.

3\. **Использование OAuth токена:** Полученный OAuth токен далее используется системой сборки для получения доступа к ресурсам, необходимым для сборки проекта. Это могут быть зависимости, хранящиеся в приватных репозиториях, доступ к API, требующим аутентификации и т.д.

Пример использования

`ya make --key=/home/user/.ssh/id_rsa`

Где `/home/user/.ssh/id_rsa` - путь к приватному ключу пользователя на его машине.

 **Ключ без парольной фразы:** Если ключ защищен парольной фразой, убедитесь, что перед использованием опции `--key=SSH_KEYS` ключ добавлен в `ssh-agent` или используйте ключ без парольной фразы.

Использование опции `--key=SSH_KEYS` является удобным способом автоматизации процессов аутентификации и авторизации в системе сборки без необходимости явного указания учетных данных или токенов доступа.

Опция `--token=OAUTH_TOKEN` в контексте системы сборки `ya make` используется для аутентификации и авторизации пользователя через механизм OAuth. Это позволяет системе сборки получать доступ к ресурсам, которые требуют проверки прав доступа пользователя, например, к приватным репозиториям с исходным кодом или зависимостями проекта, доступ к API, требующим аутентификации, и другим защищенным ресурсам.

Как работает опция --token=OAUTH_TOKEN

1\. **Получение OAuth токена:** Пользователю необходимо заранее получить OAuth токен у провайдера аутентификации, который поддерживается сервисами или ресурсами, к которым требуется доступ в процессе сборки.

2\. **Использование токена при сборке:** При запуске сборки через `ya make`, пользователь указывает полученный OAuth токен в качестве аргумента командной строки, используя опцию `--token=ВАШ_ТОКЕН`. Система сборки использует этот токен для выполнения аутентификации при обращениях к внешним ресурсам.

3\. **Применение токена для доступа к ресурсам:** Во время сборки, на этапах, когда требуется доступ к защищенным ресурсам (например, клонирование приватного репозитория из git), система сборки предоставляет OAuth токен, который используется для аутентификации и авторизации запросов, тем самым предоставляя доступ к необходимым данным.

 Пример использования
 ya make --token=abc123

Где `abc123` — это ваш актуальный OAuth токен.

 Зачем нужен OAuth токен в процессе сборки

\- **Доступ к приватным репозиториям:** Некоторые зависимости или модули проекта могут быть размещены в приватных репозиториях, доступ к которым осуществляется через аутентификацию.
\- **Использование внешних API:** Процесс сборки может включать в себя запросы к внешним API, которые требуют подтверждения прав доступа через OAuth токен.
\- **Настройка окружения:** Некоторые проекты могут требовать загрузку настроек или конфигураций из защищенных источников перед началом сборки.

Использование опции `--token=OAUTH_TOKEN` обеспечивает гибкий и безопасный подход к аутентификации и авторизации в процессе сборки, позволяя системе сборки `ya make` доступ к защищенным ресурсам без необходимости жестко кодировать учетные данные или ключи доступа в скриптах сборки или конфигурационных файлах.

Опция `--user=USERNAME` предназначена для указания имени пользователя, под которым будет осуществляться авторизация при доступе к ресурсам, требующим аутентификации. Это может быть необходимо, например, при доступе к приватным репозиториям, защищенным API, или другим ресурсам, доступ к которым регулируется на основе учетных данных пользователя.

Как работает опция --user=USERNAME

В процессе сборки проекта система `ya make` может столкнуться с необходимостью выполнения действий, для которых требуется аутентификация. Примерами таких действий могут быть: загрузка зависимостей из приватных репозиториев, обращение к внешним сервисам или API, которые используют механизмы аутентификации для подтверждения прав доступа.

Использование `--user=USERNAME` позволяет явно задать системе сборки имя пользователя для таких случаев. Это имя пользователя будет использоваться при аутентификации на соответствующих сервисах вместе с другими переданными учетными данными (например, паролем или токеном).

Пример использования

Предположим, вы осуществляете сборку проекта, который включает в себя зависимость из приватного репозитория. Для доступа к этому репозиторию требуется аутентификация:

ya make --user=YourUsername

где `YourUsername` это ваше имя пользователя на GitHub.

Аутентификация и дополнительные параметры

Чтобы процесс аутентификации был полным, кроме указания пользователя, может потребоваться передать дополнительные параметры, такие как пароль или токен. Для этого могут использоваться ключи `--password=PASSWORD` или `--token=OAUTH_TOKEN`. Вместе эти параметры образуют полный набор учетных данных для доступа к требуемым ресурсам.

Различия между SSH vs OAuth Token

### SSH-ключи {#ssh-ключи}

1. **Цель использования**: SSH-ключи преимущественно используются для установления безопасного канала между двумя устройствами, обеспечивая возможность удаленного управления системами и безопасной передачи данных. Например, разработчики используют SSH-ключи для безопасного подключения к серверам, на которых развернуто их приложение.

2. **Процесс создания**: Для работы с SSH-ключами нужно сгенерировать пару ключей — публичный и приватный. Публичный ключ устанавливается на целевой сервер или в систему управления версиями (например, GitHub), а приватный ключ остается на локальном устройстве пользователя. Приватный ключ зачастую защищен паролем для дополнительной безопасности.

3. **Механизм работы**: При установлении соединения система использует публичный и приватный ключи для аутентификации пользователя, что позволяет ему получить доступ без необходимости вводить пароль. Этот процесс включает в себя шифрование и расшифровку данных с использованием этих ключей.

4. **Использование**: SSH-ключи чаще всего используются системными администраторами, разработчиками и IT-профессионалами для администрирования серверов, работы с гит-репозиториями и безопасного доступа к различным системам.

### OAuth токены {#oauth-токены}

### 1. Цель использования {#1-цель-использования}

OAuth токены служат для безопасной делегации доступа к ресурсам пользователя без необходимости раскрывать его личные учетные данные (логин и пароль). Токены позволяют приложениям запрашивать и получать ограниченный доступ к учетной записи пользователя на другом сервисе.

### 2. Процесс создания {#2-процесс-создания}

Основные шаги в процессе создания OAuth токена:

* **Аутентификация пользователя**: Процесс начинается с того, что пользователь логинится в свой аккаунт сервиса, который будет выдавать токен.

* **Авторизация доступа**: Пользователь дает согласие на доступ приложения к определенным данным в его аккаунте.

* **Выдача токена**: После согласия пользователя, авторизационный сервер выдает токен, который приложение может использовать для доступа к данным пользователя.

### 3. Механизм работы {#3-механизм-работы}

Механизм работы OAuth токена включает следующие этапы:

* **Запрос доступа**: Приложение запрашивает у пользователя разрешение на доступ к его данным на ресурсе.

* **Выдача авторизационного кода**: После получения согласия сервис выдает авторизационный код.

* **Обмен кода на токен**: Приложение обменивает полученный код на токен у авторизационного сервера.

* **Использование токена**: Приложение использует полученный токен при запросах к API ресурса, предоставляющего данные.

### 4. Использование {#4-использование}

Применения OAuth токенов:

* **Интеграция со сторонними сервисами**: Позволяет приложениям получать доступ к функциям или данным других сервисов, таких как Google, Facebook или Twitter.

* **Создание приложений, требующих доступ к ресурсам**: Упрощает процесс создания приложений, которые работают с информацией из других приложений или платформ, делегируя им ограниченный доступ.

* **Обеспечение безопасности**: Уменьшает риски, связанные с распространением учетных данных, ограничивая доступ приложениями только той информацией, которая необходима для работы.

В сущности, OAuth — это стандартизированный протокол, который позволяет пользователям легко и безопасно предоставлять приложениям доступ к их данным на других сервисах, не открывая свои основные учетные данные и обеспечивая контролируемый доступ к своей личной информации и функциям.


 Обмен SSH ключа на OAuth токен

В контексте систем сборки и работы с кодовыми базами и репозиториями обмен приватного SSH ключа на OAuth-токен может потребоваться для доступа к репозиториям или сервисам, где требуется аутентификация и авторизация для выполнения операций, например, клонирование приватного репозитория.

 Процесс обмена:
1\. **Использование приватного ключа:** Пользователь указывает системе/скрипту/утилите путь к своему приватному SSH ключу посредством опции вроде `--ssh-key=/path/to/private/key`. Этот ключ используется для идентификации пользователя перед сервисом, поддерживающим SSH аутентификацию.

2\. **Аутентификация и получение токена:** Сервис, при поддержке такого механизма, проводит аутентификацию пользователя, используя предоставленный приватный ключ, и в случае успешной аутентификации выдает OAuth-токен, который затем используется для авторизации в API данного сервиса или доступа к ресурсам.

3\. **Использование OAuth-токена:** После получения токена он может быть использован в дальнейших запросах к сервису для аутентификации и выполнения необходимых операций в рамках сборки (например, доступ к приватным зависимостям).
