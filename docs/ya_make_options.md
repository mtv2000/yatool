## Основные опции `ya make`

### Основные опции

**Основные:**

* `--rebuild`  - Указывает команде `ya make` игнорировать результаты предыдущих сборок и начать процесс сборки с нуля.
  Это может быть полезно в случаях, когда кэшированные результаты повреждены или когда требуется полная пересборка проекта для устранения несоответствий.
* `-C=BUILD_TARGETS`, `--target=BUILD_TARGETS` - Используется для указания конкретных целей сборки, которые должны быть построены или обработаны. В этом контексте “цель сборки” (BUILD_TARGET) относится к конкретному продукту сборки, например, исполняемому файлу, статической либо динамической библиотеке, которые генерируются в результате процесса компиляции и связывания исходного кода.
  Опция полезна в случаях, когда вам необходимо собрать не весь проект целиком, а только определенные его части. Это может быть необходимо, например, для экономии времени при разработке, когда изменения вносятся лишь в один модуль, или когда нужно собрать только определенные библиотеки или исполняемые файлы для дистрибутива.
  Это особенно актуально в больших проектах с множеством компонентов и сложной структурой зависимостей.
* `-k`, `--keep-going` - Инструктирует инструмент продолжать процесс сборки даже после возникновения ошибок в одной из целей сборки. По умолчанию, когда процесс сборки сталкивается с ошибкой, он немедленно прекращается, чтобы пользователь мог исправить обнаруженные проблемы. Опция --keep-going изменяет это поведение, позволяя сборке продолжиться и пытаться построить как можно больше целей, несмотря на ошибки в других частях проекта.\
  Использование `-k` или `--keep-going` может быть полезно в нескольких случаях:
  1. Определение всех ошибок: В больших проектах может быть удобно увидеть все ошибки компиляции за один проход сборки, чтобы исправить их одновременно, вместо того чтобы делать это по одной ошибке за раз.
  2. Сборка независимых компонентов: При работе над большим проектом, разбитым на модули или подсистемы, которые могут собираться независимо, опция `--keep-going` позволяет завершить сборку тех частей проекта, которые не затрагиваются текущими ошибками.
  3. Автоматизация: В сценариях автоматической сборки и тестирования может быть полезно собрать как можно больше компонентов, даже если некоторые из них не могут быть собраны из-за ошибок, чтобы затем автоматически запустить тесты на успешно собранных целях.
     При использовании `-k` или `--keep-going`, сборка всё равно завершится с ошибкой, если были обнаружены проблемы. Однако, в процессе будут сделаны все возможные попытки построить другие цели сборки, которые не зависят от возникших ошибок.
* `-j=BUILD_THREADS`, `--threads=BUILD_THREADS` Опция используется для указания количества потоков сборки, которые должны быть задействованы в процессе компиляции и сборки проекта. По умолчанию используется значение 2, т.е. процесс сборки должен использовать 2 параллельных потока или “ядра”. Это означает, что до 2 задач сборки (например, компиляции различных частей проекта) могут выполняться одновременно, что может значительно ускорить общее время сборки, особенно на многоядерных процессорах.
  Параллелизм сборки позволяет более эффективно использовать ресурсы современных многоядерных процессоров, уменьшая время, необходимое для компиляции больших или сложных проектов.
  В идеале, количество потоков сборки должно соответствовать количеству ядер процессора, на котором выполняется сборка, хотя в некоторых случаях может быть полезно задать значение больше или меньше, в зависимости от характеристик проекта и доступной оперативной памяти.
  Необходимо помнить, что некоторые задачи, такие как линковка (связывание), могут быть ограничены одним потоком и не получат преимущества от запуска в параллельном режиме.
* `--clear` Очистить временные данные. Опция используется для указания на необходимость удаления временных данных, созданных в процессе работы. Такие временные данные могут включать объектные файлы, промежуточные результаты компиляции, кэшированные данные и любые другие файлы или директории, которые генерируются инструментом в процессе его выполнения, но не требуются после завершения работы или в начале новой сборки. Использование опции --clear может быть полезно в нескольких случаях:
  1. Освобождение места на диске: Временные файлы, особенно в больших проектах, могут занимать значительный объем дискового пространства. Их удаление помогает управлять доступным пространством на диске.
  2. Предотвращение конфликтов: В некоторых ситуациях оставшиеся от предыдущих сборок временные файлы могут вызвать проблемы или конфликты при последующих сборках. Очистка гарантирует, что каждая сборка начинается в “чистом” окружении.
  3. Убедительность результата: Пользователи могут использовать --clear для того, чтобы убедиться, что все результаты сборки актуальны и были получены из текущего состояния исходного кода, без остаточных данных предыдущих процессов сборки.

**Расширенные опции:**

* --sandboxing Выполнить команду в изолированном корне исходного кода

* `--link-threads=LINK_THREADS` Количество потоков для линковки (по умолчанию: 0)
  Линковка — это процесс, при котором различные модули и библиотеки, сгенерированные в ходе компиляции, объединяются в один исполняемый файл или библиотеку
  Опция  используется для указания количества потоков (или параллельных задач), которые должны быть задействованы в процессе линковки (связывания) исполняемых файлов и/или библиотек.
  При локальной сборке линковки запускают в параллель не больше 2х в обычном режиме и не больше одной в режимах `--lto/--thinlto` (Link-time optimization — режим, в котором вся компиляция происходит во время линковки для более глубокой оптимизации кода).

* `--no-clonefile` Отключить опцию clonefile
  Клонирование файлов — это процесс, при котором создаётся новый файл, который на уровне файловой системы использует те же блоки данных на диске, что и исходный файл (hardlink). Этот процесс позволяет избежать дублирования данных при копировании, экономя место на диске и время на операцию копирования. Фактические данные копируются только тогда, когда в одном из клонированных файлов происходят изменения.
  Отключение `clonefile` необходимо в ситуациях, когда требуется гарантировать физическое разделение копий файлов на уровне блоков диска для обеспечения полной изоляции копий файлов друг от друга.

* `--nice=SET_NICE_VALUE` Установить значение nice для процессов сборки (по умолчанию: 10)
  Опция  предназначена для управления приоритетом процессов сборки в операционной системе. Данная опция позволяет настроить, с каким приоритетом будут работать процессы сборки, тем самым влияя на распределение ресурсов процессора между процессами сборки и другими задачами, выполняющимися на машине.
  В Linux и других UNIX-подобных операционных системах значение “nice” определяет приоритетность процесса: чем выше значение, тем ниже приоритет выполнения. Это означает, что процессы с более высоким значением nice будут уступать ресурсы процессора другим процессам с более низким значением.
  Опция особенно полезна в средах, где необходимо одновременно выполнять компиляцию больших проектов и важные задачи, требующие высокой отзывчивости системы. Например, на серверах сборки, обслуживающих множество проектов, или на рабочих станциях разработчиков, которые продолжают работать над кодом, в то время как идет процесс сборки.

* `--warning-mode=WARN_MODE` Режим предупреждений
  Опция позволяет настраивать, как система сборки должна реагировать на различные предупреждения, возникающие в процессе сборки.
  Общие значения для WARN_MODE могут включать:

* `all` - Выводить все предупреждения. Этот режим полезен для максимального контроля качества кода, обеспечивая, что каждое предупреждение будет рассмотрено и обработано разработчиком.

**Опции для экспертов**

* --fetcher-params=FETCHER_PARAMS_STR Приоритеты и параметры загрузчиков
  Опция служит для указания дополнительных параметров  отвечающих за загрузку (фетчинг) данных, зависимостей, кода и других ресурсов из внешних источников.
  Строка `FETCHER_PARAMS_STR`  представляет собой список ключ=значение параметров, разделенных символами, удобными для разбора (как запятые, пробелы или другие).
  Например: `--fetcher-params="mirror=http://example.com,mirror.priority=100,use_proxy=true".`
* `-B=CUSTOM_BUILD_DIRECTORY`, `--build-dir=CUSTOM_BUILD_DIRECTORY` Пользовательская директория сборки (определяется автоматически по умолчанию)
  Опции для указания пользовательской директории сборки, вместо использования стандартной или автоматически определяемой директории. Каждая сборочная команда исполняется в собственной директории, поэтому задаётся корень для всех таких директорий. По умолчанию эти директории размещаются внутри `~/.ya/build/`
  В некоторых случаях разработчикам может потребоваться изменить стандартное местоположение по разным причинам, например:
  * Для разделения исходного кода и артефактов сборки на разные дисковые разделы или устройства для улучшения производительности.
  * Для удобства управления артефактами сборки, особенно когда требуется легко очищать сборку, не затрагивая исходный код.
  * Для создания нескольких конфигураций сборки в рамках одного проекта (например, отладочной и релизной), каждая из которых будет храниться в своей собственной директории
* `--force-use-copy-instead-hardlink-macos-arm64` Использовать копирование вместо хардлинка, когда clonefile недоступен.
  Опция представляет собой специфический параметр, который может быть использован при сборке, работающей на архитектуре macOS с процессорами ARM64.
  Этот параметр указывает использовать операцию копирования файлов вместо создания жёстких ссылок (hard links), в ситуациях, когда невозможно использовать clonefile.
  Опция является очень специфической и её применение должно быть оправдано конкретными требованиями процесса сборки или развертывания в среде macOS на ARM64.
* `--no-content-uids` Отключить дополнительный кэш на основе UIDов, основанных только на содержимом.
  Опция предназначена для отключения использования специфического кэша, который строится на  уникальных идентификаторах (UID), генерируемых на основе графа команд.
  UIDы используются для эффективного управления кэшом и определения необходимости пересборки конкретных частей проекта. Основываясь на содержимом, такой кэш позволяет оптимизировать процесс сборки, выполняя пересборку только тех частей проекта, которые действительно изменились, исходя из изменений в их UID, связанных с содержимым.
  Отключение кэша на основе UIDов может быть целесообразным в определенных сценариях, таких как:
  * Тестирование и отладка: Когда разработчику необходимо убедиться, что все компоненты проекта собираются с нуля, чтобы исключить влияние кэширования на процесс сборки.
  * Инициализация чистой среды: В новых или временных средах сборки, где не требуется экономия времени сборки за счет кэширования.
  * Решение конфликтов: Когда в проекте возникли проблемы, связанные с кэшем, и нужно временно обойтись без него для их диагностики и устранения.
    Иногда, в случае проблем может потребоваться полная пересборка с удалением кэша или --rebuild.
    Ознакомится с информацией как строится и исполняется сборочный граф
* `--keep-temps` Не удалять временные корни сборки. Выводить рабочий каталог теста в stderr (используйте --test-stderr, чтобы убедиться, что он выводится в начале теста)
  Опция указывает на необходимость сохранения временных файлов и директорий, создаваемых в процессе сборки или выполнения тестов. Эти временные файлы могут включать промежуточные артефакты, логи компиляции, выходные данные тестов и другие файлы, которые обычно удаляются после успешного завершения сборки или тестирования для освобождения дискового пространства. Позволяет разработчикам и тестировщикам (инженерам по качеству) детально проанализировать эти файлы для диагностики ошибок, оптимизации процесса сборки и улучшения качества кода.
  Использование опции `--test-stderr` в сочетании с `--keep-temps` подчеркивает важность анализа вывода процессов. `--test-stderr` гарантирует, что `stderr` теста будет выведен в начале его выполнения, что может быть полезно для быстрого обнаружения и устранения ошибок, особенно в сочетании с сохранением временных файлов.
