## Основные опции `ya make`

### Основные опции

**Основные:**

* `--rebuild`  - Указывает команде `ya make` игнорировать результаты предыдущих сборок и начать процесс сборки с нуля.

Это может быть полезно в случаях, когда кэшированные результаты повреждены или когда требуется полная пересборка проекта для устранения несоответствий.
* `-C=BUILD_TARGETS`, `--target=BUILD_TARGETS` - Используется для указания конкретных целей сборки, которые должны быть построены или обработаны. В этом контексте “цель сборки” (BUILD_TARGET) относится к конкретному продукту сборки, например, исполняемому файлу, статической либо динамической библиотеке, которые генерируются в результате процесса компиляции и связывания исходного кода.

Опция полезна в случаях, когда вам необходимо собрать не весь проект целиком, а только определенные его части. Это может быть необходимо, например, для экономии времени при разработке, когда изменения вносятся лишь в один модуль, или когда нужно собрать только определенные библиотеки или исполняемые файлы для дистрибутива.
  Это особенно актуально в больших проектах с множеством компонентов и сложной структурой зависимостей.
* `-k`, `--keep-going` - Инструктирует инструмент продолжать процесс сборки даже после возникновения ошибок в одной из целей сборки. По умолчанию, когда процесс сборки сталкивается с ошибкой, он немедленно прекращается, чтобы пользователь мог исправить обнаруженные проблемы. Опция --keep-going изменяет это поведение, позволяя сборке продолжиться и пытаться построить как можно больше целей, несмотря на ошибки в других частях проекта.\
  Использование `-k` или `--keep-going` может быть полезно в нескольких случаях:
  1. Определение всех ошибок: В больших проектах может быть удобно увидеть все ошибки компиляции за один проход сборки, чтобы исправить их одновременно, вместо того чтобы делать это по одной ошибке за раз.
  2. Сборка независимых компонентов: При работе над большим проектом, разбитым на модули или подсистемы, которые могут собираться независимо, опция `--keep-going` позволяет завершить сборку тех частей проекта, которые не затрагиваются текущими ошибками.
  3. Автоматизация: В сценариях автоматической сборки и тестирования может быть полезно собрать как можно больше компонентов, даже если некоторые из них не могут быть собраны из-за ошибок, чтобы затем автоматически запустить тесты на успешно собранных целях.
     При использовании `-k` или `--keep-going`, сборка всё равно завершится с ошибкой, если были обнаружены проблемы. Однако, в процессе будут сделаны все возможные попытки построить другие цели сборки, которые не зависят от возникших ошибок.
* `-j=BUILD_THREADS`, `--threads=BUILD_THREADS` Опция используется для указания количества потоков сборки, которые должны быть задействованы в процессе компиляции и сборки проекта. По умолчанию используется значение 2, т.е. процесс сборки должен использовать 2 параллельных потока или “ядра”. Это означает, что до 2 задач сборки (например, компиляции различных частей проекта) могут выполняться одновременно, что может значительно ускорить общее время сборки, особенно на многоядерных процессорах.
  Параллелизм сборки позволяет более эффективно использовать ресурсы современных многоядерных процессоров, уменьшая время, необходимое для компиляции больших или сложных проектов.
  В идеале, количество потоков сборки должно соответствовать количеству ядер процессора, на котором выполняется сборка, хотя в некоторых случаях может быть полезно задать значение больше или меньше, в зависимости от характеристик проекта и доступной оперативной памяти.
  Необходимо помнить, что некоторые задачи, такие как линковка (связывание), могут быть ограничены одним потоком и не получат преимущества от запуска в параллельном режиме.
* `--clear` Очистить временные данные. Опция используется для указания на необходимость удаления временных данных, созданных в процессе работы. Такие временные данные могут включать объектные файлы, промежуточные результаты компиляции, кэшированные данные и любые другие файлы или директории, которые генерируются инструментом в процессе его выполнения, но не требуются после завершения работы или в начале новой сборки. Использование опции --clear может быть полезно в нескольких случаях:
  1. Освобождение места на диске: Временные файлы, особенно в больших проектах, могут занимать значительный объем дискового пространства. Их удаление помогает управлять доступным пространством на диске.
  2. Предотвращение конфликтов: В некоторых ситуациях оставшиеся от предыдущих сборок временные файлы могут вызвать проблемы или конфликты при последующих сборках. Очистка гарантирует, что каждая сборка начинается в “чистом” окружении.
  3. Убедительность результата: Пользователи могут использовать --clear для того, чтобы убедиться, что все результаты сборки актуальны и были получены из текущего состояния исходного кода, без остаточных данных предыдущих процессов сборки.

**Расширенные опции:**

* --sandboxing Выполнить команду в изолированном корне исходного кода

* `--link-threads=LINK_THREADS` Количество потоков для линковки (по умолчанию: 0)
  Линковка — это процесс, при котором различные модули и библиотеки, сгенерированные в ходе компиляции, объединяются в один исполняемый файл или библиотеку
  Опция  используется для указания количества потоков (или параллельных задач), которые должны быть задействованы в процессе линковки (связывания) исполняемых файлов и/или библиотек.
  При локальной сборке линковки запускают в параллель не больше 2х в обычном режиме и не больше одной в режимах `--lto/--thinlto` (Link-time optimization — режим, в котором вся компиляция происходит во время линковки для более глубокой оптимизации кода).

* `--no-clonefile` Отключить опцию clonefile
  Клонирование файлов — это процесс, при котором создаётся новый файл, который на уровне файловой системы использует те же блоки данных на диске, что и исходный файл (hardlink). Этот процесс позволяет избежать дублирования данных при копировании, экономя место на диске и время на операцию копирования. Фактические данные копируются только тогда, когда в одном из клонированных файлов происходят изменения.
  Отключение `clonefile` необходимо в ситуациях, когда требуется гарантировать физическое разделение копий файлов на уровне блоков диска для обеспечения полной изоляции копий файлов друг от друга.

* `--nice=SET_NICE_VALUE` Установить значение nice для процессов сборки (по умолчанию: 10)
  Опция  предназначена для управления приоритетом процессов сборки в операционной системе. Данная опция позволяет настроить, с каким приоритетом будут работать процессы сборки, тем самым влияя на распределение ресурсов процессора между процессами сборки и другими задачами, выполняющимися на машине.
  В Linux и других UNIX-подобных операционных системах значение “nice” определяет приоритетность процесса: чем выше значение, тем ниже приоритет выполнения. Это означает, что процессы с более высоким значением nice будут уступать ресурсы процессора другим процессам с более низким значением.
  Опция особенно полезна в средах, где необходимо одновременно выполнять компиляцию больших проектов и важные задачи, требующие высокой отзывчивости системы. Например, на серверах сборки, обслуживающих множество проектов, или на рабочих станциях разработчиков, которые продолжают работать над кодом, в то время как идет процесс сборки.

* `--warning-mode=WARN_MODE` Режим предупреждений
  Опция позволяет настраивать, как система сборки должна реагировать на различные предупреждения, возникающие в процессе сборки.
  Общие значения для WARN_MODE могут включать:

* `all` - Выводить все предупреждения. Этот режим полезен для максимального контроля качества кода, обеспечивая, что каждое предупреждение будет рассмотрено и обработано разработчиком.

**Опции для экспертов**

* --fetcher-params=FETCHER_PARAMS_STR Приоритеты и параметры загрузчиков
  Опция служит для указания дополнительных параметров  отвечающих за загрузку (фетчинг) данных, зависимостей, кода и других ресурсов из внешних источников.
  Строка `FETCHER_PARAMS_STR`  представляет собой список ключ=значение параметров, разделенных символами, удобными для разбора (как запятые, пробелы или другие).
  Например: `--fetcher-params="mirror=http://example.com,mirror.priority=100,use_proxy=true".`
* `-B=CUSTOM_BUILD_DIRECTORY`, `--build-dir=CUSTOM_BUILD_DIRECTORY` Пользовательская директория сборки (определяется автоматически по умолчанию)
  Опции для указания пользовательской директории сборки, вместо использования стандартной или автоматически определяемой директории. Каждая сборочная команда исполняется в собственной директории, поэтому задаётся корень для всех таких директорий. По умолчанию эти директории размещаются внутри `~/.ya/build/`
  В некоторых случаях разработчикам может потребоваться изменить стандартное местоположение по разным причинам, например:
  * Для разделения исходного кода и артефактов сборки на разные дисковые разделы или устройства для улучшения производительности.
  * Для удобства управления артефактами сборки, особенно когда требуется легко очищать сборку, не затрагивая исходный код.
  * Для создания нескольких конфигураций сборки в рамках одного проекта (например, отладочной и релизной), каждая из которых будет храниться в своей собственной директории
* `--force-use-copy-instead-hardlink-macos-arm64` Использовать копирование вместо хардлинка, когда clonefile недоступен.
  Опция представляет собой специфический параметр, который может быть использован при сборке, работающей на архитектуре macOS с процессорами ARM64.
  Этот параметр указывает использовать операцию копирования файлов вместо создания жёстких ссылок (hard links), в ситуациях, когда невозможно использовать clonefile.
  Опция является очень специфической и её применение должно быть оправдано конкретными требованиями процесса сборки или развертывания в среде macOS на ARM64.
* `--no-content-uids` Отключить дополнительный кэш на основе UIDов, основанных только на содержимом.
  Опция предназначена для отключения использования специфического кэша, который строится на  уникальных идентификаторах (UID), генерируемых на основе графа команд.
  UIDы используются для эффективного управления кэшом и определения необходимости пересборки конкретных частей проекта. Основываясь на содержимом, такой кэш позволяет оптимизировать процесс сборки, выполняя пересборку только тех частей проекта, которые действительно изменились, исходя из изменений в их UID, связанных с содержимым.
  Отключение кэша на основе UIDов может быть целесообразным в определенных сценариях, таких как:
  * Тестирование и отладка: Когда разработчику необходимо убедиться, что все компоненты проекта собираются с нуля, чтобы исключить влияние кэширования на процесс сборки.
  * Инициализация чистой среды: В новых или временных средах сборки, где не требуется экономия времени сборки за счет кэширования.
  * Решение конфликтов: Когда в проекте возникли проблемы, связанные с кэшем, и нужно временно обойтись без него для их диагностики и устранения.
    Иногда, в случае проблем может потребоваться полная пересборка с удалением кэша или --rebuild.
    Ознакомится с информацией как строится и исполняется сборочный граф
* `--keep-temps` Не удалять временные корни сборки. Выводить рабочий каталог теста в stderr (используйте --test-stderr, чтобы убедиться, что он выводится в начале теста)
  Опция указывает на необходимость сохранения временных файлов и директорий, создаваемых в процессе сборки или выполнения тестов. Эти временные файлы могут включать промежуточные артефакты, логи компиляции, выходные данные тестов и другие файлы, которые обычно удаляются после успешного завершения сборки или тестирования для освобождения дискового пространства. Позволяет разработчикам и тестировщикам (инженерам по качеству) детально проанализировать эти файлы для диагностики ошибок, оптимизации процесса сборки и улучшения качества кода.
  Использование опции `--test-stderr` в сочетании с `--keep-temps` подчеркивает важность анализа вывода процессов. `--test-stderr` гарантирует, что `stderr` теста будет выведен в начале его выполнения, что может быть полезно для быстрого обнаружения и устранения ошибок, особенно в сочетании с сохранением временных файлов.

  {% cut "--add-result=ADD_RESULT - Process selected build output as a result" %}

\--add-result=ADD_RESULT Обработать выбранный вывод сборки как результат

Опция --add-result=ADD_RESULT предназначена для управления результатами, выдаваемыми системой сборки. Она дает возможность точно определить, какие файлы следует включать в итоговый набор результатов.

Этот параметр оказывается особенно полезным, когда возникает потребность в просмотре или анализе кода файлов, сгенерированных в ходе сборки.

Примеры

* `ya make --add-result=".h"`  `--add-result=".cpp"` - собрать, добавив в результаты сгенерированные в процессе сборки cpp- и h-файлы.
* `ya make --add-result=".pb.h"` `--add-result=".pb.cc"` `--replace-result` - запустить только кодогенерацию протобуфов.

Чтобы посмотреть код сгенерированных файлов можно давить флаг `--add-result .pb.gw.go`

{% endcut %}

{% cut "--add-protobuf-result -  Process protobuf output as a result" %}

\--add-protobuf-result Обработать вывод protobuf как результат

Опция `--add-protobuf-result` позволяет системе сборки явно  получить сгенерированный исходный код `Protobuf` для соответствующих языков программирования.

[Protobuf](https://protobuf.dev/) предоставляют эффективный и удобный способ описания структурированных данных, который не привязан к конкретному языку программирования или платформе.

Они позволяют определить структуру данных в специальном формате `.proto`, после чего можно автоматически генерировать код для сериализации и десериализации этих данных на поддерживаемых языках программирования, таких как C\+\+, Java, Python и других.

{% endcut %}

{% cut "--add-flatbuf-result - Process flatbuf output as a result" %}

\--add-flatbuf-result Обработать вывод flatbuf как результат

Опция `--add-flatbuf-result` предназначена для того, чтобы система сборки могла  автоматически получить сгенерированный исходный код выходных файлов FlatBuffers (flatc) для соответствующих языков программирования

[FlatBuffers](https://flatbuffers.dev/) - это сериализационная система, разработанная для обеспечения высокой производительности и эффективности при работе с структурированными данными, позволяя оперировать данными прямо в бинарном формате без необходимости предварительного парсинга или десериализации. Это делает FlatBuffers особенно подходящим для приложений, где требуется минимизация задержек и перерасхода памяти, например, в встроенных системах, играх, или приложениях реального времени.

{% endcut %}

{% cut "--replace-result - Build only --add-result targets" %}

\--replace-result Собирать только цели, указанные в --add-result

Опция `--replace-result` применяется в системах сборки для чёткого ограничения процесса компиляции объектами, определёнными в параметре `--add-result`. С ее помощью система будет собирать исключительно те элементы, которые были явно указаны в `--add-result`, исключая все остальные составные части проекта, такие как библиотеки или исполняемые файлы программ.

Это полезно в случаях, когда необходимо осуществить сборку только определённых генерируемых файлов, что может значительно уменьшить общее время сборки.

{% endcut %}

{% cut "--force-build-depends - Build by DEPENDS anyway" %}

\--force-build-depends Принудительно собирать зависимости, указанные в `DEPENDS`

Опция `--force-build-depends` специально разработана для того, чтобы обеспечить комплексную подготовку к тестированию за счет принудительной сборки всех зависимостей, объявленных в `DEPENDS`.

Это означает, что даже если некоторые из этих зависимостей не требуют обновления в обычном режиме сборки, они будут собраны заново для гарантирования актуальности тестового окружения. При этом непосредственно само тестирование не проводиться .

Таким образом, перед выполнением тестов разработчик получает возможность убедиться в том, что все компоненты системы находятся в последних версиях и совместимы между собой.

{% endcut %}

{% cut "-R, --ignore-recurses - Do not build by RECURSES" %}

\-R, --ignore-recurses Не собирать рекурсивно указанные зависимости

Опции `-R` и `--ignore-recurses` применяются при запуске системы сборки для управления вложенным процессом компиляции проекта. Эти параметры предотвратят автоматическую сборку проектов, объявленных с использованием макроса `RECURSE` в файлах ya.make.

Макрос `RECURSE` обычно используется для объявления вложенных сборочных целей, которые необходимо скомпилировать одновременно. Однако это не создает жестких зависимостей между различными целями сборки. Когда требуется ограничить процесс сборки только конкретно указанными целью или модулем, без рекурсивного включения дополнительных сборочных задач, опции `-R` и `--ignore-recurses` приказывают системе сборки игнорировать макрос `RECURSE`.

Это означает, что если в проекте используются вложенные макросы `RECURSE`, которые могут повлечь за собой дополнительные неявные процессы сборки, опции `-R` и `--ignore-recurses` обеспечивают более точный контроль над процессом, позволяя собрать только те цели, которые явно заданы, минимизируя тем самым потенциальные сложности из-за неожиданных зависимостей.

{% endcut %}

{% cut "--no-src-links - Do not create any symlink in source directory" %}

\--no-src-links Не создавать символические ссылки в исходной директории

Опция `--no-src-links` отменяет создание символических ссылок для доступа к результатам сборки или тестов, которые обычно размещаются во временных хранилищах, таких как кэш результатов. Это является стандартным способом организации доступа к собранным артефактам на Unix-подобных системах, таких как Linux или MacOS, позволяя быстро ссылаться из исходной директории на данные и результаты, хранящиеся в другом месте.

При запуске сборки или тестов без `--no-src-links`, система создает символические ссылки в рабочей копии исходного репозитория, которые указывают на соответствующие файлы или директории в кэше результатов.

Использование `--no-src-links` означает, что система будет сохранять все артефакты напрямую в предназначенные для этого директории на локальной файловой системе, не создавая символических ссылок. Это может быть особенно актуально в Windows, где механизм работы с символическими ссылками отличается и может быть не таким прямым или надежным, как в Unix-подобных системах.

{% endcut %}

Разработчикам **--ignore-recurses Повторяется в справке, уже описана выше  на 2 пункта**

{% cut "-o=OUTPUT_ROOT, --output=OUTPUT_ROOT - Directory with build results" %}

\-o=OUTPUT_ROOT, --output=OUTPUT_ROOT Директория с результатами сборки

`-o=OUTPUT_ROOT`, `--output=OUTPUT_ROOT` — путь, куда будут сложены результаты сборки (на Linux и macOS будут использованы хардлинки). Результаты будут размещены по путям, соответствующим размещению описаний сборки

{% endcut %}

**Расширенные опции**

{% cut "-I=INSTALL_DIR, --install=INSTALL_DIR - Path to accumulate resulting binaries and libraries" %}

\-I=INSTALL_DIR, --install=INSTALL_DIR Путь для накопления результирующих бинарных файлов и библиотек

I=INSTALL_DIR, --install=INSTALL_DIR — не рекомендуется использовать. Путь, куда будут сложены результаты сборки. Результаты будут сложены непосредственно в указанную директорию.

{% endcut %}

**Опции для экспертов**

{% cut "--add-host-result=ADD_HOST_RESULT - Process selected host build output as a result" %}

\--add-host-result=ADD_HOST_RESULT - Обработать выбранный вывод хост-сборки как результат

Опция `--add-host-result=ADD_HOST_RESULT` конфигурирует сборочный процесс таким образом, что определенные результаты сборки на хост-машине (то есть та машина, которая используется для выполнения сборки) могут быть явно отобраны как финальные артефакты. Это обеспечивает точность и контроль за теми артефактами, которые вы считаете важными и хотите сохранить после процесса сборки.

Использование `--add-host-result=ADD_HOST_RESULT` особенно полезно, когда необходимо выделить важные результаты, такие как исполняемые файлы, библиотеки, документация или отчеты, гарантируя, что они не будут утеряны среди прочих временных файлов сборки. Этот параметр позволяет определить пути или шаблоны путей, которые должны быть включены в итоговый набор.

{% endcut %}

{% cut "--all-outputs-to-result - Process all outputs of the node along with selected build output as a result" %}

\--all-outputs-to-result - Обрабатывать все выходные данные узла вместе с выбранным результатом сборки

Опция `--all-outputs-to-result` модифицирует поведение сборочной системы так, что вместо фильтрации и извлечения лишь специфичных выходных файлов, определенных через другие параметры (как `--add-result`), она указывает сборочной системе включать все выходные файлы, связанные с заданными командами.

Классически, при использовании `--add-result`, система сборки фильтрует выходные данные, основываясь на их расширениях или других критериях, определенных пользователем. Так, если использовать `--add-result=.pb.h`, система извлечет и предоставит только файлы с расширением `.pb.h`. Однако, добавление `--all-outputs-to-result` к команде изменит эту логику и даст в результате все связанные выходные файлы, включая, например, `.pb.cc`, которые могут быть необходимы для полного функционирования сборки или при дальнейшем использовании.

{% endcut %}

{% cut "--add-modules-to-results - Process all modules as results" %}

\--add-modules-to-results - Обрабатывать все модули как результаты

Опция `--add-modules-to-results` применяется для того, чтобы указать системе сборки рассматривать каждый модуль в проекте, включая те, что указаны как зависимости через `PEERDIR`, как целевые результаты сборки.

В стандартном режиме сборки только определенные типы артефактов, такие как исполняемые файлы, библиотеки или результаты тестов, считаются конечными результатами. Однако, активация `--add-modules-to-results` меняет это поведение, делая каждый модуль, который может быть представлен индивидуальным блоком кода и компилироваться в отдельные объектные файлы или пакеты, отдельным результатом сборки.

{% endcut %}

`--strip-packages-from-results -`**НЕ НАШЕЛ В ДОКУМЕНТАЦИИ. ДЕЛАЛ ПО АНАЛОГИИ**

{% cut "--strip-packages-from-results - Strip all packages from results" %}

\--strip-packages-from-results -Удалить все пакеты из результатов

Опция `--strip-packages-from-results` применяется в процессе сборки для исключения пакетов из итоговых результатов сборки. Это означает, что при использовании данной опции, система сборки произведет удаление всех пакетов, которые  могли бы в противном случае рассматривать как конечные результаты.

Как правило, пакеты (packages) могут содержать бинарные файлы, библиотеки, скрипты конфигураций и другие компоненты, которые являются результатами сборочного процесса.

Может быть полезно, например,  для выполнения тестов и проверок, где наличие пакетов не требуется.

{% endcut %}

{% cut "--no-output-for=SUPPRESS_OUTPUTS - Do not symlink/copy output for files with given suffix, they may still be save in cache as result" %}

Опция `--no-output-for=SUPPRESS_OUTPUTS` обеспечивает управление отображением и доступностью результатов сборки, позволяя исключить создание символических ссылок или физическое копирование файлов с определенным суффиксом в выходную директорию, сохраняя их в кеше системы сборки.

При вызове `ya make`, добавление параметра `--no-output-for=<.suffix>`, где `<.suffix>` представляет суффиксы файлов, для которых не следует создавать выходные ссылки или копии, позволяет точно управлять содержимым выходных директорий.

Ключевые моменты использования `--no-output-for=SUPPRESS_OUTPUTS`:

* Файлы с указанным суффиксом не отображаются после сборки, но остаются в кэше.
* Опция не влияет на `--replace-result`, поэтому исключение файлов из выходных результатов не предотвращает их сборку, они будут скачаны и сложены в кэш, но не будут отображены как результаты сборки.

{% endcut %}

`--with-credits` - **НЕ НАШЕЛ В ДОКУМЕНТАЦИИ. ДЕЛАЛ ПО АНАЛОГИИ**

{% cut "--with-credits - Enable CREDITS file generation" %}

\--with-credits - Включить генерацию файла CREDITS

Опция `--with-credits` используется при проведении сборки с целью включить в процесс создание файла `CREDITS`. Этот файл обычно содержит информацию о вкладчиках, авторах, лицензиях и другие подобные сведения, которые касаются используемых зависимостей и компонентов в проекте.

Включение этой опции заставит систему сборки автоматически генерировать файл `CREDITS`, который будет собирать такие данные из различных источников в процессе сборки. Это может быть необходимо для соответствия лицензионным требованиям открытого программного обеспечения, для обеспечения прозрачности использования сторонних библиотек или просто в целях предоставления информации о вкладе разработчиков.

{% endcut %}
