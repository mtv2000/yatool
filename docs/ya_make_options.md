## Основные опции `ya make`

### Основные опции

**Основные:**

* Опция `--rebuild` применяется командой `ya make` для выполнения полной пересборки проекта, игнорируя все ранее сгенерированные результаты. 
Удаляются все промежуточные и итоговые файлы, созданные во время прошлых процессов сборки, чтобы исключить влияние устаревших или некорректных данных на новую сборку.

В результате использования опции  `--rebuild` гарантируется, что все составные части проекта будут скомпилированы заново, что способствует исключению ошибок, связанных с конфликтами или несогласованностями в файлах, и обеспечивает точное соответствие текущего состояния исходного кода скомпилированным компонентам. Служит инструментом качества и поддержания валидности разработки.

* Опции `-C=BUILD_TARGETS`, `--target=BUILD_TARGETS`  применяются, для установки конкретных целей сборки, указанных в файле ya.make и задаваемых значением `BUILD_TARGETS`.

Актуально в больших проектах с множеством компонентов и сложной структурой зависимостей, как один из спобов описать цель для сборки.

* Опции `-k`, `--keep-going` - служат для поддержания процесса сборки активным, даже если некоторые цели сборки не удается выполнить из-за ошибок. По умолчанию, когда процесс сборки сталкивается с ошибкой, он немедленно прекращается, чтобы пользователь мог исправить обнаруженные проблемы. Опции `-k` или `--keep-going` изменяют это поведение, позволяя сборке продолжиться и пытаться построить как можно больше целей, несмотря на ошибки в других частях проекта.

При использовании `-k` или `--keep-going`, сборка всё равно завершится с ошибкой, если были обнаружены проблемы. Однако, в процессе будут сделаны все возможные попытки построить другие цели сборки, которые не зависят от возникших ошибок.

* Параметры `-j=BUILD_THREADS`, `--threads=BUILD_THREADS`  используются для указания число рабочих потоков сборки, которые должны быть задействованы в процессе сборки проекта, соответственно ресурсам вашего процессора. Рекомендуется устанавливать количество потоков, равное количеству ядер вашего процессора, чтобы оптимизировать процедуру сборки.

При отсутствии явных указаний используется два потока сборки по умолчанию, и один поток при включении опции --lto. Это позволяет запускать до двух сборочных операций параллельно, что может существенно сократить общее время, необходимое для сборки проекта.

* При использовании опции `--clear` будут удалены временные данные и результаты предыдущих сборок, которые находятся в директории проекта. Однако кеш компиляции, который может содержать предварительно собранные данные для ускорения последующих сборок, не будет затронут.

**Расширенные опции:**

* `--link-threads=LINK_THREADS` Количество потоков линковок (по умолчанию: 0)
  Линковка — это процесс, при котором различные модули и библиотеки, сгенерированные в ходе компиляции, объединяются в один исполняемый файл или библиотеку
  Опция  используется для указания количества линковок , которые должны быть задействованы параллельно.
  При локальной сборке линковки запускают в параллель не больше 2х в обычном режиме и не больше одной в режимах `--lto/--thinlto` (Link-time optimization — режим, в котором вся компиляция происходит во время линковки для более глубокой оптимизации кода).

* `--no-clonefile` Отключить опцию clonefile
  Клонирование файлов — это процесс, при котором создаётся новый файл, который на уровне файловой системы использует те же блоки данных на диске, что и исходный файл (hardlink). Этот процесс позволяет избежать дублирования данных при копировании, экономя место на диске и время на операцию копирования. Фактические данные копируются только тогда, когда в одном из клонированных файлов происходят изменения.
  
  Отключение `clonefile` необходимо в ситуациях, когда требуется гарантировать физическое разделение копий файлов на уровне блоков диска для обеспечения полной изоляции копий файлов друг от друга.

* `--nice=SET_NICE_VALUE` Установить значение nice для процессов сборки (по умолчанию: 10)
  Опция  предназначена для управления приоритетом процессов сборки в операционной системе. Данная опция позволяет настроить, с каким приоритетом будут работать процессы сборки, тем самым влияя на распределение ресурсов процессора между процессами сборки и другими задачами, выполняющимися на машине.
  В Linux и других UNIX-подобных операционных системах значение “nice” определяет приоритетность процесса: чем выше значение, тем ниже приоритет выполнения. Это означает, что процессы с более высоким значением nice будут уступать ресурсы процессора другим процессам с более низким значением.
  
* `--warning-mode=WARN_MODE` Режим предупреждений
  
Опция позволяет настраивать, как система сборки должна реагировать на различные предупреждения, возникающие в процессе сборки.
Работает только в режиме отладки `debug`. Если вам нужны и производительность, и эти сообщения используйте сборку в режиме `relwithdebinfo`.
Общие значения для WARN_MODE могут включать:
  * `all` - Выводить все предупреждения. Этот режим полезен для максимального контроля качества кода, обеспечивая, что каждое предупреждение будет рассмотрено и обработано разработчиком.
  * `allerr` - Выводить все виды фатальных ошибок.
  * `dbg` - Печатать все отладочные сообщения и остальные ошибки.
  * `dbgonly` - Печатать только отладочные сообщения.
  * `Details` - Выводить дополнительные сведения о предупреждениях или сообщениях об ошибке.
  * `Syntax` - Печатать найденные синтаксические ошибки в файлах ya.conf, ya.make.
  * `BadSrc` - Выводит сообщения об отсутствии правила, основанного на расширении файла.
  * `BadMacro` - Печатает сообщение при вызове неопределенного макроса.
  * `Garbage` - Печатает предупреждения о бесполезные инструкции в вашем ya.make-файле.
  * `UnkStatm` - Печатает предупреждения о неизвестных инструкциях в ya.make-файле.
  * `UnkMod` - Печатает предупреждения о неизвестных модификаторах в вашем ya.make-файле.
  * `Style` - Реагирует на неправильное описание ya.make-файла.
  * `MacroUse` - Печатает предупреждения о проблемах при использовании макросов.
  * `BadFile` - Предупреждения о невозможности прочитать файл.
  * `UndefVar` - Реагирует при использовании неопределенных переменных в макросах.
  * `BadInput` - Выводит предупреждения об отсутсвии входные файлов для целей сборки.
  * `NoOutput` - Нет выходных файлов для результатов сборки.
  * `NoCmd` - Предупреждения об отсутсвии команды сборки для целевого объекта.
  * `KnownBug` - Выводит предупреждения, если присутствуют известые ошибки в ядре системы сборки
  * `BadDir` - Пустой или несуществующий каталог в `PEERDIR` или `tool`.
  * `DupSrc` - Показывает дублированные записи в `SRCS`.
  * `BlckLst` - Сообщает об использованных файлах и каталогов запрещенных проектом.
  * `IslPrjs` - Сообщает об использованных файлах и каталогов для другого проекта.
  * `recurs` - Вывод список каталогов, активированных через `RECURSE` и `SUBDIR`.
  * `allbadrecurses` - Обнаружение всех ошибочных обращений.
  * `nomain` - Предупреждения, если ни один из входов/выходов не помечен как основной.
  * `pedantic-licenses` - Показывает дополнительную диагностику возможных некорректных аргументов макросов `LICENSE` или `RESTRICT_LICANSES`.
  * `allloops` - Выводит сообщения при обнаружение циклов в `PEERDIR`.
  * `ChkPeers` - Поиск и отображение файлов, которые, отсутствуют по ошибке в `PEERDIRS`.
  * `BadIncl` - Печатает предупреждения при отсутствувии необходимых файлов или они неразрешенны.
  * `NATR` - Трассировка `TNodeAddCtx`.
  * `V` - Подробные сообщения при отладке, аналог опции `-v`
  * `VV` - Более подробные сообщения при отладке, аналог опции `-vv`
  * `CVar` - Проверка и обработка переменных на уровне создания.
  * `ToDo` - Печатает сообщения о том, что что-то не выполнено.
  * `Incl` - Синтаксическиу ошибки в подключаемых файлах.
  * `LEX` - Диагностика парсером системы сборки.
  * `Make` - Внутренние сообщения системы сборки.
  * `Loop` - Проверка обнаружения циклов
  * `Conf` - Анализирует файлы конфигурации.
  * `FU` -  Проверка при обновлении графа, печатает новые и обновленные файлы.
  * `UIDs` - Проверка и печать измененых `UIDs`.

**Опции для экспертов**

* `--fetcher-params=FETCHER_PARAMS_STR` Приоритеты и параметры загрузчиков
  Опция служит для указания дополнительных параметров  отвечающих за загрузку (фетчинг) данных, зависимостей, кода и других ресурсов из внешних источников.
  Строка `FETCHER_PARAMS_STR`  представляет собой список ключ=значение параметров, разделенных символами, удобными для разбора (как запятые, пробелы или другие).
  Например: `--fetcher-params="custom=http://example.com,mirror.priority=100, proxy=true".`
* `-B=CUSTOM_BUILD_DIRECTORY`, `--build-dir=CUSTOM_BUILD_DIRECTORY` Пользовательская директория сборки (определяется автоматически по умолчанию)
  Опции для указания пользовательской директории сборки, вместо использования стандартной или автоматически определяемой директории. Каждая сборочная команда исполняется в собственной директории, поэтому задаётся корень для всех таких директорий. По умолчанию эти директории размещаются внутри `~/.ya/build/`
  В некоторых случаях разработчикам может потребоваться изменить стандартное местоположение по разным причинам, например:
  * Для разделения исходного кода и целей сборки на разные дисковые разделы или устройства для улучшения производительности.
  * Для удобства управления целями сборки, особенно когда требуется легко очищать сборку, не затрагивая исходный код.
  * Для создания нескольких конфигураций сборки в рамках одного проекта (например, отладочной и релизной), каждая из которых будет храниться в своей собственной директории

* Опция `--no-content-uids`  отключает работу локальной сборки в режиме контетных UIDов.

Локальная сборка работает в режиме контетных UIDов. В этом режиме она не перезапускает команды если результаты её команд-зависимостей не поменялись. Для этого используется дополнительное кэширование по контентному (динамическому) UID.
Режим отключается опцией `--no-content-uids` или настройкой `content_uids = false` в `ya.conf`.

[Ознакомится с информацией как строится и исполняется сборочный граф](https://github.com/mtv2000/yatool/blob/newstyle/docs/UIDwork.md)
    
* Опция `--keep-temps` указывает на необходимость сохранения временных файлов и директорий, создаваемых в процессе сборки или выполнения тестов.
  
Иногда разработчику нужно сохранить файлы прямо там, где исполнялась сборка (в сборочных директориях), например, чтобы воспроизвести отдельные команды сборки. 
 
### Вывод результатов системы сборки (Build output)

* `--add-result=ADD_RESULT` Обработать выбранный вывод сборки как результат

Опция `--add-result=ADD_RESULT` предназначена для управления результатами, выдаваемыми системой сборки. Она дает возможность точно определить, какие файлы следует включать в итоговый набор результатов.

Этот параметр оказывается особенно полезным, когда возникает потребность в просмотре или анализе кода файлов, сгенерированных в ходе сборки.

Примеры

* `ya make --add-result=".h"`  `--add-result=".cpp"` - собрать, добавив в результаты сгенерированные в процессе сборки cpp- и h-файлы.
* `ya make --add-result=".pb.h"` `--add-result=".pb.cc"` `--replace-result` - запустить только кодогенерацию протобуфов.

Чтобы посмотреть код сгенерированных файлов можно давить флаг `--add-result .pb.gw.go`

* `--add-protobuf-result` Обработать вывод protobuf как результат

Опция `--add-protobuf-result` позволяет системе сборки явно  получить сгенерированный исходный код `Protobuf` для соответствующих языков программирования.

[Protobuf](https://protobuf.dev/) предоставляют эффективный и удобный способ описания структурированных данных, который не привязан к конкретному языку программирования или платформе.

Они позволяют определить структуру данных в специальном формате `.proto`, после чего можно автоматически генерировать код для сериализации и десериализации этих данных на поддерживаемых языках программирования, таких как C\+\+, Java, Python и других.

* `--add-flatbuf-result` Обработать вывод flatbuf как результат

Опция `--add-flatbuf-result` предназначена для того, чтобы система сборки могла  автоматически получить сгенерированный исходный код выходных файлов FlatBuffers (flatc) для соответствующих языков программирования

[FlatBuffers](https://flatbuffers.dev/) - это сериализационная система, разработанная для обеспечения высокой производительности и эффективности при работе с структурированными данными, позволяя оперировать данными прямо в бинарном формате без необходимости предварительного парсинга или десериализации. Это делает FlatBuffers особенно подходящим для приложений, где требуется минимизация задержек и перерасхода памяти, например, в встроенных системах, играх, или приложениях реального времени.

* `--replace-result` Собирать только цели, указанные в `--add-result`

Опция `--replace-result` применяется в системах сборки для чёткого ограничения процесса компиляции объектами, определёнными в параметре `--add-result`. С ее помощью система будет собирать исключительно те элементы, которые были явно указаны в `--add-result`, исключая все остальные составные части проекта, такие как библиотеки или исполняемые файлы программ.

Это полезно в случаях, когда необходимо осуществить сборку только определённых генерируемых файлов, что может значительно уменьшить общее время сборки.

* `--force-build-depends` Принудительно собирать зависимости, указанные в `DEPENDS`

Опция `--force-build-depends` обеспечивает комплексную подготовку к тестированию за счет принудительной сборки всех зависимостей, объявленных в `DEPENDS`.

Это означает, что даже если некоторые из этих зависимостей не требуют обновления в обычном режиме сборки, они будут собраны заново для гарантирования актуальности тестового окружения. При этом непосредственно само тестирование не проводиться .

* Опции `-R` и `--ignore-recurses`  предотвратят автоматическую сборку проектов, объявленных с использованием макроса `RECURSE` в файлах ya.make.

Макрос `RECURSE` обычно используется для объявления вложенных сборочных целей, которые необходимо собрать одновременно. 
Когда требуется ограничить процесс сборки только конкретно указанными целью или модулем, без рекурсивного включения дополнительных сборочных целей, опции `-R` и `--ignore-recurses`.  Такой подход позволяет сборочной системе пропустить обработку макроса `RECURSE`, что обеспечивает сборку исключительно тех сборочных целей, которые были строго определены.

* `--no-src-links` Не создавать символические ссылки в исходной директории

Опция `--no-src-links` отменяет создание символических ссылок для доступа к результатам сборки или тестов, которые обычно размещаются во временных хранилищах, таких как кэш результатов. Это является стандартным способом организации доступа к собранным артефактам на Unix-подобных системах, таких как Linux или MacOS, позволяя быстро ссылаться из исходной директории на данные и результаты, хранящиеся в другом месте.

При запуске сборки или тестов без `--no-src-links`, система создает символические ссылки в рабочей копии исходного репозитория, которые указывают на соответствующие файлы или директории в кэше результатов.

Использование `--no-src-links` означает, что система будет сохранять все цели сборки в предназначенные для этого директории на локальной файловой системе, не создавая символических ссылок. Это может быть особенно актуально в Windows, где механизм работы с символическими ссылками отличается и может быть не таким прямым или надежным, как в Unix-подобных системах.

* `-o=OUTPUT_ROOT`, `--output=OUTPUT_ROOT` Директория с результатами сборки

`-o=OUTPUT_ROOT`, `--output=OUTPUT_ROOT` — путь, куда будут сложены результаты сборки (на Linux и macOS будут использованы хардлинки). Результаты будут размещены по путям, соответствующим размещению описаний сборки

**Расширенные опции**

* `-I=INSTALL_DIR`, `--install=INSTALL_DIR` Путь для накопления результирующих бинарных файлов и библиотек

`I=INSTALL_DIR`, `--install=INSTALL_DIR` — не рекомендуется использовать. Путь, куда будут сложены результаты сборки. Результаты будут сложены непосредственно в указанную директорию.

**Опции для экспертов**

* `--add-host-result=ADD_HOST_RESULT` - Обработать выбранный вывод хост-сборки как результат

Опция `--add-host-result=ADD_HOST_RESULT` конфигурирует сборочный процесс таким образом, что определенные результаты сборки были явно сохранены на хост-платформе после завершения сборки. 

Использование `--add-host-result=ADD_HOST_RESULT` особенно полезно, когда необходимо выделить важные результаты, гарантируя, что они не будут утеряны среди прочих временных файлов сборки. 

* Опция `--all-outputs-to-result` модифицирует поведение сборочной системы так, что вместо фильтрации и извлечения лишь специфичных выходных файлов, определенных через другие параметры (как `--add-result`), она указывает сборочной системе включать все выходные файлы, связанные с заданными командами.

При использовании `--add-result`, система сборки фильтрует выходные данные, основываясь на их расширениях или других критериях, определенных пользователем. Так, если использовать `--add-result=.pb.h`, система извлечет и предоставит только файлы с расширением `.pb.h`. Однако, добавление `--all-outputs-to-result` к команде изменит эту логику и даст в результате все связанные выходные файлы, включая, например, `.pb.cc`, которые могут быть необходимы для полного функционирования сборки или при дальнейшем использовании.

* Опция `--add-modules-to-results` применяется для того, чтобы указать системе сборки рассматривать каждый модуль в проекте, включая те, что указаны как зависимости через `PEERDIR`, как целевые результаты сборки.

В стандартном режиме сборки только определенные типы артефактов, такие как исполняемые файлы, библиотеки или результаты тестов, считаются конечными результатами. Однако, активация `--add-modules-to-results` меняет это поведение, делая каждый модуль, который может быть представлен индивидуальным блоком кода и компилироваться в отдельные объектные файлы или пакеты, отдельным результатом сборки.

* Опция `--strip-packages-from-results` применяется в процессе сборки для исключения пакетов из итоговых результатов сборки. Это означает, что при использовании данной опции, система сборки произведет удаление всех пакетов, которые  могли бы в противном случае рассматривать как конечные результаты.

Как правило, пакеты (packages) могут содержать бинарные файлы, библиотеки, скрипты конфигураций и другие компоненты, которые являются результатами сборочного процесса.

Может быть полезно, например,  для выполнения тестов и проверок, где наличие пакетов не требуется.

* Опция `--no-output-for=SUPPRESS_OUTPUTS` обеспечивает управление отображением и доступностью результатов сборки, позволяя исключить создание символических ссылок или физическое копирование файлов с определенным суффиксом в выходную директорию, сохраняя их в кеше системы сборки.

При вызове `ya make`, добавление параметра `--no-output-for=<.suffix>`, где `<.suffix>` представляет суффиксы файлов, для которых не следует создавать выходные ссылки или копии, позволяет точно управлять содержимым выходных директорий.

Ключевые моменты использования `--no-output-for=SUPPRESS_OUTPUTS`:

  * Файлы с указанным суффиксом не отображаются после сборки, но остаются в кэше.
  * Опция не влияет на `--replace-result`, поэтому исключение файлов из выходных результатов не предотвращает их сборку, они будут скачаны и сложены в кэш, но не будут отображены как результаты сборки.

* Опция `--with-credits` используется при проведении сборки с целью включить в процесс создание файла `CREDITS`. Этот файл обычно содержит информацию о вкладчиках, авторах, лицензиях и другие подобные сведения, которые касаются используемых зависимостей и компонентов в проекте.

Если включить эту опцию, то система сборки будет автоматически создавать файл CREDITS, собирая данные из разных источников во время процесса сборки. Это может быть необходимо для соответствия лицензионным требованиям открытого программного обеспечения, для обеспечения прозрачности использования сторонних библиотек или просто в целях предоставления информации о вкладе разработчиков.

## Вывод (Printing) 

* Опция `--stat` используется с командой `ya make` для отображения статистики выполнения сборки. Когда эта опция включена, пользователи могут получить сведения о процессе сборки без учета дополнительных шагов, таких как конфигурирование, пакетирование и других аналогичных процессов. Это полезно для анализа производительности и оптимизации времени сборки.

В добавок к использованию командной строки, вы можете автоматически активировать этот режим для всех сборок, выполняемых через `ya make`, `ya package` и так далее, путем установки параметра `print_statistics = true` в конфигурационном файле. Это означает, что каждый раз, когда выполняется сборка через `ya make` с любыми его опциями, статистика сборки будет автоматически выводиться в конце процесса.

* Опция `-v` или `--verbose`, применяемая с командой `ya make`, служит для активации режима подробного вывода. Когда эта опция включена, в консоль будут дополнительно выводиться тексты всех выполняемых сборочных команд, что позволяет пользователям более детально следить за процессом сборки и диагностировать возможные проблемы.

Использование режима подробного вывода особенно полезно в следующих случаях:
  * Диагностика ошибок: Позволяет увидеть точные команды, приводящие к ошибкам в процессе сборки, что упрощает отладку.
  * Оптимизация сборки: Понимание того, какие команды выполняются и сколько времени они занимают, может помочь в оптимизации скриптов сборки для ускорения процесса.
  * Обучение и документирование: Подробный вывод дает лучшее понимание того, как работает процесс сборки, что может быть полезно при написании документации или обучении новых членов команды.

Опции `-v` или `--verbose` добавляет дополнительный уровень прозрачности к процессу сборки, позволяя более глубоко понять и контролировать его этапы.

* Опция `-T`  служит для изменения способа вывода статуса процесса сборки (собрать, не перезатирая выполняемые команды в выводе)
 
Активация опции `-T` приводит к тому, что статус сборки выводится в построчном режиме, при этом каждое новое сообщение выводится на новой строке без перезаписывания предыдущего, делает вывод более подходящим для логирования и последующего анализа.

Кроме того, при перенаправлении вывода команды `ya make` в файл (например, `build.log`), позволяет сохранить весь вывод процесса сборки в удобочитаемом формате для последующего анализа или архивации.

Использование `-T` упрощает работу с логами, делая их более структурированными и информативными, особенно когда построчная запись сообщений предпочтительнее для визуализации процесса сборки в различных средах и инструментах.

* Опция `--show-command=SHOW_COMMAND` позволяет пользователям получить информацию о конкретной сборочной команде, которая была использована для создания выбранного результата сборки. Параметр  полезен при необходимости детального анализа процесса сборки и понимания того, какие именно команды и аргументы применялись для получения конечного результата сборки.

При использовании опции `--show-command`,отображается соответствующая команда сборки, извлеченная из базы данных сборки или кэша. Возможность видеть точные команды помогает разработчикам понять процесс сборки и облегчает отладку, оптимизацию сборочных скриптов, а также помогает новым членам команды лучше разбираться в сборочных процессах проекта.

* Опция `--show-timings`  позволяет пользователям получить информацию о времени выполнения каждой команды в процессе сборки.
  
При использовании опции `--show-timings`, после каждой выполненной сборочной команды `ya make` добавляет в вывод время, потребовавшееся на её выполнение. Это позволяет разработчикам определить узкие места в процессе сборки, которые требуют оптимизации, чтобы ускорить общее время сборки проекта.

Опция `--show-timings` должна использоваться совместно с опцией `-T`, которая изменяет вывод статуса на построчный, чтобы обеспечить корректное отображение времени выполнения команд.

* Опция `--log-file=LOG_FILE`  предоставляет возможность перенаправления подробного журнала выполнения сборки в указанный пользователем файл. Это позволяет сохранить все детали процесса сборки для последующего анализа, аудита или использования в системах мониторинга и уведомлений.

При запуске `ya make` с этой опцией, все сообщения, обычно выводимые на стандартный вывод (stdout) и стандартный вывод ошибок (stderr), будут также дополнительно записаны в файл, путь к которому указан в параметре `LOG_FILE`. Это включает в себя вывод команд, предупреждения, сообщения об ошибках и любую другую информацию, генерируемую во время сборки.

`ya make --log-file=build.log`

В этом примере все данные сборки, включая логи сборки и логи событий, будут сохранены в файл `build.log`.

* Опция `--stat-dir=STATISTICS_OUT_DIR` используется с инструментом `ya make` для указания директории, в которую будут выводиться дополнительные статистические данные о процессе сборки. Эта функциональность позволяет разработчикам сохранять различные метрики и аналитические данные о сборке в отдельное место, что способствует более удобному доступу и анализу последующими инструментами или для внутреннего аудита.

При запуске `ya make` с использованием `--stat-dir=STATISTICS_OUT_DIR`, система сборки автоматически создает указанную директорию (если она уже не существует) и начинает записывать в нее файлы со статистической информацией о процессе сборки. Статистика может включать данные о времени выполнения, использовании кэшей, деталях критического пути, долгих сборочных шагах и других аналитических метриках.

`ya make --stat-dir=./build_stats` В этом случае все статистические данные сборки будут сохранены в директорию `./build_stats` относительно текущей рабочей директории.

* Опция `--no-emit-status` применяется для управления выводом статуса процесса сборки в командной строке. Когда эта опция активирована, `ya make` не будет выводить в терминал регулярные обновления статуса сборки, которые обычно информируют пользователя о текущем действии, выполняемом сборочной системой. Это может включать начало выполнения определенной задачи, завершение задачи, ошибки сборки и предупреждения.

Активация `--no-emit-status` существенно сокращает количество информации, выводимой в процессе выполнения сборки, оставляя лишь критически важные сообщения или результаты выполнения. Стандартные обновления прогресса, которые обычно предоставляются для информирования пользователя о ходе сборки, будут подавлены.

* Опция `--do-not-output-stderrs` используется  для подавления вывода всех сообщений об ошибках в стандартный поток ошибок (stderr).

При использовании опции `--do-not-output-stderrs`, все сообщения, которые обычно направляются в стандартный поток ошибок (например, компиляторные ошибки, предупреждения, ошибки исполнения и т.д.), не будут отображаться в терминале. Это не влияет на стандартный поток вывода (stdout), который может продолжать выводить другие сообщения, не связанные с ошибками.

* Опция `--mask-roots` предназначена для скрытия или маскирования путей к исходным и сборочным директориям в сообщениях об ошибках, которые выводятся в стандартный поток ошибок (stderr). Это делается для улучшения безопасности и портативности вывода ошибок, а также для упрощения чтения и анализа сообщений об ошибках при сборке.

При активации опции `--mask-roots`, всякий раз, когда в выводе ошибок должен будет отображаться полный путь к файлу или директории (например, путь к файлу, в котором произошла ошибка компиляции), `ya make` автоматически заменяет его на относительный путь или маскированное представление. Это позволяет скрыть абсолютные пути, которые могут содержать имена пользователей, специфичные для системы имена директорий или другую чувствительную информацию.

Этот параметр особенно полезен при обмене логами сборки с другими разработчиками или при публикации их в открытом доступе (например, в рамках отчетов об ошибках в интернете), поскольку предотвращает ненужное раскрытие информации о структуре файловой системы, настройках среды разработки или личных данных.

* При использовании `--no-mask-roots`, пути к исходным и сборочным директориям будут отображаться в полном виде в сообщениях об ошибках, направляемых в стандартный поток ошибок (stderr). Таким образом, в логах ошибок будут видны абсолютные пути, включая всю информацию о структуре директорий.

Опция используется в ситуациях, когда разработчикам необходимо точно знать, где находится файл или директория, вызвавшая определенную ошибку сборки, для быстрого доступа и внесения корректив.

* Опция `--html-display=HTML_DISPLAY` активирует генерацию вывода процесса сборки в формате HTML. Этот режим предназначен для создания визуально более доступной и удобочитаемой версии логов сборки, которую можно просматривать в веб-браузере. Включение этой опции приводит к тому, что результаты выполнения команд сборки, включая сообщения об ошибках, предупреждения, а также информацию о прогрессе сборки, будут представлены в виде HTML-документа.

Значение, передаваемое с опцией (`HTML_DISPLAY`),  указывает путь к файлу или директории, где должен быть сохранен сгенерированный HTML-файл. После завершения процесса сборки пользователь может открыть указанный HTML-файл в любом веб-браузере и просмотреть результаты сборки в удобном и наглядном формате.

Использование этой опции предоставляет дополнительные возможности для визуализации и анализа процесса сборки, делает информацию более доступной и легко интерпретируемой для различных категорий пользователей.

## Конфигурация платформы/сборки 

Опция `-d` (также указываемая как `--debug` или `--build debug`) задает процесс сборки в режиме отладки для проекта. Этот режим предназначен для разработки и отладки программы, поскольку обеспечивает наиболее полную информацию для анализа и исправления ошибок. Такой режим установлен по умолчанию.

Особенности сборки отладки:
  * **Без оптимизаций**: Для кода на C\+\+, например, уровень оптимизации компилятором устанавливается как `-O0`, что гарантирует отсутствие оптимизаций кода. Это облегчает процесс отладки, так как каждая строка исходного кода может быть прямо отнесена к определенному месту в скомпилированном бинарном файле.
  * **С отладочной информацией**: Сборка включает в себя отладочную информацию, что позволяет отладчикам и другим инструментам анализа предоставлять более подробную информацию об объектах, функциях, переменных и так далее.
  * **С ассертами**: Включение ассертов (утверждений) облегчает проверку предусловий, постусловий и инвариантов в коде во время его исполнения. Это помогает быстрее находить и исправлять ошибки логики программы.

Для кода на `C++` добавляется флаг `-fstack-protector`, который активирует функции защиты стека, помогая предотвратить определенные виды атак на переполнение буфера.

Пример использования:
`ya make -d` или `ya make --debug` или `ya make --build debug`
Эти команды инициируют процесс сборки в режиме отладки, обеспечивая создание бинарных файлов, оптимизированных для отладки, а не для выпуска в продакшн.

* Опция `--build=BUILD_TYPE`  позволяет указать конкретный тип сборки, определяющий уровень оптимизации, наличие отладочной информации, использование различных инструментов анализа и диагностики. В зависимости от выбранного `BUILD_TYPE`, сборка может быть адаптирована для различных целей: от разработки и отладки до тестирования производительности и подготовки к выпуску.

Варианты `BUILD_TYPE`:
  * `debug` (по умолчанию): Сборка без оптимизаций, с полной отладочной информацией и ассертами. Оптимизирована для разработки и отладки.
  * `release`: Сборка с максимальным уровнем оптимизации и ограниченной отладочной информацией. Предназначена для выпуска продукта.
  * `profile`: Специализированный тип сборки, оптимизированный для профилирования приложения.(Сборка с профилировкой - https://ru.wikipedia.org/wiki/Profile-guided_optimization )
  * `gprof`: Сборка предназначена для использования с GNU Profiler (gprof), инструментом профилирования производительности.
  * `valgrind`: Сборка, адаптированная для работы с Valgrind, инструментом для обнаружения утечек памяти и других ошибок.
  * `valgrind-release`: Оптимизированная версия сборки для использования с Valgrind, совмещающая оптимизации релизной сборки.
  * `coverage`: Сборка, инструментированная для сбора данных о покрытии кода тестами.
  * `relwithdebinfo`: Релизная сборка с отладочной информацией и ассертами, используется для основных проверок в CI.
  * `minsizerel`: Сборка, оптимизированная для минимизации размера исполняемого файла.
  * `debugnoasserts`: Сборка отладки без ассертов, что может быть полезно для производительности при отладке.
  * `fastdebug`: Отладочная сборка с некоторыми оптимизациями для ускорения процесса отладки.

Разработчики используют разные типы сборок для достижения различных целей на разных этапах разработки программного обеспечения:
  * `debug` для повседневной разработки и отладки.
  * `release` для тестирования производительности или подготовки к выпуску.
  * `coverage` для анализа покрытия тестами.
  * `valgrind` или `valgrind-release` для детального анализа исполнения и поиска проблем, связанных с управлением памятью.
  * Специализированные типы сборок, такие как `profile` или `gprof`, могут использоваться для детального профилирования приложения с целью оптимизации его производительности.

* Опция `--sanitize=SANITIZE` используетсядля активации инструментов санитайзера, которые предоставляют различные виды проверок на ошибки в программе на стадии выполнения. Санитайзеры — это мощные инструменты, предназначенные для обнаружения различных типов ошибок, таких как доступы к выходу за границы массивов, использование неинициализированных данных, утечки памяти, нарушения работы с потоками и другие. Они особенно полезны для выявления сложных для отладки проблем и повышения качества кода.

Варианты `SANITIZE`:
  * `address`: Санитайзер адресов (`AddressSanitizer`), помогает находить ошибки связанные с памятью, такие как выходы за границы массивов, использование после освобождения и двойное освобождение.
  * `memory`: Санитайзер памяти (`MemorySanitizer`), предназначен для обнаружения использований неинициализированной памяти.
  * `thread`: Санитайзер потоков (`ThreadSanitizer`), используется для выявления гонок данных и других проблем многопоточности.
  * `undefined`: Санитайзер неопределенного поведения (`UndefinedBehaviorSanitizer`), можно использовать для поиска неопределенных поведений в коде по стандарту языка программирования, таких как переполнение целочисленных значений или неправильное использование null-указателей.
  * `leak`: Санитайзер утечек памяти (`LeakSanitizer`), служит для обнаружения утечек памяти в программе.

Пример использования:
`ya make --sanitize=address`Команда активирует `AddressSanitizer` для обнаружения ошибок, связанных с неправильным обращением к памяти, таких как выход за границы массива или использование уже освобожденной памяти.

Использование санитайзеров является эффективным средством для повышения качества и безопасности кода.

* Опция `--race` предназначена для активации детектора гонок (race detector) при компиляции и сборке проектов, написанных на языке программирования Go.

Детектор гонок — это инструмент, который помогает разработчикам обнаруживать проблемы синхронизации в многопоточных или конкурентных программах, такие как состояние гонки (race condition), когда результат выполнения программы непредсказуемо зависит от порядка, в котором выполняются операции.

Когда вы компилируете и запускаете программу с включенным детектором гонок, инструмент анализирует операции чтения и записи общих данных между горутинами или потоками на предмет неправильного доступа, который может привести к гонкам. Это достигается за счет внедрения дополнительного инструментального кода в целевую программу, который наблюдает за операциями с памятью и отслеживает синхронизацию при доступе к данным. Если детектор обнаруживает потенциальную гонку, он выводит предупреждение с информацией о месте в коде, где возможна проблема.

* Опция `-D=FLAGS`  позволяет определять или переопределять переменные среды сборки (сборочные флаги), задавая их имя и значение. Даёт возможность динамически изменять параметры, влияющие на выбор конфигураций и другие аспекты сборки без необходимости изменения исходного кода или структуры проекта.
Пример `ya make -D=JDK_VERSION`

В команде `ya make` можно указать дополнительные флаги (переменные) с помощью опции `-DVAR[=VALUE]`. Если не указывать значение переменной, по умолчанию оно будет выставлено в `yes`.

Можно определить:
  * Предопределённые переменные, позволяющие передать флаги для сборки `ya make -DLDFLAGS="-fblabla=foo -fbar"`, `ya make -DCFLAGS="-DNN_DOUBLE_PRECISION -Wno-strict-aliasing"` и т. п.
  * Предопределённые переменные, управляющие конфигурацией, например `ya make -DCATBOOST_OPENSOURCE` (сборка как для open source) или `ya make -DCUDA_VERSION=10.1` (сборка с CUDA).
  * Переменные для использования в ya.make `ya make -DMACRO1 -DMACRO2=42`, где в `ya.make` написано, например `IF (MACRO1)`.

* Опция `--host-platform-flags=HOST_PLATFORM_FLAGS` позволяет указывать специфические флаги или настройки, которые применяются к сборочной платформе, то есть к системе, на которой запускается процесс сборки. В отличие от обычных флагов, которые направлены на конфигурацию процесса сборки для целевой платформы (то есть для системы, на которой будет запущен собранный продукт), опция `--host-platform-flags` влияет на то, как собираются инструменты и зависимости, используемые непосредственно при сборке.

Примеры использования: 
  * `--host-platform-flag MUSL`
Этот флаг указывает на необходимость использования `musl libc` вместо стандартной библиотеки `glibc` для сборки инструментов, которые требуются для создания продукта. 
  * `-DUSE_PREBUILT_TOOLS=no --host-platform-flag=USE_PREBUILT_TOOLS=no`
Эти флаги обеспечивают полное отключение использования предпостроенных инструментов в процессе сборки, требуя вместо этого компиляции всех необходимых инструментов из исходного кода непосредственно во время сборки. 

* Опция `--target-platform=TARGET_PLATFORMS` позволяет явно указать целевую платформу для сборки проекта, определяемую тройкой значений: компилятор, операционная система (OS) и архитектура процессора. Целевая платформа — это платформа, для которой предназначен итоговый продукт или артефакт сборки. Платформа определяет ключевые характеристики сборки, включая используемый компилятор, архитектуру CPU и операционную систему, что влияет на процесс компиляции и настройки линковки.

Как работает опция:

  * Указание целевой платформы в формате `<компилятор-OS-архитектура>` позволяет настроить сборку для специфических требований и учета особенностей разных платформ.
  * Можно задать подмножество тройки, например, только OS или архитектуру, при этом оставшиеся аспекты будут выбраны по умолчанию, основываясь на текущей среде сборки или предустановленных значениях.
  * Специальное значение `DEFAULT` для компилятора позволяет использовать стандартный компилятор, который обычно используется в данной операционной системе для целевой архитектуры.

Примеры использования:

  * `--target-platform clang-win-x86_64`
Собрать программу для Windows на Intel 64bit используя компилятор Clang.
  * `--target-platform default-android-armv8a`
Собрать приложение для Android на архитектуре ARM версии armv8a, используя компилятор по умолчанию для этой платформы.
  * `--target-platform windows`
Собрать проект для Windows, используя архитектуру по умолчанию (обычно x86_64) и стандартный компилятор для Windows.

Особенности использования при сборке под macOS:

  * При сборке для macOS в качестве OS указывается `DARWIN`.
  * Для Apple Silicon (процессоры M1) используется `default-darwin-arm64`, так как архитектура по умолчанию для macOS - это x86-64.

Система сборки поддерживает одновременную сборку под несколько платформ, что позволяет использовать `--target-platform` несколько раз для разных вариантов сборки в одной команде.

Важные замечания:
  * Каждая указанная целевая платформа приведет к генерации отдельного артефакта. `ya make` не поддерживает создание мультиплатформенных бинарных файлов (fat binaries) автоматически.
  * Если артефакты для разных платформ имеют одинаковые имена, их результаты могут конфликтовать или перезаписывать друг друга, что может привести к непредсказуемым результатам сборки.

* Опция `--target-platform-flag=TARGET_PLATFORM_FLAG` позволяет задать специфические флаги (-D флаги) или параметры конфигурации для определённой целевой платформы.

Опция `--target-platform-flag` позволяет управлять поведением сборки на уровне конкретной платформы, передавая в процесс сборки параметры, специфичные для данной платформы. Используемое значение `TARGET_PLATFORM_FLAG` определяет, какие именно флаги или параметры будут применены.

Замечания:
  * Для каждой целевой платформы могут быть заданы свои уникальные флаги.
  * Порядок указания флагов имеет значение, так как последующие опции могут перезаписывать или дополнять предыдущие.
  * Используйте `ya package` для предсказуемой сборки под несколько платформ.

* Опция `--sanitizer-flag=SANITIZER_FLAGS` используется для задания дополнительных параметров или флагов, которые будут переданы инструментам санитайзера.

Санитайзеры — это специальные инструменты, встроенные в компиляторы (например, в GCC или Clang), предназначенные для автоматического обнаружения различных видов ошибок в программе на этапе выполнения, таких как использование неинициализированной памяти, выход за границы массивов, утечки памяти, гонки данных и другие типы неопределенного поведения.

Принцип работы:

При компиляции исходного кода с использованием санитайзера, компилятор встраивает в бинарный код специальные проверки, которые во время выполнения программы могут обнаруживать различные типы ошибок. Опция `--sanitizer-flag` позволяет настроить работу санитайзеров, уточнив или расширив список выполняемых проверок, или же сконфигурировать поведение санитайзера более тонко.

Использование `--sanitizer-flag` требует знания возможных параметров конкретного санитайзера и понимания их влияния на процесс проверки.

* Опция `--lto` используется , чтобы включить режим сборки с Link Time Optimization (LTO).

LTO — это метод оптимизации, выполняемый компоновщиком (линкером) при сборке исполняемых файлов или библиотек, что позволяет улучшить производительность и уменьшить размер итогового бинарного файла за счет анализа и оптимизации всего кода приложения в целом, а не отдельных его модулей.

Традиционно, компиляция исходного кода на языках `C/C++` происходит по модулям или единицам трансляции, после чего компоновщик (линкер) собирает все объектные файлы в один исполняемый файл или библиотеку. Оптимизации, доступные компилятору, ограничены областью одной единицы трансляции. В отличие от этого, LTO позволяет линкеру анализировать и оптимизировать код на более глобальном уровне, имея доступ ко всему уже развернутому представлению программы.

При включении LTO компилятор генерирует дополнительные метаданные для каждой единицы трансляции, что позволяет линкеру применять межмодульные оптимизации. Это может включать удаление неиспользуемого кода (“dead code elimination”), инлайнинг функций между модулями, оптимизацию обращений к памяти и другие трансформации.

`ya make --lto` Эта команда запускает сборку проекта с включенным LTO, что предполагает оптимизацию на этапе линковки.

* Опция `--thinlto` активирует использование технологии Thin Link Time Optimization (ThinLTO) при сборке и линковке проекта. ThinLTO является усовершенствованной версией стандартного Link Time Optimization (LTO), предлагая баланс между скоростью сборки и эффективностью оптимизации кода, что делает её особенно привлекательной для крупных и сложных проектов.

ThinLTO улучшает процесс LTO, внедряя концепцию “разбавленного” (thin) представления модулей. В отличие от полного LTO, которое требует передачи всего кода каждого модуля компоновщику для глобальной оптимизации, ThinLTO создаёт сокращённые сводки модулей, содержащие достаточно информации для проведения межмодульных оптимизаций, таких как инлайнинг функций и удаление неиспользуемого кода. Эти сводки значительно меньше полных модулей по размеру и позволяют распараллелить обработку разных модулей, что ускоряет процесс оптимизации без значительной потери в её качестве.

* Опция `--afl`  указывает на использование American Fuzzy Lop (AFL) в качестве инструмента для фаззинга (fuzz testing) вместо стандартно используемого libFuzzer.

Фаззинг — это автоматизированный метод тестирования программного обеспечения, который заключается в подаче непредсказуемых или случайных данных на вход программам с целью обнаружения ошибок, уязвимостей или нестандартного поведения программа.

AFL — это широко известный и эффективный инструмент фаззинга, который автоматически генерирует входные данные, пытаясь вызвать сбои, зависания или другие ошибки в тестируемом программном обеспечении. AFL отслеживает изменения в поведении программы, вызванные различными вводимыми данными, используя техники, такие как инструментирование кода и генетические алгоритмы, чтобы эффективно исследовать пространство потенциальных входных данных. AFL часто используется для проверки устойчивости системы безопасности, поиска уязвимостей в бинарных файлах и анализа выполнения кода.

`ya make --afl` Использование этой опции переключает контекст тестирования так, чтобы для фаззинга выбирался не libFuzzer, а AFL, что может быть предпочтительным в зависимости от конкретных требований проекта, специфики тестируемого программного обеспечения или предпочтений команды разработчиков.

Опция `--musl`  указывает на необходимость сборки проекта с использованием библиотеки musl libc вместо стандартной C библиотеки (glibc в большинстве Linux дистрибутивов). 

musl libc — это легковесная, высокопроизводительная и стандартно-совместимая реализация стандартной библиотеки языка программирования С, предназначенная для обеспечения простоты и эффективности.

musl libc предоставляет функционал, эквивалентный традиционной glibc, но с упором на простоту реализации, меньший размер бинарных файлов и меньшее потребление ресурсов системы. 

*  Опция `--hardening`  применяется в процессе сборки проекта с более строгими проверками в коде.

Влияет на повышение безопасности исполняемого файла за счёт предотвращения или усложнения определённых типов атак, особенно связанных с переполнениями буфера, исполнением кода и другими уязвимостями, связанными с неправильной обработкой памяти.

*  Опция `--cuda=CUDA_PLATFORM` позволяет управлять интеграцией и использованием технологии NVIDIA CUDA при сборке проекта.

CUDA (Compute Unified Device Architecture) — вычислительная платформа и программная модель, разработанная NVIDIA, позволяющая значительно увеличить вычислительную производительность за счёт использования мощности графических процессоров (GPU).

Опция `--cuda` может принимать одно из трёх значений: `optional`, `required`, `disabled`, что определяет способ обращения сборочного процесса к функциональности CUDA.

Значения опции `--cuda`:

  * **optional** (по умолчанию): Сборка будет пытаться найти и использовать CUDA, если она доступна в системе. Если CUDA не найдена, сборка продолжится, исключив функции, зависящие от CUDA. Этот режим полезен, когда проект может использовать CUDA для ускорения, но не зависит от неё полностью, и может быть собран и функционировать без CUDA.
  * **required**: Указывает, что использование CUDA необходимо для сборки проекта. Сборка будет прервана с ошибкой, если компоненты CUDA недоступны. Применяется в случаях, когда функциональность или компоненты проекта строго зависят от CUDA и не могут быть реализованы без неё.
  * **disabled**: Полностью отключает поддержку и использование CUDA в проекте, даже если она доступна. Это может быть полезно, когда требуется гарантировать, что проект собран исключительно без использования GPU или для сборки проекта в среде, где CUDA не желательна или не может быть использована по лицензионным или другим соображениям.

* Опция `--host-build-type=HOST_BUILD_TYPE` позволяет явно указать тип сборки, который должен быть применён к компонентам, работающим на платформе хоста — то есть, на системе, где производится компиляция кода проекта. Опция предоставляет возможность точно настроить, какие оптимизации, флаги компиляции и другие параметры сборки будут использоваться для создания исполняемых файлов и библиотек, влияющих на процесс сборки, но не на само приложение, предназначенное для запуска на целевой платформе.

Значения `HOST_BUILD_TYPE`:
  * `debug`: Сборка без оптимизаций и с полной отладочной информацией. Идеально подходит для отладки сборочного процесса или инструментов сборки, когда требуется полное понимание происходящего в процессе компиляции и линковки.
  * `release`: Этот тип сборки активирует оптимизации компилятора и может сокращать отладочную информацию для повышения производительности исполняемых файлов, используемых в процессе сборки. Более подходит для ускорения самого процесса сборки.
  * `profile`, `gprof`, `valgrind`, `valgrind-release`, `coverage`, `relwithdebinfo`, `minsizerel`, `debugnoasserts`, `fastdebug`: Эти типы определяют различные специализированные режимы сборки, адаптированные под профилирование, анализ производительности, проверку покрытия кода и т.п. Они позволяют настраивать процесс сборки с инструментами и опциями, оптимизированными под конкретные цели разработки и отладки.

* Опция `--host-platform=HOST_PLATFORM` позволяет указать, для какой хостовой платформы (то есть платформы, на которой непосредственно выполняется сборка) должны быть собраны инструменты и зависимости проекта. Эта опция важна при кросс-компиляции, когда код, написанный и собираемый на одной платформе (хост), предназначен для выполнения на другой платформе (целевой).

Система сборки ya make позволяет отделить процесс  от сборки и потому кроме задания *целевой платформы* можно указать *сборочную платформу* (опция `--host-platform`). 
Однако, эта возможность вам вряд ли понадобится в повседневной работе - для локальной сборки это имеет мало смысла, потому что, по умолчанию в качестве целевой и сборочной платформ выбирается та, где запущена сборка.

* Опция `--c-compiler=C_COMPILER` используется для указания конкретного компилятора языка C, который должен быть использован при компиляции исходного кода проекта. Это позволяет разработчику или сборочной системе выбрать определённую версию компилятора C или использовать альтернативные реализации вместо стандартного компилятора, предоставляемого средой разработки или операционной системой.

Компиляторы C, такие как GCC (GNU Compiler Collection), Clang (разработанный проектом LLVM), и другие, могут иметь различия в реализации стандартов языка C, поддержке расширений, оптимизациях и предупреждениях. Выбор определённого компилятора может быть обусловлен необходимостью воспользоваться его уникальными возможностями или обеспечить совместимость с определённой кодовой базой или библиотеками.

Примеры использования:
  1. **Указание использовать компилятор GCC для сборки проекта:** `ya make --c-compiler=gcc`
  2. **Указание использовать компилятор Clang для сборки проекта:** `ya make --c-compiler=clang`

* Опция `--cxx-compiler=CXX_COMPILER` используется для указания конкретного компилятора `C++`, который должен использоваться для компиляции исходного кода проекта. Эта опция позволяет явно задать как абсолютный путь к исполняемому файлу компилятора, так и имя компилятора (в случае, если он доступен в стандартном пути поиска исполняемых файлов в операционной системе), для сборки как на платформе хоста, так и для целевой платформы.

При сборке проектов на `C++` необходимо использовать компилятор, который может быть специфичен для проекта или окружения, в котором он разрабатывается. Опция `--cxx-compiler` позволяет переопределить стандартный выбор компилятора системы сборки на заданный пользователем, что особенно полезно в следующих случаях:

Допустим, у вас есть специально собранный компилятор Clang, расположенный в `/opt/clang/bin/clang++`, и вы хотите, чтобы именно он использовался для сборки вашего проекта: `ya make --cxx-compiler=/opt/clang/bin/clang\+\+`

Или если вы хотите использовать конкретную версию g++, доступную в вашей системе под именем `g++-9`: `ya make --cxx-compiler=g\+±9`

* Опция `--pgo-add` используется для активации процесса создания Profile-Guided Optimization (PGO) профиля для вашего проекта.

PGO — это техника оптимизации, которая позволяет компилятору собрать данные о выполнении программы при её реальной работе, а затем использовать эту информацию для более эффективной оптимизации на стадии последующей компиляции.

Использование PGO дает значительное улучшение производительности для многих программ, особенно тех, где критические участки кода или пути выполнения могут быть эффективно идентифицированы только при выполнении.

* Опция `--pgo-use=PGO_USER_PATH` используется для указания пути к файлам профиля, сгенерированным в результате предыдущего выполнения программы с включенным [Profile-Guided Optimization](https://ru.wikipedia.org/wiki/Profile-guided_optimization) (PGO). Эти профили содержат ценные данные о выполнении программы, собранные в процессе работы инструментированной версии программы, собранной с опцией `--pgo-add`. Затем эти данные используются для оптимизации сборки проекта, позволяя компилятору производить более информированные и точные оптимизации на основе реального использования кода.

Если предположить, что данные профиля сохранены в файле `profile-data/default.profraw`, то для использования этих данных в процессе оптимизации команда будет выглядеть следующим образом: `ya make --pgo-use=profile-data/default.profraw`

* Опция `--pic`  указывает на необходимость принудительного использования режима Position-Independent Code (PIC) в процессе компиляции исходного кода проекта. Этот режим широко используется при создании динамических библиотек, обеспечивая их совместимость и эффективность работы в различных адресных пространствах памяти, независимо от того, куда они были загружены при выполнении программы.

Position-Independent Code — это тип машинного кода, выполнение которого не зависит от его физического адреса в памяти. Это достигается за счёт использования относительной адресации для инструкций перехода, доступа к данным и работы со статическими переменными, вместо абсолютной адресации. Такой подход позволяет программному коду быть более модульным, переносимым и легко внедряемым в другие приложения или системы в качестве динамически подключаемых библиотек или модулей.

Режим PIC особенно важен и широко применяется при разработке:
  * Динамически подключаемых библиотек (shared libraries) для операционных систем на основе Unix и Linux, так как такие библиотеки часто загружаются в произвольные области адресного пространства.
  * Переносимого кода, предназначенного для использования на разных платформах или в пространствах исполнения, где не гарантировано фиксированное распределение адресов.

* Опция `--maps-mobile` активирует специальный набор настроек сборки, оптимизированный для разработки мобильных приложений Яндекс Карт (Yandex Maps for mobile devices).

Такая конфигурации сборки включает в себя определённые флаги компиляции, линковки и другие параметры сборки, нацеленные на улучшение производительности, снижение потребления памяти и минимизацию размера итогового кода приложения, что критично для мобильных устройств с ограниченными ресурсами.

**Экспертные опции**

* Опция `--sanitize-coverage=SANITIZE_COVERAGE`  используется для активации сбора данных о покрытии кода при выполнении инструментами санитайзера. 

При активации этой опции компилятор вставляет в бинарный код дополнительные инструкции, которые регистрируют, какие строки кода, функции или условные переходы были выполнены в процессе работы программы. Эти данные могут быть использованы для анализа и создания отчётов о покрытии кода тестами.

* Опция `--target-platform-build-type=TARGET_PLATFORM_BUILD_TYPE`  позволяет определить тип сборки для конкретной целевой платформы, когда проект компилируется для нескольких различных платформ. Опция дает возможность уточнить тип сборки, что позволяет оптимизировать скомпилированное приложение или библиотеку под конкретные характеристики и требования выбранной целевой платформы.

Значение `TARGET_PLATFORM_BUILD_TYPE` указывает на конкретный тип сборки, который может быть одним из следующих или других, зависящих от специфики проекта и доступных опций компилятора:
  * `debug`: Создает сборку с отладочной информацией и без оптимизаций, что упрощает отладку, но может снижать производительность.
  * `release`: Сборка для релиза с активированными оптимизациями компилятора и с минимальной или отсутствующей отладочной информацией, что обеспечивает максимальную производительность.
  * `profile`: Сборка предназначена для профилирования, включает механизмы и метки времени выполнения для измерения производительности различных частей кода.
  * `coverage`: Включает инструменты для измерения покрытия кода тестами, помогает определить, какие строки кода были выполнены во время работы тестов.

И другие типы сборок, со специфическими флагами и настройками компилятора, влияющими на производительность, размер исполняемых файлов, безопасность и другие аспекты.

Допустим, ваш проект предназначен для развертывания как на серверах с Linux, так и на устройствах с Windows. Вы хотите, чтобы для Linux использовалась сборка `release`, а для Windows — `debug`. В этом случае вы можете указать:

ya make --target-platform linux-x86_64 --target-platform-build-type=release --target-platform windows-x86_64 --target-platform-build-type=debug

Это гарантирует, что для каждой целевой платформы будут применены оптимальные настройки сборки.

* Опция `--target-platform-release`  используется для явного указания, что сборка проекта для последней назначенной целевой платформы должна быть выполнена в режиме `release`. Этот режим сборки оптимизирован для максимальной производительности и минимального размера итогового продукта, поскольку включает в себя различные оптимизации компилятора и, как правило, исключает отладочную информацию, которая может быть не нужна в финальной версии программы.

Предположим, что проект разрабатывается для нескольких платформ, но для целевой платформы Windows требуется создать более оптимизированную версию для релиза:

ya make --target-platform windows-x86_64 --target-platform-release

Эта команда установит тип сборки в `release` для платформы Windows x86_64, активировав соответствующие оптимизации и настройки сборки.
* Опция `--target-platform-debug`  предназначена для установления типа сборки в режим “отладка” (debug mode) для последней указанной целевой платформы. Этот режим обычно используется в процессе разработки и отладки программного обеспечения, поскольку он предоставляет разработчикам расширенную информацию для диагностики и исправления ошибок, а также упрощает процедуру отладки благодаря включению отладочных символов и отключению оптимизаций компилятора.

Когда проект собирается с использованием этой опции, компилятор настраивается на генерацию дополнительной отладочной информации и символов, что позволяет отладчикам получать доступ к именам переменных, строкам исходного кода и стеку вызовов во время выполнения программы.

Если вы работаете над мультиплатформенным проектом и хотите убедиться, что сборка для определенной платформы, например Android, выполнена в режиме отладки, то используйте следующую команду:

ya make --target-platform android-arm64 --target-platform-debug

* Опция `--target-platform-tests` предназначена для запуска тестов, специфичных для последней указанной в команде целевой платформы. Эта функциональность позволяет разработчикам и тестировщикам выполнить автоматизированные тесты, которые могут включать юнит-тесты, интеграционные тесты или другие виды тестирования. Это актуально в среде мультиплатформенной разработки, где требуется обеспечить надежное функционирование программного обеспечения на разнообразном оборудовании и операционных системах.

Когда вы используете `--target-platform-tests`, `ya make` настраивает среду сборки таким образом, чтобы тестируемое ПО было скомпилировано и подготовлено специально для ранее указанной целевой платформы. После компиляции запускаются тесты, которые были разработаны или настроены для выполнения на этой платформе. Это даёт возможность автоматически проверить, соответствует ли код стандартам качества и работоспособности на конкретном типе оборудования или в определённой операционной системе.

Предположим, что вы разрабатываете приложение, которое должно работать как на Windows, так и на Linux. Чтобы запустить тесты для Windows-версии приложения, вы могли бы использовать следующую команду:

ya make --target-platform windows-x86_64 --target-platform-tests

Это запустит процесс сборки приложения для Windows на архитектуре x86_64, после чего будут запущены тесты, специально предназначенные или адаптированные для этой платформы.

Опция `--target-platform-test-type=TARGET_PLATFORM_TEST_TYPE`  используется для запуска определённого типа тестов для указанной целевой платформы. Этот параметр позволяет более точно настроить тестирование, ограничиваясь определённым типом тестов, что полезно в мультиплатформенной разработке, когда для разных платформ могут быть предусмотрены различные наборы тестов в зависимости от специфики платформы, требований к тестированию или наличия ресурсов.

* Опция `--target-platform-regular-tests`  является специализированной командой, которая инициирует запуск тестов, ограничиваясь предопределенным набором типов тестов, оптимизированных для выполнения на последней указанной целевой платформе. Эта функциональность полезна в средах мультиплатформенной разработки, где важно эффективно распределить ресурсы тестирования и сосредоточить усилия на ключевых аспектах верификации программного обеспечения.

`ya make --target-platform=linux-x86_64 --target-platform-regular-tests` Эта команда запускает стандартный набор тестов для проекта, предназначенного для выполнения на Linux с архитектурой x86_64.

* Опция `--target-platform-c-compiler=TARGET_PLATFORM_COMPILER` позволяет определить и установить пользовательский компилятор языка C для компиляции проекта, специфично для указанной целевой платформы. Это означает, что разработчики могут указать конкретный путь к исполняемому файлу компилятора C, который должен использоваться вместо стандартного или иного компилятора по умолчанию, определенного в системе сборки.

Опция предоставляет разработчикам возможность более гибко управлять процессом сборки программного обеспечения на языке C, позволяя использовать различные версии компиляторов или специализированные компиляторы, адаптированные под конкретные требования проекта или особенности целевой платформы.

* Опция `--target-platform-cxx-compiler=TARGET_PLATFORM_COMPILER`  используется для явного указания компилятора `C++`, который должен применяться при компиляции исходного кода на `C++` для целевой платформы.

Когда разработчики создают приложения, предназначенные для работы на нескольких платформах, возможно, потребуется использование разных компиляторов для оптимальной поддержки каждой из платформ.

* Опция `--target-platform-target=TARGET_PLATFORM_TARGET`  позволяет указать конкретные цели сборки для последней определённой целевой платформы, в контексте корневого каталога исходного кода проекта.

При использовании системы сборки `ya make`, цели сборки могут включать отдельные исполняемые файлы, библиотеки или другие ресурсы, которые должны быть скомпилированы или собраны из исходного кода. Через опцию `--target-platform-target` можно явно указать список таких целей, определяя их относительно корневого каталога исходного кода проекта. Это дает возможность точно задать, что именно требуется собрать, ориентировано на конкретные потребности разработки или тестирования для выбранной платформы.

* Опция `--target-platform-ignore-recurses` используется для оптимизации процесса сборки по аналогии опции `ignore-recurses` в контексте указанной целевой платформы.

## Локальный кеш

* `--cache-stat` — перед сборкой выдать статистику по наполнению локального кэша

Опция `--cache-stat` предназначена для получения подробной статистики по состоянию локального кеша сборки. 

Локальный кеш  — это хранилище на диске, где сохраняются результаты сборок, промежуточные файлы и другие данные, которые могут быть повторно использованы для ускорения последующих процессов сборки.

При запуске сборки с этой опцией, до начала самого процесса сборки, система анализирует содержимое локального кеша и выводит статистику.

* Опция `--gc`  используется для проведения операции “сбора мусора” на диске, где хранятся данные кеша сборки. Эта операция предназначена для удаления устаревших или неиспользуемых файлов кеша, что позволяет освободить дисковое пространство и повысить эффективность процесса сборки за счет уменьшения объема данных для просмотра и обработки.

`ya make --gc` Это указание системе пройтись по локальному кешу, очистить его от ненужных данных и только после этого начать выполнение запрошенных задач сборки.

Можно явно почистить диск с помощью команды `ya gc cache`. Вместе с очисткой делаются дополнительные проверки на ошибки.

* Опция `--gc-symlinks` предназначена для  очистки кеша сборки, фокусируясь на удалении символических ссылок. Эти символические ссылки обычно указывают на результаты предыдущих сборок и используются для оптимизации процесса сборки за счет переиспользования уже сгенерированных ресурсов. 

Опция `--gc-symlinks` позволяет удалить эти ссылки, не затрагивая файлы, нужные для текущей сборки, определенной текущим графом зависимостей проекта.

При запуске команды с этой опцией система сборки проходит по всем символическим ссылкам, созданным в рамках кеширования результатов сборок, и удаляет те из них, которые уже не соответствуют ни одному элементу в текущем графе сборки.

Опция `--gc-symlinks` влияет только на символические ссылки, не затрагивая основных файлов ресурсов и исходного кода.

* Опция `--tools-cache-size=TOOLS_CACHE_SIZE` используется для задания ограничения на максимальный размер кэша инструментов.

Кэш инструментов — это специализированное хранилище на диске, предназначенное для сохранения различных компиляторов, библиотек, SDK, эмуляторов и других инструментов, которые используются в процессе сборки.

Эта опция позволяет управлять объемом дискового пространства, выделенного под кэширование таких инструментов, что помогает оптимизировать использование ресурсов системы.

При задании этой опции с определенным числовым значением, система сборки будет ограничивать использование дискового пространства под кэш инструментов заданным размером. Если в процессе выполнения сборки общий размер кэшированных инструментов превышает указанный лимит, система автоматически удалит наименее часто используемые (или самые старые) данные из кэша, чтобы освободить место и удерживать его размер в заданных рамках.

В командной строке, перед запуском процесса сборки, добавьте опцию `--tools-cache-size`, за которой следует значение, указывающее максимальный размер кэша инструментов. Например:

`ya make --tools-cache-size=10GiB` Эта команда запустит сборку проекта, при этом максимальный размер кэша инструментов будет ограничен 10 гигабайтами.

Максимальный размер кеша инструментов (по умолчанию: 30.0GiB)

* Опция `--symlinks-ttl=SYMLINKS_TTL` используется для задания времени жизни (TTL, Time-To-Live) кеша результатов сборки, доступного через символические ссылки. Значение TTL указывает, как долго результаты сборки, представленные в виде символических ссылок, должны храниться в кеше, прежде чем будут автоматически удалены системой сборки для освобождения места или обновления данных. Задание TTL позволяет эффективно управлять ресурсами файловой системы, автоматически удаляя устаревшие или малоиспользуемые результаты сборки.

При указании этой опции с конкретным числовым значением, сборочная система будет отслеживать время существования каждой символической ссылки на результаты сборки в кеше. Как только для какой-либо ссылки прошедшее время превысит заданный TTL, соответствующий результат сборки (или ссылка на него) будет автоматически удален из кеша. Это предохраняет систему от переполнения устаревшими данными и помогает поддерживать кеш в актуальном и оптимизированном состоянии.

Эту опцию можно использовать при запуске команды сборки для указания системе, как долго хранить символические ссылки на результаты сборки в кеше. 

Указываемое значение `SYMLINKS_TTL` обычно задаётся в часах. По умолчанию, как указано, оно составляет `168.0` часов, что равно одной неделе.

* Опции `--cache-size=CACHE_SIZE`, `--cache-codec=CACHE_CODEC`, и `--auto-clean=AUTO_CLEAN_RESULTS_CACHE` представляют собой настройки, позволяющие детально управлять кешем результатов систем сборки. 

Эти опции позволяют оптимизировать использование дисковых ресурсов и процесс сборки в целом, обеспечивая эффективность и актуальность хранимых данных.

`--cache-size=CACHE_SIZE`  - опция задаёт максимальный размер кеша результатов сборки, выраженный в гигабайтах или других единицах измерения. С её помощью можно ограничить объём дискового пространства, выделяемого под хранение результатов работы системы сборки, что помогает предотвратить чрезмерное использование дискового пространства.

`--cache-codec=CACHE_CODEC` - опция указывает на метод (алгоритм) кодирования, используемый для сжатия или прочего преобразования данных в кеше.

`--auto-clean=AUTO_CLEAN_RESULTS_CACHE` - Автоматическая очистка кеша результатов (по умолчанию: True)

Включает или отключает автоматическую очистку неактуальных или редко используемых данных в кеше. Когда эта опция активирована, система сборки будет самостоятельно контролировать состояние кеша и удалять из него устаревшие данные.

## Функциональные флаги

Опция `--no-local-executor` указывает системе сборки изменить метод выполнения субпроцессов во время сборки проекта. 

В стандартной конфигурации  системы сборки, используют специализированные “исполнители” или “executor’ы” для управления запуском и выполнением субпроцессов, таких как компиляция кода, линковка библиотек и т.п. 

Эти исполнители могут предоставлять дополнительные возможности для оптимизации и контроля процесса сборки, включая параллелизм, кэширование результатов и мониторинг состояния.

Однако, в некоторых случаях или для определенных задач может потребоваться отказаться от использования встроенного исполнителя в пользу стандартного механизма запуска процессов в операционной системе, предоставляемого модулем Popen из стандартной библиотеки Python. 

Это может быть необходимо из-за специфических требований к среде выполнения или для обеспечения совместимости с определенными внешними системами или инструментами.

`ya make --no-local-executor` - команда запустит процесс сборки, где все субпроцессы будут исполнены с использованием Popen, обходя таким образом стандартную логику исполнителя сборочной системы.

Влияние использования Popen:

1. Совместимость: Popen позволяет запускать процессы в более “чистой” среде, что может быть необходимо для совместимости с определенными инструментами или сценариями использования, требующими стандартного поведения окружения ОС.
2. Прозрачность: Запуск субпроцессов через Popen может упростить отладку и анализ процесса сборки, поскольку поведение Popen хорошо документировано и широко известно разработчикам.
3. Ограничения: Отказ от использования специализированных исполнителей может привести к потере некоторых оптимизаций процесса сборки, предоставляемых системой сборки, таких как управление зависимостями на уровне задач и оптимизация параллельного выполнения задач.

* Опция `--dir-outputs-test-mode` предназначена для активации экспериментальных или новых функций, связанных с обработкой вывода сборочных процессов в директории.

Включает  проверку правильности местоположения выходных файлов, соответствие ожидаемой структуре директорий и верности выходных данных в них.

При использовании этой опции система сборки активирует новые или экспериментальные функции, которые могут быть ещё не включены по умолчанию из-за их тестового статуса или потенциальной нестабильности. 

* Опция `--disable-runner-dir-outputs` используется для  управление выводами в виде директорий (dir_outputs). Эта настройка позволяет отключить функциональность, связанную с автоматическим управлением директориями для хранения результатов исполнения задач сборки.

В обычных условиях, при выполнении задач сборки, система может автоматически создавать и управлять директориями для хранения вывода каждой задачи, например, скомпилированные объектные файлы, генерируемые исходные коды, или временные файлы, требуемые в процессе. Это делается для упорядочения и оптимизации процесса сборки, а также для облегчения последующей навигации по результатам сборки.

Опция `--disable-runner-dir-outputs` позволяет отключить эту автоматизацию. Необходимо, когда автоматическое управление выводами не желательно или когда необходимо самостоятельно контролировать структуру и расположение файлов результатов сборки для интеграции с другими инструментами или из соображений совместимости.

* Опция `--no-dump-debug` предназначена для управления выводом отладочной информации во время выполнения сборки проекта. Эта настройка позволяет отключить вывод расширенной отладочной информации или “дампов отладки”, которые могут быть генерированы сборочной системой для диагностики и анализа процесса сборки.

В обычном режиме работы система сборки автоматически генерирует различные типы отладочной информации или дампы, когда в процессе сборки возникают ошибки, предупреждения или для целей профилирования и оптимизации. 

К такой информации могут относиться логи вызовов функций, стек вызовов при сбоях, дампы памяти, статистика использования ресурсов и другие типы данных, полезные для разработчиков при диагностике и устранении проблем.

Опция `--no-dump-debug` указывает инструменту сборки не создавать или не сохранять эту расширенную отладочную информацию во время выполнения задач.

В результате использования этой опции объем генерируемых логов и файлов отладки может существенно сократиться, что может помочь ускорить процесс сборки и уменьшить затраты дискового пространства, особенно в крупных проектах.

## Загрузка

Опция `--ttl=TTL` используется для управления временем жизни (TTL, Time To Live) ресурсов или данных. Эта опция позволяет указать, на какой срок ресурс будет считаться актуальным или живым, после чего он может быть автоматически удален или инвалидирован системой. Время жизни задается в днях.

 Использование специального значения `inf`, указывает, что ресурс не должен быть удален. Это считается бесконечным временем жизни ресурса. Используется в ситуациях, когда необходимо, чтобы данные или ресурс оставались доступными на неопределенный срок. Пример использования — `--ttl=inf`.

Если опция `--ttl` не указана при создании или настройке ресурса, используется значение по умолчанию **14** дней. Это означает, что в отсутствие явного указания TTL, ресурс будет автоматически удаленсистемой по истечении 14 дней с момента его создания или последнего обновления.

## Авторизация


**Вопросы**

Два параметра в справке. Уточнить есть ли отличия
--key=SSH_KEYS Путь к приватному SSH ключу для обмена на OAuth токен
--ssh-key=SSH_KEYS Путь к приватному SSH ключу для обмена на OAuth токен

OAuth является открытым стандартом для делегирования доступа, позволяя приложениям безопасно делегировать пользовательскую аутентификацию во внешнюю службу, такую как GitHub, GitLab или любое другое API, которое поддерживает OAuth.

OAuth (Open Authorization) — это открытый стандарт для делегирования доступа, который используется в интернете для предоставления приложениям или веб-сайтам возможности запроса доступа к информации на других веб-сайтах, но без необходимости передавать логин и пароль пользователя. Это позволяет пользователям безопасно авторизовать сторонние приложения для доступа к их информации без раскрытия своих учетных данных. OAuth чаще всего используется для входа на сайты через социальные сети, такие как Facebook, Google, Twitter и др.

Благодаря OAuth, пользователи могут контролировать, какие именно данные они делятся с приложениями или сайтами, а также имеют возможность отзывать предоставленный доступ в любой момент. Этот стандарт предоставляет высокую степень безопасности для аутентификации и авторизации, ограничивая риски, связанные с хранением пользовательских паролей третьими сторонами.

* Опция `--key=SSH_KEYS` является частью механизма аутентификации и авторизации пользователя при доступе к определенным ресурсам, требующих проверки прав. Данная опция позволяет указать путь к приватному SSH ключу пользователя, который будет использоваться для обмена на OAuth токен. Этот токен, в свою очередь, предоставляет доступ к нужным ресурсам во время сборки.

Пользователь в командной строке явно указывает системе сборки путь к своему приватному SSH ключу при помощи опции `--key=ПУТЬ_К_КЛЮЧУ`. Этот ключ должен быть без парольной фразы или с парольной фразой, если сеанс ssh-agent уже запущен и ключ добавлен в него.

Система сборки использует предоставленный приватный ключ для аутентификации пользователя в сервисе, поддерживающем такой механизм обмена (например, внутренние корпоративные сервисы). В результате успешной аутентификации система получает OAuth токен, который далее используется для авторизации доступа к защищенным ресурсам во время сборки.

Полученный OAuth токен далее используется системой сборки для получения доступа к ресурсам, необходимым для сборки проекта. Это могут быть зависимости, хранящиеся в приватных репозиториях, доступ к API, требующим аутентификации и т.д.

Пример использования

`ya make --key=/home/user/.ssh/id_rsa`

Где `/home/user/.ssh/id_rsa` - путь к приватному ключу пользователя на его машине.

Использование опции `--key=SSH_KEYS` является удобным способом автоматизации процессов аутентификации и авторизации в системе сборки без необходимости явного указания учетных данных или токенов доступа.

* Опция `--token=OAUTH_TOKEN` используется для аутентификации и авторизации пользователя через механизм OAuth. Это позволяет системе сборки получать доступ к ресурсам, которые требуют проверки прав доступа пользователя, например, к приватным репозиториям с исходным кодом или зависимостями проекта, доступ к API, требующим аутентификации, и другим защищенным ресурсам.

Пользователю необходимо заранее получить OAuth токен у провайдера аутентификации, который поддерживается сервисами или ресурсами, к которым требуется доступ в процессе сборки.

При запуске сборки через `ya make`, пользователь указывает полученный OAuth токен в качестве аргумента командной строки, используя опцию `--token=ВАШ_ТОКЕН`. Система сборки использует этот токен для выполнения аутентификации при обращениях к внешним ресурсам.

Во время сборки, на этапах, когда требуется доступ к защищенным ресурсам (например, клонирование приватного репозитория из git), система сборки предоставляет OAuth токен, который используется для аутентификации и авторизации запросов, тем самым предоставляя доступ к необходимым данным.

* Опция `--user=USERNAME` предназначена для указания имени пользователя, под которым будет осуществляться авторизация при доступе к ресурсам, требующим аутентификации. Это может быть необходимо, например, при доступе к приватным репозиториям, защищенным API, или другим ресурсам, доступ к которым регулируется на основе учетных данных пользователя.

В процессе сборки проекта система `ya make` может столкнуться с необходимостью выполнения действий, для которых требуется аутентификация. Примерами таких действий могут быть: загрузка зависимостей из приватных репозиториев, обращение к внешним сервисам или API, которые используют механизмы аутентификации для подтверждения прав доступа.

Использование `--user=USERNAME` позволяет явно задать системе сборки имя пользователя для таких случаев. Это имя пользователя будет использоваться при аутентификации на соответствующих сервисах вместе с другими переданными учетными данными (например, паролем или токеном).

Чтобы процесс аутентификации был полным, кроме указания пользователя, может потребоваться передать дополнительные параметры, такие как пароль или токен. Для этого могут использоваться ключи `--password=PASSWORD` или `--token=OAUTH_TOKEN`. Вместе эти параметры образуют полный набор учетных данных для доступа к требуемым ресурсам.
