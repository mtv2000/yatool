## ya make: основной сборочный инструмент

Это команда для автоматизации сборки проектов, включая компиляцию кода, запуск тестов и создание исполняемых файлов.

Цель сборки в системе `ya make` — это программа или библиотека, которую нужно собрать.  
Цель сборки имеет двоякое значение:
1. Артефакт — результат сборки, например, файл программы или библиотеки.
2. Описание сборки — файл `ya.make`, содержащий инструкции по сборке.

Не каждая цель сборки создает артефакт. 
Некоторые цели устанавливают зависимости или внедряют сборочные флаги.

Цель сборки указывается директорией, содержащей файл `ya.make`.   
Файл `ya.make` [описывает](#Настройки-сборки), что и как будет собрано и какие цели нужно собрать.    
[Результаты сборки](#Результаты-сборки) по умолчанию размещаются в директориях целей как символьные ссылки.

Правило системы `ya make`:

**Одна директория — одна цель сборки**.

В каждой директории есть только один файл `ya.make`, описывающий сборку одного модуля.

Общая форма команды

`ya make [OPTIONS]… [TARGET]…`

- `[OPTIONS]…` — опции для изменения поведения сборки или тестирования. 
- `[TARGET]…` — цели сборки.
При отсутствии явно указанной цели, `ya make` собирает цель из текущей директории.

`ya make` с помощью опций позволяет гибко настраивать параметры сборки:

- [Настройки сборки](#Настройки-сборки) — выбор дополнительных [результатов сборки](#Результаты-сборки).
- [Тип и вид сборки](#Тип-и-вид-сборки) — debug/release, LTO, sanitizers и другие.
- [Платформенные параметры](#Платформенные-параметры) — целевые аппаратная платформа и OS, настройки сборочной платформы.
- [Сборочные переменные](#Сборочные-переменные) — например, `-DCFLAGS=-Wall`, `-DDEBUGINFO_LINES_ONLY`.
- [Работа с тестами](#Работа-с-тестами) - запуск и работа с тестами. 

Опции также делятся по типам:
1. Основные
2. Расширенные
3. Экспертные

Для получения справки по команде `ya make` используйте:
- `ya make -h`, `--help` — печатает справку.
- `ya make -hh` — для полного списка опций.
- `ya make -hhh` — для вывода списка опций, которые в том числе используются в конкретных сценариях.

### Настройки сборки

Система сборки призвана превратить исходные файлы на различных языках по строгим правилам в библиотеки, программы и тесты ([результаты сборки](#Результаты-сборки)), а также [запускать тесты](#Работа-с-тестами) по запросу.

Желательно, чтобы пересборка была минимальной и затрагивала только изменённые компоненты.

Для достижения этого цели в системе сборки должны быть:
- [Описаны правила превращения исходных файлов в результаты.](#Описание-макросов-для-модуля)
- [Определены зависимости для минимизации пересборок.](#Строгий-контроль-зависимостей)
- [Описаны сборочные свойства для согласованности сборки целей и их зависимостей.](#Описание-параметров-сборки-модулей-и-программ)
- Указаны дополнительные свойства, такие как владелец кода и лицензия.

#### Как описывается сборка на ya.make 

Описание сборки в `ya.make` модульное.

Каждый `ya.make` файл описывает сборку не более чем одного модуля.

Модуль может быть библиотекой, программой, тестом или группой целей (модули `PACKAGE` и `UNION`).

Иногда логический модуль может быть реализован в нескольких вариантах, что называется мультимодулем.

Примеры мультимодулей: `PY23_LIBRARY` и `PROTO_LIBRARY`

Структура описания является декларативной, что означает, что указывается необходимая информация для сборки, а не последовательность действий.

**Ключевые характеристики:**
- Использование переменных и условных операторов для детализации процесса сборки.
- Автоматическое определение некоторых зависимостей на основе расширений файлов.
- Каждый `ya.make` файл уникален для своей директории и описывает сборку одного модуля.

#### Описание макросов для модуля

Настройка сборки начинается с определения ключевых параметров модуля через специальные команды, которые называются макросами и выглядят как вызовы функций с параметрами.

Система сборки `ya make` предоставляет огромное количество макросов для различных языков и применений.

Макросы в модуле можно условно подразделить на три категории:

1. Управляющие макросы:
Управляющие или условные макросы, такие как `INCLUDE`, `EXCLUDE_TAGS`, `ONLY_TAGS`, а также макросы типа `IF()`, `ELSEIF()`, `ELSE()`, `ENDIF()`, влияют на то, как интерпретируется файл `ya.make`.  
Эти макросы позволяют настроить различную сборку на основе значений переменных, которые могут быть заданы локально (с помощью макроса `SET()`) или глобально, для определения конфигурации сборки данного модуля.
Например, глобальные переменные могут включать `OS_WINDOWS` при сборке для `Windows` или `PYTHON3` в соответствующих случаях мультимодуля.

2. Макросы, задающие свойства
Эти макросы могут напрямую влиять на встроенные свойства.
Например, `PEERDIR` задаёт зависимости для модуля, `SRCDIR` или `ADDINCL` указывают пути для поиска имён.
Макрос `PY_NAMESPACE` определяет пространства имён для импорта файлов, описанных в модуле.

Они также могут формировать значения переменных, использующихся в других макросах или командах модуля. 
Например, `CFLAGS` устанавливает флаги для команд компиляции `C/C++` файлов. 
Макрос `SET(VAR VALUE)` задаёт значение переменной: если переменная присутствует в глобальной конфигурации, её значение изменится для данного модуля, если нет - переменная появится и будет доступна в контексте модуля для последующих макросов.

3. Макросы, описывающие команды
Такие макросы задают команды, которые будут выполнены в процессе сборки.
Они формируют команды, интегрируя их в граф сборки модуля путем связывания своих результатов с входами других команд (потребителей) и, возможно, своих входов с результатами других команд (источников).  
К примеру, макрос `COMPILE_LUA` создаёт команду, компилирующую код на `Lua` в представление, пригодное для `LuaJit`.  
Результат этой команды будет ассоциирован с другими командами модуля (например, упаковка в библиотеку), а впоследствии библиотека будет связана по зависимостям с финальной программой.

Начальный `ya.make` для списка проектов содержит список директорий в макросе `RECURSE`:

```bash
RECURSE(
commie
core
lib
solver
ut
)
```
Большинство макросов не требуют явного указания команд для сборки.  
Команды — это скрытые свойства макросов, которые меняются в зависимости от параметров конфигурации и описываются уровнем ниже (на языке `core.conf`).  
В макросах указываются только аргументы для этих команд.  

Макросы, такие как `SRCS`, могут сами определить команды для сборки по расширению файла.  

#### Описание параметров сборки модулей и программ

В типичном файле `ya.make` можно указать:
- Владельца модуля (`SUBSCRIBER`) – обычно это имя пользователя или группа, ответственные за модуль.
- Тип сборки (`PROGRAM`, `LIBRARY`, `PY3_LIBRARY` и т.д.) – указывает, является ли модуль исполняемым файлом, библиотекой или чем-то иным.
- Источники (`SRCS`) – перечень файлов исходного кода, которые следует скомпилировать.
- Зависимости (`PEERDIR`, `DEPENDS`) – другие модули или программы, от которых зависит текущий модуль.
- Параметры и флаги компиляции (`CFLAGS`, `LDFLAGS` и др.) для настройки процесса сборки.
- `END()` - Сигнализирует о конце блока настроек для модуля.

В дополнение к макросам используются комментарии, которые начинаются символом `#` и продолжаются до конца строки.

**Пример базового файла `ya.make`:**
```bash
SUBSCRIBER(username) # Макрос, указывающий владельца модуля
PROGRAM() # Макрос типа модуля: программа (на C++)
PEERDIR( # Макрос зависимостей модуля
util/draft
)
SRCS( # Макрос исходных файлов модуля
main.cpp
)
END() # Закрывающий макрос модуля
RECURSE_FOR_TESTS(test) # Макрос связи - компиляция и запуск тестов из поддиректории test
```
#### Строгий контроль зависимостей
Для управления зависимостями между различными компонентами проекта в файлах `ya.make` используются макросы `PEERDIR` и `DEPENDS`.

Макрос `PEERDIR` указывает на другие модули внутри проекта, необходимые для сборки текущего модуля, обеспечивая правильное разрешение локальных зависимостей.   
`DEPENDS` указывает зависимости на другие проекты, которые нужно собрать и результаты которых должны быть доступны тесту.  
В параметрах перечисляются относительные пути от корня репозитория.

Контроль зависимостей осуществляется на этапе конфигурирования: этот этап анализирует зависимости команд и присваивает всем необходимым файлам уникальные идентификаторы (UID).

#### Описание макросов ya.make для тестов

Для тестов используются специальные макросы в `ya.make`, которые помогают организовать тестирование модулей:

- `RECURSE_FOR_TESTS()`: Указывает, что следует также собрать тесты, находящиеся в указанной директории.
- `DEPENDS()`: Зависимости теста от других модулей или библиотек, которые должны быть собраны для его выполнения.
- `FORK_TESTS()`, `FORK_SUBTESTS()`: Параллельный запуск тестов.
- `USE_RECIPE()`:  Подключает рецепт для настройки тестового окружения к тесту. Если тест описан с использованием макросов `FORK_TEST()` / `FORK_SUBTESTS()`, то рецепт будет подготавливать отдельное окружение для каждого запуска.
- SKIP_TEST(Reason): Отключает все тесты в модульной сборке. Параметр Reason указывает причину отключения.

####   Описание параметров тестирования

Параметры тестирования определяют, как будут выполняться тесты:
- Параметры командной строки, которые могут быть переданы в процесс тестирования (`--test-param`)
- Определение временных ограничений на выполнение тестов (`TIMEOUT()`)
- Установка переменных окружения, специфичных для тестов (`ENV()`)
- Конфигурации специальных режимов выполнения тестов, например, под разные операционные системы или архитектуры.(`REQUIREMENTS()`)

### Результаты Сборки

По умолчанию целями сборки являются модули, непосредственно указанные в `ya.make`, а также рекурсивно во всех макросах `RECURSE`, доступных из `ya.make`.

Это поведение может быть изменено следующими опциями:
- `--target/-C` — цели сборки и параметры среды.
- `-t`, `-A` — запуск тестов.
- `--force-build-depends` — включить сборку всех зависимостей для тестов.
- `-DTRAVERSE_RECURSE_FOR_TESTS` — трактовать `RECURSE_FOR_TESTS` как обычный `RECURSE`.
- `--ignore-recurses` — игнорировать `RECURSE`, выполнять только указанные цели.
- `-o`, `--output <path>` — директория для хранения результатов.
- `--no-src-links` — отключение символических ссылок.
- `--keep-temps` — сохранить файлы в сборочных директориях.

Для расширения набора результатов сборки, можно использовать опцию `--add-result=.<suff>`.
В конфигурационном файле `ya.conf`можно задать `add_result = [".suff"]`. 
```bash
ya make -o=<output> <target> --add-result=.o --add-result=.obj
```
Складывает объектные файлы в директорию <output> и (на Linux и MacOS) создает ссылки на файлы из кэша результатов в директории с исходниками.

Дополнительные Опции:
  - `--add-protobuf-result` — Добавить все результаты генерации для `Protobuf`.
  - `--add-flatbuf-result` — Добавить результаты генерации `Flatbuffers`.
  - `--add-modules-to-results` — Сделать все модули (включая зависимые по `PEERDIR`) результатами сборки.
  - `--add-host-result=.<suff>` — Добавить выбранные результаты из сборочной платформы.
  - `--all-outputs-to-result` — Не фильтровать результаты команд.
  - Обычно `--add-result` фильтрует результаты команд по расширениям, с помощью этой опции можно запросить все результаты для команд, подходящих под `--add-result`.

Примеры:
  - `ya make --add-result=.pb.h` - результат только файлы `.pb.h`
  - `ya make --add-result=.pb.h --all-outputs-to-result` - результат как `.pb.h`, так и `.pb.cc`. 

Иногда хочется построить только генерируемые файлы, но не библиотеки/программы.  
Для этого служит опция `--replace-result`.  
Она оставит в результатах сборки только то, что выбрано в `--add-result`, все остальное будет удалено и не будет строиться совсем.

Множество отображаемых результатов можно ограничить с помощью:
  - `--no-output-for=.<suff>` — Ограничить множество отображаемых результатов.
  - `suppress_outputs = [".suff"]` — Параметр конфигурационного файла.

Эти опции не исключают файлы из сборки, они лишь говорят системе сборки, что результаты не надо складывать в рабочую копию и выходную директорию.  
Опция `--no-output-for` не взаимодействует с `--replace-result`.  
Файлы, исключенные из результатов, все равно будут построены и останутся в кэше.

### Тип и вид сборки
На данный момент `ya make` поддерживает только локальную сборку.
В будущем планируется добавить распределенную сборку, для чего зарезервирована опция `--dist`.

По умолчанию код собирается в конфигурации `Debug` — без оптимизаций,с отладочной информацией и `assert`. 

Для типов сборок доступны следующие варианты:

- `-d`, `--debug`  
Активирует сборку в режиме отладки.
Включает отладочную информацию в исполняемые файлы и снижает уровень оптимизации.
- `-r`, `--release`  
Инициирует сборку в режиме релиза.
Оптимизирует исполняемый код для максимальной производительности в том числе удаляя отладочную информацию.
- `-v`, `--verbose`  
Включает подробный режим вывода. Предоставляет дополнительную информацию о процессе сборки.
- `--rebuild`  
Указывает игнорировать результаты предыдущих сборок и начать процесс заново.
- `--build=BUILD_TYPE` - Указать тип сборки (debug, release, profile, gprof, valgrind, valgrind-release, coverage, relwithdebinfo, minsizerel, debugnoasserts, fastdebug)

Полный актуальный список вариантов сборки можно посмотреть, выполнив:
```bash
ya make --help | grep 'Build type`
```
или 

```bash
ya make --build help
```
Кроме параметра `--build` есть ещё ряд флагов, влияющих на тип сборки:
* `--lto/--thinlto` - сборка с глобальными оптимизациями (оптимизациями во время линковки, `LTO`) для C++;
* `--sanitize <sanitizer>` - сборка с санитайзером для С++;
* `--race` - сборка с race detector для Go.
* `--hardening` - сборка с более строгими проверками в коде
* `--musl` - сборка C/С++ c MUSL вместо `glibc`
* `--cuda=<optional|required|disabled>` - сборка с `CUDA`

Локальная сборка использует следующие ключи для настройки директорий:

- `-S=CUSTOM_SOURCE_ROOT`, `--source-root=CUSTOM_SOURCE_ROOT` — путь к проекту, из которого будет произведён поиск корня репозитория. По умолчанию это текущий рабочий каталог, где запущена команда ya make.
- `-B=CUSTOM_BUILD_DIRECTORY`, `--build-dir=CUSTOM_BUILD_DIRECTORY` — корень для сборочных директорий.
Здесь исполняются команды сборки. По умолчанию директории находятся в `~/.ya/build/`.

Директории для результатов сборки настраиваются следующими параметрами:
- `-o=OUTPUT_ROOT`, `--output=OUTPUT_ROOT` — путь для результатов сборки (на `Linux` и `macOS` используются хардлинки).
Результаты размещаются по указанному пути.

Можно указать, куда записывать логи сборки и событий:
- `--log-file=LOG_FILE` — добавляет подробный лог в указанный файл.
По умолчанию на каждую сборку создается свой лог в `~/.ya/logs/<date>/<time>.log`.
- `--evlog-file=EVLOG_FILE` — записывает лог событий в указанный файл.
По умолчанию на каждую сборку создается свой лог в `~/.ya/evlogs/<date>/<time>.evlog.zst`.

Локальная сборка поддерживает режим **контентных UIDов**
В этом режиме сборка не перезапускает сборку ноды, если результаты выполенения её зависимостей не изменились.

Режим отключается опцией `--no-content-uids` или настройкой `content_uids = false` в `ya.conf`.

Чтобы увидеть использование контентных UIDов, воспользуйтесь опцией `--stat`:
```bash
[=] ya make path/test/content_uids_cache/simple/original --stat
Cache hit ratio is 71.43% (5 of 7). Local: 2 (28.57%), dist: 0 (0.00%), >>> by dynamic uids: 3 (42.86%) <<<
[CC-DYN_UID_CACHE] - 6 ms. <<<
[LD-DYN_UID_CACHE] - 2 ms. <<<
```

#### Отображение статуса сборки

Для вывода статуса сборки используется стиль `ninja`.
Прогресс отображается одной строкой, и показывает статус одной команды, со сведениями о других командах в конце строки (+X more).

Изменить вывод статуса на построчный можно опцией `-T`.  
Этот же режим включается при перенаправлении вывода команды `ya make` в файл.

Вывод команды `ya make` можно расширить следующими опциями:
  * `-v`, `--verbose` — выводить текст исполнившихся сборочных команд
  * `--do-not-output-stderrs` — не выводить stderr команд
  * `--show-timings` — выводить времена исполнения команд в статус, работает только с опцией `-T`
  * `--show-extra-progress` — выводить расширенный прогресс (количество исполненных команд) в статус. Работает только с `-T`
  * `--cache-stat` — перед сборкой выдать статистику по наполнению локального кэша
  * `--stat` — в конце сборки выдать статистику по сборке. Статистика включает использование кэшей, критический путь, самые долгие сборочные шаги и т.п.

### Платформенные параметры

Платформа включает в себя триплет из компилятора, операционной системы и архитектуры процессора.
Например, `<clang11, Windows, x86_64>` или `<clang10, Android, armv8a>`.

По умолчанию в качестве целевой и сборочной платформы выбирается та, на которой запущена сборка. 
То есть операционная система будет соответствовать той, на которой вы работаете (например, `Linux, Darwin (macOS)` или `Windows`), архитектура будет `x86_64` или `arm64` (для Mac с процессором M1), а компилятор будет выбран по умолчанию (`default`) для данной операционной системы.

Чтобы изменить целевую платформу, используйте флаг `--target-platform`. 
Укажите тройку в формате `<компилятор-OS-архитектура>`, соединяя значения дефисами. 
Вы также можете указать только часть этой тройки, и недостающие компоненты будут автоматически заполнены значениями по умолчанию.
Для выбора компилятора по умолчанию используйте значение `DEFAULT`.

Примеры:
- `--target-platform clang-win-x86_64` — сборка для Windows на процессоре x86_64 с использованием компилятора Clang.
- `--target-platform default-android-armv8a` — сборка для Android на ARM в версии armv8a с компилятором по умолчанию.
- `--target-platform windows` — сборка для Windows на архитектуре x86-64 с компилятором по умолчанию.

### Сборочные переменные

В команде `ya make` можно указать дополнительные флаги (переменные) с помощью опции `-DVAR[=VALUE]`.
Если не указывать значение переменной, по умолчанию оно будет выставлено в `yes`.

Можно определить:
- Предопределённые переменные, позволяющие передать флаги для сборки 
`ya make -DLDFLAGS="-fblabla=foo -fbar"`, `ya make -DCFLAGS="-DNN_DOUBLE_PRECISION -Wno-strict-aliasing"`.
- Предопределённые переменные, управляющие конфигурацией, например `ya make -DCATBOOST_OPENSOURCE` (сборка как для `open source`) или `ya make -DCUDA_VERSION=10.1` (сборка с `CUDA`).
- Переменные для использования в `ya.make` `ya make -DMAKE_VAR1 -DMAKE_VAR2=42`, где в `ya.make` написано, например `IF (MAKE_VAR1)`.

### Работа с тестами 

По умолчанию локально результаты тестов не кэширутся.

На данный момент локальный запуск тестов учитывает таймауты в соответствии с размером (1 минута для SMALL, 10 минут для MEDIUM, час для LARGE).

По умолчанию, локальная сборка производится в конфигурации `debug`. Для автоматического тестирования можно выбрать режим `relwithdebinfo` — релизная сборка с отладочной информацией.

Результаты тестов локально складываются в директорию `test-results`, которая появляется символьной ссылкой в рабочей копии в директории теста (кроме Windows или при использовании флага `--no-src-links`).

Внутри находится директория `<suittype>/testing_out_stuff` в которой находятся логи тестов и прочие файлы, которые порождают тесты. 

Если тесты не прошли успешно, в консоль может быть выведена информация о путях в реальных директориях внутри сборочного каталога, где выполнялись тесты.  
Чтобы сохранить эти данные после завершения тестов, сборочные директории не очищаются сразу, а только при следующем запуске сборки.  
Таким образом, данные в этих каталогах доступны до следующей сборки или запуска тестов.  
Если вам необходимо сохранить эти данные, скопируйте их заранее.

#### Запуск тестов (-t, -tt, -ttt, -A)
- `-t`: Эта базовая опция запускает все тесты, отмеченные как “маленькие” (SMALL). Это быстрые тесты, обычно требующие мало ресурсов и времени для выполнения.
- `-tt`: Расширение базовой опции `-t`, которое включает в себя запуск тестов как “маленьких”, так и “средних” (MEDIUM) размеров. Средние тесты обычно занимают больше времени и ресурсов.
- `-ttt`: Данная опция запускает тесты всех размеров, включая “большие” (LARGE). Большие тесты часто включают в себя интеграционные и нагрузочные тесты, требующие значительного времени для выполнения и могут включать внешние зависимости.
- `-A, --run-all-tests`: Аналогично `-ttt`, запускает все тесты независимо от размера.

#### Управление выводом результатов
- `-L, --list-tests`: Выводит список тестов, которые будут выполнены, без их фактического запуска. Помогает разработчикам быстро проверить, какие тесты включены в план тестирования.
- `–-fail-fast`: Прекращает выполнение тестового прогона сразу после первой встреченной неудачи. Эта опция полезна для экономии времени и ресурсов, особенно когда разработчики ищут конкретную ошибку.

#### Выборочное тестирование
- `–-test-filter=TESTS_FILTERS`: Эта опция позволяет ограничить тестирование только определенными тестами, соответствующими указанным фильтрам. Это может быть имя теста, его часть или другой идентифицирующий шаблон.
- `-–test-tag=TEST_TAGS_FILTER`: Позволяет запускать только те тесты, которые помечены определенными тегами. Теги — это пользовательские метки, которые могут быть нанесены на тесты для их группировки по определенным признакам или функциональности.
- `–-test-size=TEST_SIZE_FILTERS`: Фильтр для запуска тестов определенного размера (SMALL, MEDIUM, LARGE), позволяющий более точно настроить объем запускаемых тестов в зависимости от текущих потребностей.
- `–-test-type=TEST_TYPE_FILTERS`: Ограничивает запуск только теми тестами, которые относятся к указанным типам (например, `UNITTEST`, `PYTEST`). Удобно при необходимости проведения специфичных видов тестирования.

### Сообщения об ошибках

`ya make` предоставляет подробные сообщения об ошибках и предупреждениях на этапе конфигурации (анализ `ya.make` файлов, построение графа зависимостей). Эти сообщения могут включать информацию о недостающих файлах, циклических зависимостях, проблемах в конфигурации и многом другом. 
 
  * Конфигурационные ошибки (`BadAuto`, `BadDir`, и т.д.): Эти ошибки свидетельствуют о проблемах в настройках сборки, например, неправильно указанных директориях или файлах. Убедитесь, что все пути указаны корректно, и что ваши конфигурации соответствуют требованиям вашего проекта.
  * Ошибки зависимостей (`DEPENDENCY_MANAGEMENT`, `DupSrc`): Такие ошибки указывают на проблемы с управлением зависимостями, включая дублирование источников или некорректное управление зависимыми модулями. Для решения таких проблем проверьте объявления ваших зависимостей в файлах `ya.make` и устраните дубликаты или некорректные ссылки.
  * Синтаксические ошибки (`Syntax`): Ошибки синтаксиса часто возникают из-за неверного использования макросов или опечаток в файлах `ya.make`. Внимательно проверьте синтаксис ваших конфигурационных файлов на соответствие документации `ya make`.
  * Пользовательские ошибки (`UserErr`, `UserWarn`): Эти сообщения генерируются непосредственно из `ya.make` файлов, описанными пользователями в макросах `MESSAGE(FATAL_ERROR msg)`, и обычно проверяют некоторую логику описания сборки.

### Популярные рецепты

* `ya make -r` - собрать код c оптимизациями и отладочной информацией 
* `ya make -v` - собрать в verbose-режиме.  **Обратите внимание:** `ya -v make` и `ya make -v` имеют разный эффект. Первая добавляет вывод утилиты `ya`, вторая — сборки.
* `ya make -T` - переключиться на построчный вывод информации на экран
* `ya make --add-result=".h" --add-result=".cpp"` - собрать, добавив в результаты сгенерированные в процессе сборки cpp- и h-файлы.
* `ya make --add-result=".pb.h" --add-result=".pb.cc" --replace-result`- запустить только кодогенерацию протобуфов.
* `ya make -t`  - запустить только быстрые тесты
* `ya make -tL` - вывести список быстрых тестов
* `ya make -A`  - запустить все тесты
