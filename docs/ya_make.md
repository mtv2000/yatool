# ya make: основной сборочный инструмент

Команда утилиты `ya`, которая позволяет  компилировать код, управлять зависимостями, запускать тесты и генерировать исполняемые файлы в едином и согласованном окружении независимо от сложности проекта.

## Основные преимущества и возможности

- Универсальность и гибкость: `ya make` поддерживает широкий спектр языков программирования и технологий, что делает его подходящим для работы с мультитехнологичными проектами. Он может быть использован для сборки проектов на таких языках, как C++, Python, Java, Go, и многих других, предоставляя разработчикам удобный способ управления сборкой в разнообразных разработческих экосистемах.
- Автоматизация сборки: Одной из ключевых особенностей `ya make` является его способность автоматически обрабатывать сложные системы зависимостей в проекте, обеспечивая точную и эффективную автоматическую сборку программных компонентов. Основываясь на конфигурациях, определенных в файлах `ya.make`, команда `ya make` автоматически разрешает зависимости и выполняет необходимые шаги для подготовки окончательной сборки проекта.
- Настройка параметров сборки: `ya make` предоставляет возможности по настройке процесса сборки, позволяя разработчикам выбирать между различными режимами сборки (например, debug или release), а также настраивать параметры компиляции, линковки и оптимизации кода для достижения наилучших результатов производительности и размера исполняемого файла.
- Расширенное тестирование: Инструмент  обеспечивает запуск широкого спектра тестов, включая модульные тесты, интеграционные тесты, тесты производительности и другие, с поддержкой настройки параметров запуска тестов для максимальной гибкости процесса верификации качества кода.
- Поддержка локальной и распределенной сборки: Позволяет выполнять сборку как на локальной машине разработчика, так и использовать распределенные ресурсы для ускорения процесса сборки.

`ya make` позволяет очень гибко настраивать параметры сборки. Список настраиваемых возможностей включает:

- Выбор типа и вида сборки](ссылка) — debug/release, LTO, sanitizers и т. п.
- Параметры платформ](ссылка) — целевые аппаратная платформа и OS, настройки сборочной платформы и т. п.
- Установку сборочных переменных](ссылка) — Например, `-DCFLAGS=-Wall`, `-DDEBUGINFO_LINES_ONLY` и т. п.
- Настройки сборки](ссылка) - выбор дополнительных результатов сборки и т. п.
- Запуск и работу с тестами](ссылка)

## Базовая настройка

Для начала работы с ya make, выполните следующие шаги:

1. Ознакомтесь с возможностями сборки: `ya make  -h, --help`  печатает справку . Используйте `-hh` для большего количества опций и `-hhh` для ещё большего. С описанием всех функций можно ознакомится по [ссылке](helpfilemake.md)

2. Ознакомтесь с файлами ya.make: Изучите структуру и содержание файлов ya.make в вашем проекте. Эти файлы содержат инструкции о том, как компоненты проекта должны быть скомпилированы, какие зависимости они имеют и какие тесты необходимо выполнить.

3. Простая сборка проекта: Попробуйте выполнить сборку вашего проекта, используя команду `ya make` без дополнительных параметров в корневой директории проекта. Это позволит убедиться, что ваша система настроена правильно и `ya make может` успешно выполнить сборку. (ссылка на примеры)

4. Настройка среды разработки: Настройте вашу интегрированную среду разработки (IDE) или текстовый редактор для работы с `ya make`, если это поддерживается. Это может включать настройку путей к инструментам, конфигураций сборки и запуска тестов.(ссылка на ide)

### Синтаксис

Основная форма команды ya make представляет собой командную строку, в которую включаются различные опции и цели для сборки или тестирования проекта. Её строение обеспечивает гибкость и возможность точной настройки процесса.

#### Общая форма команды

`ya make [OPTIONS]… [TARGET]…`

`[OPTIONS]` обозначает одну или несколько опций команды, предназначенных для изменения поведения сборки или тестирования. Опции могут управлять такими параметрами, как тип сборки (например, отладочный или релиз), применение оптимизации, использование инструментов анализа кода и многое другое.

`[TARGET]…` указывает на одну или несколько целей сборки. Целью может быть конкретный модуль в проекте, директория, содержащая компоненты для сборки, или специально заданный аргумент, определяющий действие (например, запуск тестов). Если цель не указана, ya make обычно выполняет сборку всего проекта, начиная с текущего каталога.

#### Основные опции

* `-d, --debug`
Опция `-d` или `--debug` активирует сборку в режиме отладки. В этом режиме компилятор включает отладочную информацию в генерируемые исполняемые файлы и снижает уровень оптимизации кода, что делает процесс отладки приложения более удобным и эффективным за счет улучшенной интерпретации и отслеживания ошибок.

* `-r, --release`
Использование флага `-r` или `--release` инициирует сборку проекта в режиме релиза. В этом режиме команда сосредоточена на оптимизации исполняемого кода для достижения максимальной производительности приложения, часто за счет размера выпускной версии и отсутствия отладочной информации.

* `--dist`
Опция `--dist` включает распределенную сборку, позволяя использовать вычислительные мощности сборочных кластеров для параллельной обработки задач. Это значительно ускоряет процесс сборки для крупных проектов с большим количеством зависимостей.

* `-v, --verbose`
Флаг `-v` или `--verbose` инициирует подробный режим вывода, благодаря которому становится доступной дополнительная информация о процессе сборки. Подробный вывод может быть полезен для диагностики и устранения проблем, связанных со сборкой проекта.

* `--rebuild`
Опция `--rebuild` указывает команде `ya make` игнорировать результаты предыдущих сборок и начать процесс сборки с нуля. Это может быть полезно в случаях, когда кэшированные результаты повреждены или когда требуется полная пересборка проекта для устранения несоответствий.

#### Специфические аргументы для отдельных опций

Некоторые опции `ya make` поддерживают специфические аргументы, которые позволяют дополнительно настроить поведение сборки. Например, опция `--sanitize` принимает аргументы, указывающие тип санитайзера (например, address, thread, memory), что позволяет внедрять различные инструменты анализа на этапе сборки для обнаружения ошибок в коде.

Подробно про специфические аргументы (ссылка)

### Опции сборки

Настройки сборки в ya make позволяют детально управлять процессом сборки проекта, оптимизировать его для разных сценариев использования и достичь требуемого баланса между скоростью сборки и требованиями к качеству исходного кода. 

Основные опции:

- `-d, --debug`: Эта опция указывает инструменту собирать проект в режиме отладки. Компиляция в этом режиме включает дополнительную отладочную информацию и обычно снижает уровень оптимизации кода для облегчения процесса отладки. Это облегчает разработчикам задачу поиска и устранения ошибок.

- `-r, --release`: При выборе этой опции ya make производит сборку в режиме релиза, который нацелен на оптимизацию производительности исполняемого файла и его размер. В этом режиме отладочная информация обычно исключается, что делает отладку сложнее, но повышает скорость выполнения программы.

#### Локальная сборка

Локальная сборка — это процесс сборки проекта, выполняемый непосредственно на машине разработчика. Эта опция идеально подходит для небольших проектов или в ситуациях, когда необходима быстрая итерация в процессе разработки.

Особенности и настройки: Для управления локальной сборкой `ya make` предоставляет ряд настроек, таких как выбор режима сборки (`-d` для отладки, `-r` для релиза), настройка компилятора и его флагов, а также многие другие опции, влияющие на процесс сборки.

Рекомендации по оптимизации: Для оптимизации локальной сборки стоит использовать инкрементную сборку, активировать кэширование результатов и минимизировать количество модулей, пересобираемых при каждом изменении кода.

Подробно про локальную сборку(ссылка)

#### Распределенная сборка

Распределенная сборка — это процесс, при котором задачи сборки распределяются между несколькими машинами (сборочными агентами), что позволяет значительно ускорить компиляцию проекта большого размера за счет параллельной обработки.

- Как настроить и использовать распределенную сборку: Настройка распределенной сборки часто требует конфигурации сборочного сервера и агентов, а также указания в `ya make` опции `--dist`, которая активизирует режим распределенной сборки.

- Управление ресурсами и кэширование: Эффективное использование распределенной сборки включает в себя управление доступностью ресурсов для сборочных агентов, а также настройку кэширования результатов сборки для минимизации повторной компиляции уже обработанных модулей.

Подробно про распределенную сборку(ссылка)

#### Типы сборок 

Полный актуальный список вариантов сборки можно посмотреть, выполнив `ya make --help | grep 'Build type'` или `ya make --build help`. 

- `--build relwithdebinfo` - Релизная сборка с включенными ассёртами для C++. Используется для основных проверок в CI поскольку debug слишком медленно, а ассёрты дают больше полезной информации.
- `--build minsizerel` - Сборка с оптимизацией по размеру бинарного кода (для C++ уровень оптимизаций `-Oz` или `-Os` в зависимости от компилятора)
- `--build debugnoasserts` - Сборка без оптимизаций, но с выключенными ассёртами.
- `--build fastdebug` - Более производительная отладочная сборка, включает некоторые оптимизации (для C++ уровень оптимизаций `-Og`).
- `--build profile` - Релизная сборка, упрощающая профилировку — для C++ добавляет `-fno-omit-frame-pointer`.
- `--build valgrind`/`--build valgrind-release` - Инструментированная сборка для профилирования памяти с помощью valgrind.
- `--build coverage` - Сборка с инструментированием для подсчёта покрытия кода.

  Кроме параметра `--build` есть ещё ряд флагов, влияющих на тип сборки:

- `--lto`/`--thinlto` - сборка с глобальными оптимизациями (оптимизациями во время линковки, LTO) для C++;
- `--sanitize <sanitizer>` - сборка с санитайзером для С++;
- `--race` - сборка с race detector для Go.
- `--hardening` - сборка с более строгими проверками в коде
- `--musl` - сборка C/С++ c MUSL вместо glibc
- `--cuda=<optional|required|disabled>` - сборка с CUDA

Актуальная информация по типам сборки(ссылка) 

#### Сборка с профилировкой

С помощью `ya make` можно собирать проекты с использованием  [Profile-guided optimization](https://ru.wikipedia.org/wiki/Profile-guided_optimization).

Подробно cборку с профилировкой(ссылка)

### Опции оптимизации

- `–optimize [LEVEL]`: Опция дает возможность настроить уровень оптимизации кода. `[LEVEL]` может варьироваться от минимальной оптимизации (-O0 для GCC и Clang), предназначенной для максимального ускорения процесса компиляции, до максимальной оптимизации (-O3 или кастомные уровни как -Ofast), что делает скомпилированный код как можно более эффективным.

- `–lto, --thinlto`: Включение Link Time Optimization (LTO) и Thin Link Time Optimization (ThinLTO), соответственно. Эти опции оптимизации производятся на этапе линковки и могут значительно повысить производительность за счет анализа и оптимизации межмодульных взаимодействий.

#### Выбор компилятора

- `–compiler [COMPILER_NAME]`: Указание конкретного компилятора для сборки проекта. `[COMPILER_NAME]` может быть задано для использования специфического компилятора (например, gcc, clang, msvc) в случае, если проект имеет особые требования к компиляции.

#### Работа с предупреждениями компилятора

- `–warnings-as-errors`: Превращение всех предупреждений компилятора в ошибки. Эта строгая настройка помогает обеспечить высокий уровень качества кода, не допуская пропуска потенциальных проблем.

#### Кросс-компиляция

-`–target [PLATFORM]`: Опция позволяет указать целевую платформу для сборки. Это особенно актуально для кросс-компиляции, когда исходный код, написанный и скомпилированный на одной платформе (например, x86_64), предназначается для выполнения на другой (например, arm, aarch64).

При сборке кода под платформой обычно понимают аппаратную платформу (CPU, набор машинных инструкций, которые должны быть использованы в бинарном коде), операционную систему, на который должна работать программа, и программные средства, которые должны быть использованы для сборки (компилятор и т. п.).
Система сборки `ya make` не исключение. Платформа для неё — это тройка *<компилятор, OS, архитектура>*, например *<clang11, Windows, x86_64>* или *<clang10, Android, armv8a>*.

**Примеры:**

- `--target-platform clang-win-x86_64`  — собрать по Intel 64bit Windows компилятором Clang;
- `--target-platform default-android-armv8a` — собрать под Android на ARM (в версии armv8a) компилятором по умолчанию;
- `--target-platform windows` — собрать под Windows (и архитектуру по умолчанию x86-64) компилятором по умолчанию.

Подробная информация по кросс-компиляции(ссылка платформа) 

### Опции тестирования

Опции тестирования в `ya make` предлагают широкий спектр опций для управления процессом тестирования:

- Настройки запуска и фильтрации тестов: Опции `-t, --run-tests`, `--test-filter`, `--test-tag` позволяют точно настроить, какие тесты будут запущены, ограничивая их определенными критериями.

- Генерация отчетов и интеграция с CI/CD: Использование `--junit` для создания отчетов в формате JUnit XML упрощает интеграцию с системами непрерывной интеграции и доставки, автоматизируя обработку результатов тестирования.

#### Запуск тестов (-t, -tt, -ttt, -A)

- `-t, --run-tests`: Эта базовая опция запускает все тесты, отмеченные как “маленькие” (SMALL). Это быстрые тесты, обычно требующие мало ресурсов и времени для выполнения.

- `-tt`: Расширение базовой опции `-t`, которое включает в себя запуск тестов как “маленьких”, так и “средних” (MEDIUM) размеров. Средние тесты обычно занимают больше времени и ресурсов.

- `-ttt`: Данная опция запускает тесты всех размеров, включая “большие” (LARGE). Большие тесты часто включают в себя интеграционные и нагрузочные тесты, требующие значительного времени для выполнения и могут включать внешние зависимости.

- `-A, --run-all-tests`: Аналогично `-ttt`, запускает все тесты независимо от размера.

#### Управление выводом результатов

- `-L, --list-tests`: Выводит список тестов, которые будут выполнены, без их фактического запуска. Помогает разработчикам быстро проверить, какие тесты включены в план тестирования.

- `–fail-fast`: Прекращает выполнение тестового прогона сразу после первой встреченной неудачи. Эта опция полезна для экономии времени и ресурсов, особенно когда разработчики ищут конкретную ошибку.

#### Выборочное тестирование

- `–test-filter=TESTS_FILTERS`: Эта опция позволяет ограничить тестирование только определенными тестами, соответствующими указанным фильтрам. Это может быть имя теста, его часть или другой идентифицирующий шаблон.

- `–test-tag=TEST_TAGS_FILTER`: Позволяет запускать только те тесты, которые помечены определенными тегами. Теги — это пользовательские метки, которые могут быть нанесены на тесты для их группировки по определенным признакам или функциональности.

- `–test-size=TEST_SIZE_FILTERS`: Фильтр для запуска тестов определенного размера (SMALL, MEDIUM, LARGE), позволяющий более точно настроить объем запускаемых тестов в зависимости от текущих потребностей.

- `–test-type=TEST_TYPE_FILTERS`: Ограничивает запуск только теми тестами, которые относятся к указанным типам (например, UNITTEST, PYTEST). Это удобно при необходимости проведения специфичных видов тестирования.

### Дополнительные опции

Дополнительные опции `ya make` предоставляют дополнительные возможности для управления сборкой и тестированием проектов, а также для интеграции с внешними инструментами и услугами. Эти настройки позволяют разработчикам гибко настраивать процесс сборки, оптимизировать использование ресурсов, улучшить интеграцию с CI/CD и другими системами, а также получить подробную информацию о процессе сборки и его результате. Ниже рассмотрены ключевые дополнительные опции `ya make`.

#### Управление кэшем

- `–no-cache:` Отключает использование кэша для сборки. Это может быть полезно при диагностике проблем, связанных с кэшированием, или при необходимости гарантировать, что все компоненты проекта собираются заново.

- `–cache-size=SIZE`: Устанавливает максимальный размер кэша. Это позволяет контролировать занимаемое место на диске, оптимизируя процесс сборки за счет удаления старых или редко используемых данных из кэша.

#### Вывод дополнительной информации

- `–verbose`: Увеличивает детализацию выводимой информации о процессе сборки. Подробный вывод может помочь разобраться в причинах предупреждений или ошибках во время сборки.

- `–time-report`: Включает отчет о времени, затраченном на сборку каждого компонента проекта. Эта опция полезна для оптимизации производительности сборки, позволяя выявлять “узкие места”.

#### Управление результатами сборки

- `-o OUTPUT_DIR, --output=OUTPUT_DIR`: Указывает конкретную директорию для сохранения результатов сборки. Это повышает удобство работы с результатами сборки, позволяя легко собирать артефакты в одном месте для архивации или деплоя.

- `–add-result=PATH`: Позволяет явно указать дополнительные файлы или паттерны файлов, которые следует включить в результаты сборки. Это может настраиваться для включения логов, отчетов или других важных файлов.

#### Контроль за зависимостями

- `–strict-dependencies`: Усиливает проверки зависимостей между модулями. С этой опцией `ya make` требует более точного объявления зависимостей в проекте, что повышает его стабильность и предсказуемость сборки.

#### Дополнительные инструменты анализа и тестирования

- `–sanitizer=TYPE`: Включает использование инструментов санитизации (например, AddressSanitizer или ThreadSanitizer) для обнаружения ошибок во время выполнения. Это помогает находить сложные ошибки, такие как обращения к некорректной памяти, утечки памяти и гонки данных.

- `–coverage`: Активирует сбор информации о покрытии кода тестами. Этот режим позволяет оценить, какая часть кода была протестирована, и выявить участки кода, нуждающиеся в дополнительном тестировании.

#### Профилирование и оптимизация

- `–profiling`: Включает генерацию данных профилирования для анализа производительности исполняемого файла. Это помогает выявлять "узкие" места в коде и оптимизировать время исполнения.

- `–opt-level=LEVEL`: Устанавливает уровень оптимизации кода для компилятора. Это позволяет балансировать между временем компиляции и эффективностью исполняемого кода.

#### Настройка вывода и логирования

- –log-level=LEVEL: Определяет уровень детализации логирования для операций сборки и тестирования. Это позволяет получить больше информации о процессе сборки или, наоборот, снизить объем выводимой информации для повышения читабельности.

- –report-to=TARGET: Указывает целевое назначение для отчетов и логов сборки. Можно настроить отправку отчетов непосредственно в файл, в систему управления версиями или в инструмент мониторинга.

Подробная информация по настройке исполнения сборки 
(ссылка на страницу, где описываем 
- Отображение прогресса
- Управление результатами сборки
- Строгий контроль зависимостей
- Локальное кэширование
- Использование распределённого кэша
  )

#### Популярные рецепты

* `ya make -r` - собрать код c оптимизациями и отладочной информацией 
* `ya make -v` - собрать в verbose-режиме. **Обратите внимание:** `ya -v make` и `ya make -v` имеют разный эффект. Первая добавляет вывод утилиты `ya`, вторая — сборки.
* `ya make -T` - собрать, не перезатирая выполняемые команды в выводе
* `ya make --dist` - собрать код на кластере [распределённой сборки](ссылка)
* `ya make --add-result=".h" --add-result=".cpp"` - собрать, добавив в результаты сгенерированные в процессе сборки cpp- и h-файлы.
* `ya make --add-result=".pb.h" --add-result=".pb.cc" --replace-result`- запустить только кодогенерацию протобуфов.
* `ya make -t`  - запустить только быстрые тесты
* `ya make -tL` - вывести список быстрых тестов
* `ya make -A`  - запустить все тесты

## Работа с файлами ya.make

### Структура файла ya.make

Файлы `ya.make` являются основой для определения инструкций сборки в проектах, использующих `ya make`. Каждый такой файл содержит набор макросов, которые описывают, как должны быть скомпилированы модули, управляют зависимостями и определяют параметры тестирования. В типичном файле `ya.make` можно указать:

- Владельца модуля (OWNER) – обычно это имя пользователя или группа, ответственная за модуль.
- Тип сборки (PROGRAM, LIBRARY, PY3_LIBRARY и т.д.) – указывает, является ли модуль исполняемым файлом, библиотекой или чем-то иным.
- Источники (SRCS) – перечень файлов исходного кода, которые следует скомпилировать.
- Зависимости (PEERDIR, DEPENDS) – другие модули или библиотеки, от которых зависит текущий модуль.
- Параметры и флаги компиляции (CFLAGS, LDFLAGS и др.) для настройки процесса сборки.

Пример базового файла ya.make:
```
OWNER(user)
PROGRAM()
SRCS(main.cpp util.cpp)
PEERDIR(library/util)
```
### Определение модулей и их свойств

Модули в `ya.make` обычно определяются с помощью макросов, указывающих тип модуля (PROGRAM, LIBRARY и т.д.). Каждый модуль в проекте описывается в отдельном файле ya.make, который включает в себя все необходимые инструкции для его сборки.

Свойства модуля, такие как исходные файлы (SRCS), зависимости (PEERDIR) и специфичные для компилятора флаги (CFLAGS), настраиваются внутри блока макросов от PROGRAM или LIBRARY до END().

### Объявление зависимостей и ресурсов

Для управления зависимостями между различными компонентами проекта в файлах `ya.make` используются макросы `PEERDIR` и `DEPENDS`. Макрос `PEERDIR` указывает на другие модули внутри проекта, необходимые для сборки текущего модуля, обеспечивая правильное разрешение локальных зависимостей. `DEPENDS` может использоваться для объявления внешних зависимостей, которые требуют загрузки или специфической обработки перед сборкой.

Ресурсы, такие как изображения, конфигурации и данные для тестов, могут быть также объявлены в `ya.make` для корректного включения их в процесс сборки или тестирования с помощью макросов, предназначенных для работы с ресурсами (RES).

Работа с файлами `ya.make` требует понимания структуры и синтаксиса этих файлов, что позволяет гибко настраивать процесс сборки проекта и управлять сложными системами зависимостей. С более подробной информацией, как писать `ya.make` можно ознакомится здесь(ссылка)

Для создания или изменения файлов `ya.make` служит команда [`ya project`](project.md)

## Сборочные переменные 

В команде `ya make` можно указать дополнительные флаги (переменные) с помощью опции `-DVAR[=VALUE]`. Если не указывать значение переменной, по умолчанию оно будет выставлено в `yes`.

Можно определить:

* Предопределённые переменные, позволяющие передать флаги для сборки `ya make -DLDFLAGS="-fblabla=foo -fbar"`, `ya make -DCFLAGS="-DNN_DOUBLE_PRECISION -Wno-strict-aliasing"` и т. п.
* Предопределённые переменные, управляющие конфигурацией, например `ya make -DCATBOOST_OPENSOURCE` (сборка как для open source) или `ya make -DCUDA_VERSION=10.1` (сборка с CUDA).
* Переменные для использования в ya.make `ya make -DMACRO1 -DMACRO2=42`, где в `ya.make` написано, например `IF (MACRO1)`.

Список доступных переменных достаточно большой и часто меняется. Самые часто используемые переменные можно найти в соответствующим разделе (ссылка на описание, сделать разделы по языкам)

## Сообщения об ошибках

### Компоненты сборочных ошибок и предупреждений

`ya make` предоставляет подробные сообщения об ошибках и предупреждениях, которые помогают идентифицировать и устранять проблемы в процессе сборки и тестирования. Эти сообщения могут включать информацию о недостающих файлах, циклических зависимостях, проблемах в конфигурации и многом другом. 
 
### Распространенные ошибки и рекомендации по их устранению

- Конфигурационные ошибки (BadAuto, BadDir, и т.д.): Эти ошибки свидетельствуют о проблемах в настройках сборки, например, неправильно указанных директориях или файлах. Убедитесь, что все пути указаны корректно, и что ваши конфигурации соответствуют требованиям вашего проекта.
- Ошибки зависимостей (DEPENDENCY_MANAGEMENT, DupSrc): Такие ошибки указывают на проблемы с управлением зависимостями, включая дублирование источников или некорректное управление зависимыми модулями. Для решения таких проблем проверьте объявления ваших зависимостей в файлах `ya.make` и устраните дубликаты или некорректные ссылки.
- Синтаксические ошибки (Syntax): Ошибки синтаксиса часто возникают из-за неверного использования макросов или опечаток в файлах 'ya.make'. Внимательно проверьте синтаксис ваших конфигурационных файлов на соответствие документации `ya make`.
- Пользовательские ошибки (UserErr, UserWarn): Эти сообщения генерируются, когда `ya make` сталкивается с проблемами, непосредственно связанными с действиями пользователя, такими как неверное использование опций или несоответствие требованиям проекта. В таком случае рекомендуется пересмотреть используемые команды и опции, а также проконсультироваться с документацией или поддержкой.

Подробная информация по сообщениям об ошибках (ссылка)


