## Тесты с Санитайзером

Санитайзеры позволяют собирать и запускать тестовые приложения так, чтобы автоматизированно проверять наличие различных ошибок связанных с памятью, потоками и неопределённым поведением. 

В системе сборки `ya test` поддерживается несколько типов санитайзеров, и их использование помогает выявлять баги, которые сложно обнаружить обычными тестами.

### Типы поддерживаемых санитайзеров

На данный момент поддерживаются следующие санитайзеры:
- address — обнаруживает проблемы с доступом к памяти, включая ошибки использования неинициализированной памяти, переполнения буфера и другие.
- memory — ищет ошибки использования неинициализированной памяти.
- thread — выявляет ошибки работы с потоками, такие как гонки данных.
- undefined — обнаруживает случаи неопределённого поведения, такие как деления на ноль, сдвиги на нулевое количество битов и другие.
- leak — выявляет утечки памяти.

Можно указывать только один санитайзер за раз.

### Параметризация опций санитайзеров

Локальный запуск `ya test -t --sanitize <SANITIZE_TYPE>` учитывает [стандартные опции для санитайзеров](https://github.com/google/sanitizers/wiki/SanitizerCommonFlags), передаваемые через переменные окружения. 

По умолчанию:

- Для всех санитайзеров: добавляется опция `exitcode=100` для специальной обработки падений тестов в этой конфигурации.
- Для санитаризации `undefined` (`UBSAN_OPTIONS`): дополнительно выставляются опции `print_stacktrace=1, halt_on_error=1`.

Можно зафиксировать конкретные опции санитайзеров для своих тестов через макрос `ENV()` в файле `ya.make`, например:
```
ENV(ASAN_OPTIONS=detect_stack_use_after_return=1)
```
### Отключение тестов от сборки с санитайзерами

Вы можете отключить проект от сборки с санитайзерами несколькими способами:
- Сделайте проект недостижимым по рекурсам для санитайзеров, добавив соответствующие условия:
```
    IF (NOT SANITIZER_TYPE)
        RECURSE_FOR_TESTS(
            test
        )
    ENDIF()
```
- Используйте тег `ya:not_autocheck`, чтобы отключить конкретные тесты от санитайзеров:
```
    IF (SANITIZER_TYPE)
        TAG(ya:not_autocheck)
    ENDIF()
```
- Отключите инструментирование конкретной библиотеки с помощью макроса `NO_SANITIZE()`
  
- С помощью макроса `SUPPRESSIONS()` можно указать файл с правилами подавления обнаруженных санитайзером ошибок в [стандартной нотации](https://clang.llvm.org/docs/AddressSanitizer.html#suppressing-memory-leaks).
Следует учитывать:
  - При добавлении исключений следует убедиться, что сообщение от санитайзеров ложноположительное. Каждое обновление кода или компилятора должно приводить к пересмотру списка подавлений.
  - Опции подавления поддерживаются для санитайзеров address, leak, и thread.

### Отладка тестов с санитайзером

Для отладки падающих тестов необходимо собрать библиотеку с включённым санитайзером, передавая соответствующий флаг сборке:
```
ya test -A --sanitize=<SANITIZER_TYPE>
```
Дополнительно может потребоваться повторить настройки оптимизации `--build=release`.

Для отладки под отладчиком следует добавить точку останова `br __msan_warning_with_origin_noreturn`.

Под отладчиком же можно посмотреть, что санитайзер думает про каждый бит используемой памяти: 
`call (void)__msan_print_shadow(&myVar, sizeof(myVar))`

Согласно [документации](https://github.com/google/sanitizers/wiki/MemorySanitizer#interface) единичные биты обозначают неинициализированную память.
