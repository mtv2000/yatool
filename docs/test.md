# Описание тестов

В нашей системе сборки `ya make` можно описать тесты для основных языков в аркадии. Поддержка тестов реализована поверх фреймворков для тестирования в этих языках. Подробную информацию про устройство тестов в языке можете найти на соответствующих страницах ([C++](cpp), [Python](python), [Java](java), [Go](go)).

## Общие понятия

Два основных понятия для тестов в `ya make` это `test` и `suite`.
* `test` - это конкретная именованная проверка.
* `suite` - сущность, включающая в себя тесты в рамках описываемого модуля.

## Как описывать ya.make

По умолчанию один тестовый модуль является одной `suite`. `suite` аккумулирует в себе ошибки тестирования, которые выходят за пределы определения теста, например:
- ошибки получения списка тестов
- ошибки инициализации тестирования (до фактического выполнения тестов)
- ошибки финализации тестирования

Сьюита имеет несколько параметров:
- Указание фрэймворка тестирования
- Список файлов с тестами
- Список зависимостей
- Размер
- Тэги
- Требования к запуску тестов
- Переменные окружения
- Таймаут на запуск


### Список зависимостей {#dependecy}

Мы придерживаемся идеи герметичности тестов. Это значит, что тест должен быть зависимым только от входных данных, которые были явно задекларированы в `ya.make`. Чтобы обеспечить герметичность тестов, каждый запуск проходит в чистом окружении, которое содержит только указанные явно зависимости из `ya.make`.

Помимо сборочных зависимостей (описываются макросом `PEERDIR()`, для тестов нужно описывать зависимости на входные данные для запуска тестов. Они бывают двух типов:

1. **Другие проекты из единого репозитория**. Например, вам может потребоваться исполняемый файл, исходные коды которого расположены в другом проекте. Такие зависимости описываются при помощи макроса `DEPENDS()`. Все пути строятся относительно корня вашего репозитория и указываются через пробел до `ya.make`.

2. **Тестовые данные**. Например, сюда относятся различные эталонные файлы: логи, списки, тестовые дампы баз данных. Такие файлы могут храниться  в монорепозитории. Для описания тестовых данных можно использовать макросы:
   * **`DATA()`**

### Сборка и запуск тестов {#scope}

Основная задача `ya make` - cборка. Поэтому handler собирает все указанные цели и достижимые от них по `RECURSE`.

Однако, основная цель у `ya test` / `ya make -t` - запуск тестирования.
Поэтому по умолчанию будут собираться только те цели, которые необходимы для запуска тестирования.
Это, например, позволяет запускать конкретные типы тестов без сборки: `ya test --test-type black` запустит только python black линтер, без какой-либо сборки.

### Размер тестов 

Размер тестов задается макросом `SIZE()`. Сейчас существуют три размера:

* `SIZE(SMALL)` - максимальный таймаут *60s (1min)*. Размер по умолчанию.
* `SIZE(MEDIUM)` - максимальный таймаут *600s (10min)*.
* `SIZE(LARGE)` - максимальный таймаут *3600s (1hour)*.


### Тэги теста 

Тесты можно фильтровать по тэгам. Тэги проставляются с помощью макроса `TAG()`.

### Требования к запуску теста 

Макрос `REQUIREMENTS()` позволяет указать требования, необходимые для запуска тестов. С помощью этого макроса можно задать:

* количество ядер
* необходимый объем свободного места на диске
* необходимый объем оперативной памяти
* необходимый объем RAM-диска
* ID контейнера
* ограничения сети

### Переменные окружения {#env}

С помощью макроса `ENV(key=value)` можно задать значение переменной окружения при запуске теста. Каждая переменная окружения задается отдельным макросомм.

## Иерархия проекта с тестами

Предлагается в папке проекта иметь `lib`, `bin`, `tests` или `lib/tests`. Мы не рекомендуем указывать `RECURSE` в `ya.make`, содержащем описание модуля, но можно после директивы `END()` добавлять `RECURSE_FOR_TESTS` на тесты, проверяющие этот модуль. Тогда `project/ya.make` может состоять из

```
RECURSE(
    project/bin
    project/lib
    project/lib/tests
)
```

В `project/lib` не должно быть `RECURSE` на `tests` или определение модуля тестов, однако можно поставить `RECURSE_FOR_TESTS`.

В этом случае при запуске `ya make -t` из каталога `project` инициируется сборка проекта с прогоном тестов. А другие проекты, желая подключать вашу библиотеку, будут писать `PEERDIR(project/lib)` без установления зависимости от ваших тестов.

### Гранулярные тесты {#test-granularity}

Гранулярные зависимости в сборке это хорошо, тоже самое относится и к тестам.
Если у вас в тестовом модуле более ~15 файлов с тестами (к `java` не относится) скорее всего вам нужно разбить ваш suite на несколько логических.
Как правило всё множество тестов можно кластеризовать по каким-либо признакам - по тестируемым сущностям, по зависимостям, по типу тестирования, по сценариям тестирования.

Такое разбиение больших тестовых suite может значительно ускорить локальную разработку и время прохождения PR в CI:
- при исправлении тестов или добавлении новых будет запускаться только целевой suite
- более гранулярные зависимости позволяют запускать только те тесты, которые по настоящему зависят от них
- более гранулярные зависимости ускоряют конфигурацию
- ускоряется рантайм тестирования, так как ускоряется процедура дискаверинга тестов
- в каждый отдельный suite может быть прописан `REQUIREMENTS` соответствующий действительности
- логическая группировка упрощает организацию тестовых файлов

Пример антипаттерна: тестовый модуль с сотнями тестовых файлов и макросами `FORK_TEST()`/`FORK_TEST_FILES()`.
Такая организация suite приводит к огромному прожиганию ресурсов впустую, так как при изменении любого файла будут вынуждены перезапуститься абсолютно все тесты в suite.
Локальный запуск одного конкретного test case из такого suite может происходить очень долго.

## Возможности тестов

### Канонизация

У тестов есть возможность сообщить о своих результатах в виде данных, которые необходимо верифицировать с каноническими. Такие тесты необходимо первый раз канонизировать, после чего системе будут доступны референсные данные для сравнения. Канонический результат будет сохранен рядом с тестом в директорию `canondata/<test name>/result.json` или вынесен в ресурс Sandbox, в зависимости от переданных параметров в тесте.

Каждый фреймворк для написания тестов предоставляет свою поддержку механизма канонизации. Канонизация поддержана для всех языков, кроме C++.

### Метрики

Наш CI поддерживает выгрузку пользовательских метрик из тестов. При подключении проекта к автосборке история теста с метриками будет сохраняться и отображаться в CI. При локальной сборке будет доступен отчет.

### Параллельный запуск тестов

По умолчанию тесты внутри одного `ya.make` файла выполняются последовательно в рамках отдельной задачи сборочного графа, а тесты из разных `ya.make` выполняются параллельно. Для того, чтобы разбить выполнение тестов из одного `ya.make` на несколько параллельных запусков, можно воспользоваться макросами `FORK_TESTS`, `FORK_SUBTESTS` и `FORK_TEST_FILES`. Каждый запуск будет выполнен в отдельной задаче сборочного графа.

Важно отметить, что каждый подзапуск наследует общие параметры теста из `ya.make`, такие как размер, таймаут, требования на ресурсы и т.д. Таким образом удобно распараллелить тесты, которые из-за своего количества перестали укладываться в таймаут, но если в `ya.make` стоит требование `cpu(4)`, то при большом количестве параллельных задач, локальный запуск ya make может замедлиться.

Не все `FORK`-макросы поддержаны для конкретного тестового фреймворка и языка: перед их использованием, уточните текущий статус в документации.

## Exec-тесты

Помимо обычных тестов, которые будут описаны в специфичных для языков разделах, есть возможность писать exec-тесты. Exec-тесты позволяют выполнить произвольную команду и убедиться, что она успешно завершается. Успешным считается завершение команды с кодом возврата 0.

## Как описывать тесты для языков

### C++

Сейчас поддержаны два тестовых фреймворка:
*  собственная разработка
*  популярное решение от Google

Также есть отдельная библиотека, в которой находятся полезные утилиты, независящие от фреймворка.

**Бенчмарки:** Используется библиотека и модуль `G_BENCHMARK`. Все подключенные к автосборке бенчмарки запускаются в CI по релевантным коммитам и накапливают историю метрик.

**Fuzzing:** Фаззинг - это техника тестирования, заключающаяся в передаче приложению на вход неправильных, неожиданных или случайных данных.

**Linting:** Поддержан статический анализ файлов с помощью `clang-tidy`. 

**Метрики:** Помимо метрик от бенчмарков также можно сообщать числовые метрики из `UNITTEST()` и `GTEST()`. Для добавления метрик используйте функцию `testing::Test::RecordProperty` если работаете с `gtest`, или макрос `UNIT_ADD_METRIC` если работаете с `unittest`.


Минимальный `ya.make` для тестов выглядит так:

```
UNITTEST() | GTEST() | G_BENCHMARK()

OWNER(...)

SRCS(tests.cpp)

END()
```

### Python

Основным фреймворком для написания тестов на Python является [pytest](https://pytest.org/).

Поддерживаются Python 2 (модуль `PY2TEST`), Python 3 (модуль `PY3TEST`) и модуль `PY23_TEST`. Все тестовые файлы перечисляются в макросе `TEST_SRCS()`.

Для работы с файлами, внешними программами, сетью в тестах следует использовать специальную библиотеку.

**Метрики**: Чтобы сообщить метрики из теста, необходимо использовать funcarg metrics.
```python
def test(metrics):
    metrics.set("name1", 12)
    metrics.set("name2", 12.5)
```

**Бенчмарки**: Для бенчмарков следует использовать функцию `yatest.common.execute_benchmark(path, budget=None, threads=None)`. Чтобы результаты отображались в CI, результаты нужно записывать в метрики.

**Канонизация**: Можно канонизировать простые типы данных, списки, словари, файлы и директории. Тест сообщает о данных, которые нужно сравнить с каноническими, через возврат их из тестовой функции командой return.

**Linting**: Все python файлы, используемые в сборке и тестах, подключаемые через `ya.make` в секциях `PY_SRCS()` и `TEST_SRCS()`, автоматически проверяются `flake8` линтером.

**Python imports**: Для программ `PY2_PROGRAM`, `PY3_PROGRAM`, `PY2TEST`, `PY3TEST`, `PY23_TEST`, собранных из модулей на питоне, добавлена проверка внутренних модулей на их импортируемость - `import_test`. Это позволит обнаруживать на ранних стадиях конфликты между библиотеками, которые подключаются через `PEERDIR`, а также укажет на неперечисленные в `PY_SRCS` файлы (но не `TEST_SRCS`).

### Java

Для тестов используется фреймворк [JUnit](https://junit.org/junit5/) версий 4.x и 5.x.

Тестовый модуль для JUnit4 описывается модулем `JTEST()` или `JTEST_FOR(path/to/testing/module)`.
* `JTEST()`: система сборки будет искать тесты в `JAVA_SRCS()` данного модуля.
* `JTEST_FOR(path/to/testing/module)`: система сборки будет искать тесты в тестируемом модуле.

Для включения JUnit5 вместо `JTEST()` необходимо использовать `JUNIT5()`.

Содержание `ya.make` файла для `JUNIT5()` и `JTEST()` отличается только набором зависимостей.


**Java classpath clashes**: Есть возможность включить автоматическую проверку на наличие нескольких одинаковых классов в [Java Classpath](https://en.wikipedia.org/wiki/Classpath). В проверке участвует не только имя класса, но и хэш-сумма файла с его исходным кодом, так как идентичные классы из разных библиотек проблем вызывать не должны. Для включения этого типа тестов в ya.make файл соответствующего проекта нужно добавить макрос `CHECK_JAVA_DEPS(yes)`.

**Linting**: На все исходные тексты на Java, которые подключены в секции `JAVA_SRCS`, включён статический анализ. Для проверки используется утилита [checkstyle](https://checkstyle.org/).

**Канонизация**: Для работы с канонизированными данными используйте функции из devtools/jtest.


### Go

Тесты работают поверх [стандартного тулинга для Go](https://pkg.go.dev/testing). Для работы с зависимостями теста следует использовать библиотеку `library/go/test/yatest`.

Все тестовые файлы должны иметь суффикс `_test.go`. Они перечисляются в макросе `GO_TEST_SRCS`.

Тестовый модуль описывается модулем `GO_TEST()` или `GO_TEST_FOR(path/to/testing/module)`.
* `GO_TEST()`: система сборки будет искать тесты в `GO_TEST_SRCS()` данного модуля.
* `GO_TEST_FOR(path/to/testing/module)`: система сборки будет искать тесты в `GO_TEST_SRCS` в тестируемом модуле.

Минимальные `ya.make` файлы выглядят так:

{% list tabs %}

- GO_TEST()

  ```
  GO_TEST()

  GO_TEST_SRCS(file_test.go)

  END()
  ```
- GO_TEST_FOR()

  В `project/ya.make` в макросе `GO_TEST_SRCS` перечисляются тестовые файлы:

  ```
  GO_LIBRARY() | GO_PROGRAM()

  SRCS(file.go)

  GO_TEST_SRCS(file_test.go)

  END()

  RECURSE(tests)
  ```

  В `project/tests/ya.make` указывается относительный путь от корня аркадии на  тестируемый модуль через `GO_TEST_FOR`:

  ```
  GO_TEST_FOR(relative/path/to/project)

  END()
  ```

{% endlist %}

**Канонизация**: Для работы с такими тестами используйте library/go/test/canon.

**Бенчмарки**: Чтобы включить бенчмарки в проекте, нужно добавить тэг `ya:run_go_benchmark` в `ya.make` проекта. 

# Запуск тестов

ya make предоставляет развитые возможности запуска тестов. Основными понятиями для тестирование силами ya make являются **test**, **chunk** и **suite** (набор тестов).

* **Test** - одна именованная проверка, описанная в виде кода на поддерживаемом языке программирования. В понятие теста включается не только проверка правильности работы кода, но также, например, проверки, что код соответствует рекомендуемому [стандарту оформления](https://en.wikipedia.org/wiki/Programming_style). Любые падения/ошибки во время исполнения теста относятся непосредственно к исполняемому тесту.

* **Chunk** - сущность, представляющая собой запуск программы с тестами (представлен в виде узла в графе команд), в рамках которой исполняются тесты. К chunk относятся все ошибки runtime исполнения за рамками тестов. Например, ошибки запуска тестирования, когда тестовая программа упала на инициализации и тесты даже не запускались, ошибки финализации тестирования, утечки памяти после тестирования, падения.

* **Suite** - набор из нескольких тестов одного типа и имеющих один и тот же набор зависимостей. Suite содежит по крайней мере один chunk (так называемый sole chunk). Все тесты в наборе имеют общий размер, логику начала (set up) и завершения (tear down) работы, теги и так далее. Некоторые ошибки не позволяют вообще запустить тестирование - сломанные зависимости теста, когда невозможно собрать требуемую для тестирования программу. Все такие ошибки относятся к suite.

Каждая suite имеет имя, размер, время, отведённое на работу, тип (используемый фреймворк), а также опциональный набор тегов. Все эти параметры могут быть использованы для фильтрации.
Кроме того, каждый отдельный тест имеет имя и потому фильтрация может делаться с точностью до отдельного теста.

## Запуск тестов 

Для простого запуска тестов есть следующие ключи командной строки:

- `-t` — запустить только SMALL тесты.
- `-tt` — запустить SMALL и MEDIUM тесты.
- `-ttt`, `-A`, `--run-all-tests` — запустить тесты всех размеров.
- `--test-param=TEST_PARAM` — параметризовать тесты значениями из командной строки. `TEST _PARAM` имеет вид `name=val`, доступ к параметрам зависит от используемого фреймворка.

**Пример**

```bash
$ ya make -t devtools/examples/tutorials/python
```

Запустит все тесты, которые найдёт по `RECURSE`/`RECURSE_FOR_TESTS` от `devtools/examples/tutorials/python`, включая тесты стиля и тесты импорта для Python. Использует следующие умолчания для сборки:

- Платформа будет определена по *реальной платформе*, на которой запущена команда `ya make`.
- Тесты будут собраны в режиме `debug` — он используется по умолчанию.
- Кроме тестов будут собраны все остальные цели (библиотеки и программы), достижимые по `RECURSE`/`RECURSE_FOR_TESTS` от `devtools/examples/tutorials/python`. Это включает сборку всех необходимых зависимостей.

По умолчанию система сборки запустит все запрошенные тесты. После запуска тестов для всех упавших тестов будет выдана краткая информация о падениях (включая ссылки на более полную информацию). Для прошедших и проигнорированных (отфильтрованных) тестов будет выдан только общий короткий статус (количество тех и других).

Это поведение меняется следующими ключами:

- `--fail-fast` — исполнять тесты до первого падения.
- `-P`, `--show-passed-tests` — показывать каждый прошедший тест
- `--show-skipped-tests` — показывать каждый пропущенный (отфильтрованный) тест
- `--show-metrics` — показывать метрики тестов

## Список тестов { #test_list }

Список всех тестов, которые будут запущены, можно получить опцией `-L` (`--list-tests`).
Эта опция поддерживает выбор размера тестов, а также все [параметры фильтрации](#test_filtering).

**Примеры**

```bash
# Список всех SMALL тестов
[arcadia]$ ya make -tL devtools/examples/tutorials/python
```

```bash
# Список всех пользовательских тестов (без тестов стиля, импортов и подобных проверок)
[arcadia]$ ya make -AL --regular-tests devtools/examples/tutorials/python
```

## Размер тестов

В едином репозитории в одном пулл-реквесте изменения могут вноситься в код и тесты на разных языках программирования. Важно, чтобы проверка любых пулл-реквестов проходила как можно быстрее, поэтому тесты разделены на категории по **максимальному разрешённому времени исполнения**, которое является значением по умолчанию:

1. **SMALL** тесты: выполняются **не более 1 минуты**. Сюда обычно попадает большинство [unit-тестов](https://en.wikipedia.org/wiki/Unit_testing).
2. **MEDIUM** тесты: выполняются **не более 10 минут**. Сюда попадают некоторые медленные unit-тесты, интеграционные и end-to-end тесты.
3. **LARGE** (ранее **"FAT"**) тесты: выполняются **не более 1 часа**. Содержит особо медленные тесты. В отличие от MEDIUM/SMALL тестов LARGE тесты могут продолжаться даже после завершения остальных проверок пулл-реквеста, потому что запускаются в отдельном процессе.

Размер тестов должен быть явно указан в файле **ya.make** при помощи макроса `SIZE`.
Максимальное время выполнения теста можно уменьшить при помощи макроса `TIMEOUT`.

Пример файла **ya.make** для тестов на Java:

```yamake
OWNER(g:my-group)

JUNIT5() # Используемый фреймворк

SIZE(MEDIUM) # Размер тестов

JAVA_SRCS(SRCDIR java **/*) # Исходные коды тестов
JAVA_SRCS(SRCDIR resources **/*)

PEERDIR( # Зависимости
    my-project/src/
    # ...
)

END()
```

## Параллельный запуск тестов { #fork }

По умолчанию тесты внутри одной suite выполняются последовательно в рамках одного chunk (так называемого sole chunk) в виде отдельного узла графа команд `ya`.
Тесты из разных suite (ya.make) выполняются параллельно, но последовательно в рамках одно chunk.

Во время формирования графа команда `ya` не может знать, сколько будет тестов в suite, так как для этого требуется сборка и листинг тестов средствами тестового фреймворка.
Так как `ya` оперирует статическим графом команд (он не меняется по мере исполнения и целиком известен для исполнителя), то на этапе конфигурации мы только можем заранее вставить нужное количество chunk'ов, каждый из которых исполнит непересекающееся множество тестов.

Чтобы разбить выполнение тестов из suite на несколько chunk'ов, нужно воспользоваться макросами `FORK_TESTS`, `FORK_SUBTESTS` и `FORK_TEST_FILES`.

Каждый chunk наследует общие параметры теста из `ya.make`: размер, таймаут, требования на ресурсы и другие: таким образом удобно распараллелить тесты, которые из-за своего количества перестали укладываться в таймаут.

* `FORK_TESTS`, `FORK_SUBTESTS` – режимы, при которых вместо sole chunk запуск suite разбивается на несколько chunk'ов, каждый из которых получает дополнительные параметры в виде общего количества chunk'ов, участвующих в разбиении и своего порядкового номера: по этим параметрам каждый chunk определяет подмножество тестов, которое надо запустить.
Количество chunk'ов по умолчанию равно `10`, это значение можно изменить с помощью `SPLIT_FACTOR(X)` (при локальной разработке `SPLIT_FACTOR` можно переопределить с помощью `--split-factor=Х`. `--split-factor=1` отключает режим форков).
Отличие `FORK_TESTS` от `FORK_SUBTESTS` заключается в том, что `FORK_TESTS` считает тесты, объединенные в классы, неделимой сущностью, в то время как `FORK_SUBTESTS` разбивает в том числе тестовые классы и в разных chunk'ах могут оказаться тесты, принадлежащие одному классу, что может быть нежелательно, если у классов есть тяжёлые подготовительные стадии.

* `FORK_TEST_FILES` – разбивает прогон тестов из suite на количество chunk'ов, равное количеству файлов с тестами, перечисленных в `ya.make`, каждый запуск работает только с одним конкретным файлом.

`FORK_TESTS`, `FORK_SUBTESTS` принимают необязательный аргумент - `SEQUENTIAL` или `MODULO`, определяющий, как будет происходить разделение тестов по chunk'ам.
`SEQUENTIAL` разделяет тесты равными диапазонами, предварительно их отсортировав по имени.
`MODULO` разделяет тесты по модулю `SPLIT_FACTOR`,  предварительно их отсортировав (т.е. при `SPLIT_FACTOR(2)`, первый тест попадёт в первый chunk, второй тест во второй, третий в первый и т.д.)
Если аргумент не указан, значение по умолчанию - `SEQUENTIAL`.

`FORK_TEST_FILES` можно комбинировать с `FORK_TESTS` или `FORK_SUBTESTS`, тогда будет дополнительное разбиение запуска тестов из каждого файла.

`FORK_TEST_FILES` поддержан только для `pytest`.

## Фильтрация тестов { #test_filtering }

Suite можно фильтровать по различным свойствам:

- `--test-size=TEST_SIZE_FILTERS` — запускать только выбранные размеры
- `--test-type=TEST_TYPE_FILTERS` — запускать только выбранные [типы тестов](#test_type). Перед именами типов тестов можно использовать `+` для включения suite в фильтр и `-` для исключения. Таким образом `--test-type -import_test` запустит все тесты, кроме `import_test`. Фильтр `--test-type unittest+gtest` запустит только `unittest` и `gtest`.
- `--style` — запускать только тесты стиля
- `--regular-tests` — запускать только пользовательские тесты
- `--test-tag=TEST_TAGS_FILTER` — запускать только сюиты с определёнными тегами. Перед именами тегов можно использовать `+` для включения тега в фильтр и `-` для исключения. Таким образом `--test-tag tag1+tag2-tag3` запустит все тесты, у которых есть `tag1`, `tag2` и нет `tag3`. Фильтр `--test-tag -tag3` запустит все тесты без тега `tag3`. Фильтр `--test-tag ya:anytag` запустит все тесты со всеми тегами.

Помимо фильтрации suite можно фильтровать отдельные тесты:

-  `-F=TESTS_FILTERS`, `--test-filter=TESTS_FILTERS` — фильтрация тестов по имени. Будет запущен тест, полное имя которого строго соответствует `TESTS_FILTERS`. Для запуска подмножества тестов в шаблоне можно указать символ `*` (соответствует любому количеству символов). Каждый последующий шаблон расширяет подмножество запускаемых тестов. Например `-F '*a' -F 'B*c'` запустит все тесты имена которых заканчиваются на `a` или начинаются на `B` и заканчиваются на `c`. Шаблоны взяты в одинарные кавычки для того чтобы shell не развернул фильтр в список файлов, которому может соответствовать шаблон.
-  `-F="[X/Y] chunk"`, `--test-filter="[X/Y] chunk"` — фильтрация тестов по chunk'ам. Внутри `[]` можно использовать `*` для фильтрации.
- `--test-filename=TEST_FILES_FILTER` — запускать тесты только из выбранного исходного файла (работает только для `pytest` и `hermione`, другие тестовые фреймоврки не предоставляют такой информации).
- `-X`, `--last-failed-tests` — запустить только тесты упавшие в предыдущем запуске. Указание дополнительных фильтров (например с помощью `-F`) расширяет множество тестов, которое будет запущено. Обычно это требуется, когда вы хотите следить за корректным статусом некоторых тестов, помимо перезапуска упавших от предыдущего прогона.

При указании флага `-F` можно использовать [специальные символы](https://docs.python.org/3/library/fnmatch.html):

```bash
$ ya make -t -F <file>.py::<ClassName>::*
```

JUnit5-тесты можно фильтровать по тегам `@Tag`:

- `--junit-args '--junit-tags "tag1 tag2 tag3"'` - запуск всех тестов, у которых есть хотя бы один из указанных тегов (теги можно также разделять плюсом, например `tag1+tag2`). Подробнее можно почитать [тут](../../manual/tests/java.md#filtering).

## Канонизация (и переканонизация)

Система сборки ya make для некоторых типов тестов поддерживает сравнение с эталонными (каноническими) данными. Если эти данные нужно обновить воспользуйтесь опцией `-Z` (`--canonize-tests`).
В этом режиме вместо сравнения данных с эталонными, сами эталонные данные будут заменены и при необходимости отправлены в Sandbox. В локальное рабочее пространство будут внесены все необходимые изменения.

## Типы тестов { #test_type }

**Типом теста** называется выполнение проверок с использованием одного конкретного инструмента, например, фреймворка `pytest` для Python или утилиты проверки форматирования кода `go fmt` для Golang. Полный список типов тестов приведен в таблице:

Тип | Описание
:--- | :---
`black` | Проверка форматирования кода на python3 утилитой [black](../../manual/tests/style#black).
`classpath.clash` | Проверка наличия дублирующихся классов в classpath при компиляции Java проекта.
`eslint` | Проверка стиля и типичных ошибок кода на TypeScript с использованием утилиты [ESLint](https://eslint.org/).
`exectest` | Выполнение произвольной команды и проверка её кода возврата
`flake8.py2` | Проверка стиля кода на Python 2 c использованием утилиты [Flake8](https://gitlab.com/pycqa/flake8)
`flake8.py3` | Проверка стиля кода на Python 3 c использованием утилиты [Flake8](https://gitlab.com/pycqa/flake8)
`fuzz` | [Fuzzing](https://en.wikipedia.org/wiki/Fuzzing) тест
`g_benchmark` | Выполнение бенчмарков на C++ библиотекой [Google Benchmark](https://github.com/google/benchmark)
`go_bench` | Выполнение бенчмарков на Go утилитой `go bench`
`gofmt` | Проверка форматирования кода на Go утилитой `go fmt`
`go_test` | Выполнение тестов на Go утилитой `go test`
`govet` | Выполнение статического анализатора кода на Go утилитой `go vet`
`gtest` | Выполнение тестов на С++ с использованием фреймворка [Google Test](https://github.com/google/googletest/)
`java` | Выполнение тестов на Java с использованием фреймворка [JUnit](https://junit.org/)
`java.style` | Проверка форматирования кода на Java утилитой [checkstyle](https://checkstyle.org/)
`ktlint` | Проверка стиля Kotlin кода с использованием утилиты [ktlint](https://ktlint.github.io)
`py2test` | Тесты на Python 2 с использованием фреймворка [pytest](https://pytest.org/)
`py3test` | Тесты на Python 3 с использованием фреймворка [pytest](https://pytest.org/)
`pytest` | Тесты на Python любой версии с использованием фреймворка [pytest](https://pytest.org/)
`unittest`| Тесты на C++ с использованием фреймворка 

