## Конфигурация системы сборки

### Основные настройки

Основные параметры системы сборки описаны в файле `build/yamake.core.conf`, а также в `.conf`-файлах в директории `build/conf`. Язык конфигурации представляет собой декларативный DSL, включающий:

- Язык описания правил.
- Язык описания макросов и модулей.
- Язык параметризованных подстановок шаблонов.

### Содержимое файлов конфигурации

Файлы конфигурации могут включать:

1. Установку значений переменных: переменные используются в правилах конфигурирования и сборочных командах.
2. Правила установки значений переменных: на основе значений других переменных с использованием синтаксиса `when/elsewhen/otherwise`.
3. Описание модулей и мультимодулей: доступных в ya.make.
4. Описание макросов: как внутренних для конфигурации, так и публичных для файлов ya.make.

Дополнительно конфигурация системы сборки включает:

- Плагины в директории `build/plugins`: для макросов, которые нельзя описать на языке конфигурации.
- Правила в директории `build/rules`: для ограничения зависимостей.
- Правила резолвинга хедеров в директории `build/sysincl`.
- Скрипты в директории `build/scripts`: для реализации логики сборочных команд.
- Описание тулчейнов в файлах `ya.make`.

## Использование конфигурации

### Процесс обработки

1. Чтение конфигурации: Зачитываются и устанавливаются глобальные переменные.
2. Формирование конфигурации сборки: Конфигурация частично формируется динамически скриптом `build/yamake_conf.py`.
3. Обработка переменных и триггеров: Конфигурационные переменные принимают свои начальные глобальные значения.
4. Чтение `ya.make` файла: Устанавливаются локальные переменные, которые могут через триггеры повлиять на значения других переменных.
5. Исполнение макросов: Макросы исполняются в порядке своих приоритетов и формируют команды для построения.
6. Обработка зависимостей: Рекурсивно обрабатываются `PEERDIR-зависимости` между модулями.
7. Формирование команд: Команды помещаются в граф зависимостей и исполняются по мере готовности входных файлов.

### Источники макросов

  * Встроенные макросы: обеспечивают базовые функции и описаны в коде ядра системы сборки.
    К таким макросам относятся:
      - Макрос текстового включения `INCLUDE`.
      - Базовые макросы работы с переменными (`SET/SET_APPEND` и т.п.). Сюда же относятся макросы получения списков файлов по     маскам `(_GLOB)`, но они являются внутренними и могут быть использованы в `ya.make`, они могут использоваться для создания пользовательских макросов, таких как `ALL_PY_SRCS`.
      - Базовые макросы зависимостей и связей: `PEERDIR`, `DEPENDS`, `RECURSE`.
      - Макросы путей для поиска файлов `SRCDIR`, `ADDINCL`, `INDICED_DEPS` и т.п.
      - Макросы управления модулями и мультимодулями: `END`, `DLL_FOR`, `EXCLUDE_TAGS/ONLY_TAGS/ONLY_TAGS`
      - Условные конструкции `IF/ELSE/...`
      - Описательные макросы, которые система сборки не интерпретирует, но может выдать как дополнительную информацию о модулях, например `OWNER`.
 
  * Конфигурируемые макросы, модули и мультимодули: описаны в файлах конфигурации `build/yamake.core.conf` и в директории `build/conf`.
    Описание конфигурации делается на достаточно сложном декларативном DSL, позволяющем выразить:
      - Правила настройки (значения переменных) в зависимости от платформы и других параметров (тоже переменных);
      - Описание макросов — их параметризацию и поведение;
      - Шаблоны формирования сборочных команд: что, где и как надо вызывать, а также дополнительные свойства команд такие как, например, отображаемое имя или требуемые ресурсы;
      - Входы и результаты для связывания команд в граф;
      - Применение макросов по расширениям;
      - Свойства модулей для связывания их с командами и между собой;
      - Правила, относящиеся к конкретным модулям: свойства модулей и команд в них в зависимости от платформы и других параметров;
      - Варианты мультимодулей и их связывание по зависимостям.

## Описание макросов и модулей

### Макросы

Макросы делятся на две основные группы:
1. Макросы, задающие свойства: Формируют переменные и устанавливают зависимости.
Такие макросы вызывают другие макросы и в итоге формируют переменные, которые будут использованы в командах других макросов или модуля. Кроме того, такие макросы могут добавлять зависимости или устанавливать свойства модуля.
2. Макросы, описывающие команды: Описывают команды для исполнения в процессе сборки.
Макрос формирует команду, которая встраивается в сборочный граф своего модуля за счёт связывания своих результатов с входами других команд (потребителей) и, возможно, своих входов с результатами других команд (источников).

И макросы, задающие свойства, и макросы, описывающие команды, могут работать с параметрами.
Описать можно 5 видов параметров:
  - `AAA` - скалярный неименованный (позиционный). Получает значение в своей позиции среди всех позиционных параметров.
  - `AAA="Default"` - скалярный именованный, с дефолтным значением. Получает значение после имени `QQQ(AAA xxx) —> AAA=xxx` или дефолтное значения по факту своего отсутствия.
  - `AAA?"XXX":"YYY"` - логический именованный. В вызове указывается только его имя без значения. Получает значение по факту своего присутствия/отсутсвия.
  - `AAA[]` - именованный списочный. Получает все значения после своего имени до следующего именованного параметра или до конца. Может встречаться несколько раз - знаения будут конкатенироваться. К сожалению не умеет в дефолтные значения.
  - `AAA...` - неименованный списочный (vararg). Получает всё, что осталось от остальных параметров, может быть только один.

### Модули

Модуль — это макрос, описывающий команду своей сборки и ряд дополнительных свойств:
- Формирование имени модуля.
- Автоматические входы команд.
- Связывание с другими модулями.
- Допустимые макросы и их полиморфизм.
- Условные правила поведения модуля.

Описание модуля, как и макроса, может включать вызовы макросов, которые выполняются при обнаружении модульного макроса в файле `ya.make`.

Хотя у модуля есть параметры, они не описываются явно. Система сборки обрабатывает их автоматически для создания имени модуля.

Модуль может иметь локальные переменные, которые влияют как на его собственные команды, так и на другие команды в его описании сборки. Эти переменные могут использоваться для составления условных правил поведения модуля. Они могут менять поведение не только макросов в описании модуля, но и макросов, написанных в контексте его области в `ya.make`.

Чтобы избежать дублирования общих свойств нескольких модулей, модули могут наследоваться друг от друга. Например, модули `PROGRAM` и `DLL` наследуются от общего родителя — модуля `_LINK_UNIT`, который задает общие свойства для модулей, способных линковать библиотеки.

Свойства наследующего модуля либо переопределяют свойства родителя, либо объединяются с ними. Поведение зависит от конкретного свойства. Макросы родителя выполняются ранее макросов наследующего модуля.

### Мультимодули

Мультимодули описываются как совокупность модулей с уникальными тэгами, которые совпадает с его именем в описании или задаётся переменной `MODULE_TAG` и определяют зависимость вариантов друг от друга.

Собственных общих свойств у мультимодулей не существует, так же как и наследования. Однако каждый отдельный вариант представлен как полноценный модуль и может быть унаследован.

### Плагины

Система сборки `ya make` поддерживает расширение с использованием плагинов на Python и C++:
- Python плагины: размещены в `build/plugins` и интерпретируются ядром системы сборки в момент исполнения.
- C++ плагины: влинкованы в ядро системы сборки и требуют пересборки для локальной разработки (программы `devtools/ymake/bin`).

## Резолвинг имён

Система сборки `ya make` использует процесс резолвинга имён для связывания входных и выходных файлов между различными командами. Это позволяет автоматизировать зависимости между файлами и команд, а также обеспечивать корректную сборку проекта.

### Входы и выходы

Связывание входов с выходами в `ya make` происходит по именам. Чтобы команда зависела от файла, необходимо указать имя файла в качестве входа. Если файл с таким именем является выходом другой команды, первая команда будет зависеть от результатов выполнения второй.

### Резолвинг зависимостей

Процесс поиска подходящих имён для создания зависимости между командами называется резолвингом. Он включает несколько шагов:

1. Формирование имён-кандидатов: Проверка, является ли имя полным, включает корень проекта (BUILD_ROOT). Если имя полное, проверяется его доступность.
2. Проверка префиксов-кандидатов: Соединение имени с префиксом и проверка его доступности.

#### Резолвинг инклудов

Резолвинг для инклудов имеет дополнительные особенности:
 - Сначала проверяется путь до файла, откуда идёт `#include ""` (только для инклудов с `"..."`).
 - Проверка списка системных инклудов.
   
 - Если результаты противоречат системному резолвингу, выдается ошибка.

## Префиксы-кандидаты

Каждый префикс-кандидат определяет путь с указанием корня, к которому относится (дерево исходных файлов или сборочных результатов).

### Для входных файлов

1. Корень дерева исходных файлов.
2. Корень дерева результатов сборки.
3. Пути, указанные в макросе SRCDIR.

Приоритет имеют исходные файлы, чтобы избежать конфликта с генерированными файлами.

### Для инклудов

1. Путь до файла, откуда идёт include/import.
2. Корень дерева результатов сборки.
3. Корень дерева исходных файлов.
4. Пути из макроса ADDINCL.

## Проверка доступности

### Для исходного кода
Проверяется наличие файла на файловой системе.

### Для результатов сборки
Проверяется наличие файла среди результатов уже построенных команд.

## Связывание для модулей

Связывание входов с выходами происходит без резолвинга в случае, когда файлы появляются в процессе обработки по расширениям и для команд, указанных в SRCS(GLOBAL ...).

## Советы и замечания

1. Для инклудов рекомендуется использовать избыточный ADDINCL, чтобы избежать проблем с резолвингом.
2. Важно обеспечить однозначный резолвинг для всех используемых инкудов.
3. Списки системных инклудов позволяют указать несколько вариантов для одного имени, что помогает в случае неоднозначного резолвинга.

- 
