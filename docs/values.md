### Передача параметров

Параметры в макросах ya.make разделяются пробелами или переводами строк соответственно в большинстве случаев каждое отдельное слово — это отдельный параметр.
Макросы с длинным набором параметров можно переносить на несколько строк, разделяя по параметрам. Множественные пробелы в отступах считаются одним разделителем.

Поэтому можно так:

```
SET(FILE_LIST x y z)
```

Или так
```
SET(FILE_LIST
    x y z)
```
Или так
```
SET(
   FILE_LIST
   x
   y
   z
)
```

### Типы и виды параметров

Параметры в ya.make бывают всего трёх типов: строки, списки строк и булевы (по признаку наличия, см. ниже).

Параметры в ya.make бывают *именованные* и *неименованные*.

**Неименованные параметры** участвуют в вызове своим значением, они бывают:

- **Скалярные** — значением параметра является строка (одно слово). Иногда такой параметр может быть опциональным. Например, имя модуля 
   (параметр макроса заголовка модуля) — это обычно опциональный скалярный параметр.  Если таких параметров несколько, они принимают свои
   значения в соответствии с позицией

  - В документации обычно параметр описывается как `<значение>` (обязательный) или `[<значение>]` опциональный. Иногда угловые скобки опущены для читаемости.
    Важно, что слово, обозначающее значение, в таком случае одно и оно не целиком заглавными буквами.

  __Примеры:__
  ```
  ### @usage: PY_NAMESPACE(<name.space>)
  PY_NAMESPACE(my.namespace)
  .
  ### @usage: KV(<Key> <Value>)
  KV(the_key, the_value) # Key=the_key, Value=the_value
  ```

- **Свободно-списочные** — значением параметра является список всех строк (слов), не отнесённых ни к какому другому параметру. Если таких не находится, список остаётся пустым.
  - В документации такой параметр описывается как `Значение...`. 

  __Примеры:__
  ```
  ### @usage: ALL_SRCS([GLOBAL] Filenames...)
  .
  ALL_SRCS(x.cpp GLOBAL y.cpp)       # Filenames=x.cpp y.cpp, GLOBAL=True
  .
  ### @usage: SRC(<File>, Flags...)
  SRCS(x.cpp -Wno-error -std=c++17)  # Flags=-Wno-error -std=c++17
  SRCS(y.cpp)                        # Flags=<empty>
  ```

**Именованные параметры** участвуют в вызове своим именем и, возможно, значением. Исторически для именования параметров макросов, как и самих макросов, используется
(SCREAMING_SNAKE_CASE)[https://ru.wikipedia.org/wiki/Snake_case].

Именованные параметры бывают:

- **Булевы** — значение параметра определяется в описании самого макроса, а в вызове различается факт присутствия параметра в списке (*истина*) или отсутствия (*ложь*).
  - В документации такой параметр описывается как `[PARM_NAME]`. Важно, что в данном случае имя параметра написано целиком большими буквами и без угловых скобок.

  __Пример:__
  ```
  ### @usage: ALL_SRCS([GLOBAL] Filenames...)
  .
  ALL_SRCS(GLOBAL x.cpp y.cpp)  # GLOBAL is True
  ALL_SRCS(a.cpp b.cpp)         # GLOBAL is False
  ```

- **Скалярные** — значением параметра является строка (слово), идущее в вызове сразу после имени параметра. Такой параметр может быть *опциональным*, если он не указан,
  то параметр получит значение по умолчанию.
  - В документации такой параметр выглядит как `NAME <value>` или `[NAME <value>]`. Имя параметра целиком большими буквами, а значение — одно слово в угловых скобках.

  __Примеры:__
  ```
  ### @usage: COMPILE_LUA(Src, [NAME <import_name>])
  .
  COMPILE_LUA(func.lua NAME my.func)  # NAME=my.func
  COMPILE_LUA(the_func.lua)           # NAME=<default>
  ```

- **Списочные** — значением параметра является список строк (слов), идущих после имени параметра и до следующего имени параметра или закрывающей скобки.
  Имя параметра может встречаться в строке несколько раз, давая в результате конкатенацию всех списков. Если имя параметра не встречается, список остаётся пустым.
  - В документации такой параметр выглядит как `NAME <list of values>` или `[NAME <list of values>]`. Имя параметра целиком большими буквами, а
    значение — несколько слов в угловых скобках. 

  __Пример:__
  ```  
  ### @usage: FROM_ARCHIVE(Src [RENAME <resource files>] OUT <output files> [PREFIX <prefix>] [EXECUTABLE])
  # Src    - обязательный неименованный скалярный
  # RENAME - опциональный именованный списочный
  # OUT    - обязательный именованный списочный
  # PREFIX - опциональный именованный скалярный
  # EXECUTABLE - булев
  .
  FROM_ARCHIVE(
      resource.tar.gz
      PREFIX y
      RENAME y/a.txt OUT y/1.txt
      RENAME y/b/c.txt OUT y/2.txt
      RENAME RESOURCE OUT 3.tar.gz
      OUT y/d.txt
  )
  # Src=resource.tar.gz 
  # PREFIX=y
  # RENAME=y/a.txt y/b/c.txt RESOURCE  ## RESOURCE в данном случае значение, а не имя параметра
  # OUT=y/1.txt y/2.txt 3.tar.gz y/d.txt
  ```

### Экранирование значений параметров

Для объединения нескольких слов в параметре в одно можно использовать `"..."` (двойные кавычки) или, если что-то идёт не так `"'...'"` одинарные кавычки внутри двойных.

{% note warning %}

Экранирование кавычками может работать только на весь список параметров. Например:

Значением переменной будет одна неразрывная строка:
```
SET(FILE_LIST "a.x b.x c.x")
```

Значением переменной станет список из 4-х элементов, а не из 3-х:
```
SET(FILE_LIST a.x "with space.x" c.x)
```
{% endnote %}


{% note warning %}

Внутри ya make в качестве разделителя также используется запятая (`,`) и в некоторых случаях её невозможно надёжно экранировать. Единственным надёжным решением на данный
момент является использование специальной переменной `${__COMMA__}`

{% endnote %}

Пример:

```
SET(
  OPENAPI_GENERATOR_GENERATE_MODELS_VALUE
  models${__COMMA__}apis=false${__COMMA__}modelTests=false${__COMMA__}apiTests=false${__COMMA__}modelDocs=false${__COMMA__}apiDocs=false
)
```

### Интерпретация значений параметров

Параметрами макросов может быть практически что угодно и интерпретацией параметров могут заниматься разные системы в разные моменты времени:

- Часть значений интерпретирует сама система сборки. При чём это касается не только *встроенных* макросов, но и [*конфигурируемых*](./index.md#conf).
  Встроенные макросы могут полностью разбирать свои параметры, например [логические выражения в `IF`](#if), а также могут [интерпретировать имена директорий](#dirs).
  Для [имён файлов есть общая интерпретация](#files). Они могут обрабатываться, формируя входы, результаты, текстовые параметры команд.
  Система сборки также поддерживает ограниченный набор строковых и списочных операций для превращения значений параметров в параметры сборочных команд. Но как-то глубоко
  интерпретировать строковые значения она не умеет.

- Часть значений с помощью системы сборки могут интерпретировать [плагины для макросов](./index.md#plugins). Поскольку они пишутся на развитых языках программирования,
  их возможности в интерпретации значений практически неограниченны. Единственное ограничение к плагинам — это скорость их работы.

- Многие значения параметров макросов долетают до сборочных команд и интерпретируются уже самими командами во время исполнения. При чём это могут быть как оригинальные
  сборочные инструменты, так и их обёртки (обычно на языке Python). Большая часть таких обёрток описана в [build/scripts](https://a.yandex-team.ru/arc_vcs/build/scripts).
  Сама система сборки (своей исполнительной подсистемой), тоже может кое-что интерпретировать на этом этапе. Она поддерживает:
  - Свёртку списков параметров в файлы аргументов
  - Подстановку ссылок на глобальные ресурсы (переменные вроде `$(PYTHON)`)
  - Подстановку путей до дерева исходного кода и дерева сборки (новое на каждую сборочную команду) — переменные `$(ARCADIA_ROOT)` и `$(BUILD_ROOT)`.

#### Имена директорий { #dirs }

Макросы, такие как [`PEERDIR`](./common/macros.md#peerdir), [`ADDINCL`](./common/macros.md#addincl), [`RECURSE`](./common/macros.md#recurse) и [`DATA`](common/data.md#data) принимают имена директорий. Однако в этих конкретных 4-х макросах 4 различных интерпретации этих путей:

- [`ADDINCL`](./common/macros.md#addincl), а также [`SRCDIR`](./common/macros.md#srcdir) интерпретируют директории просто как пути. Далее они используются для [отображения имён на файлы](../general/how_it_works.md#resolving),
  но, по сути, это просто строки с дополнительной проверкой их наличия в дереве исходных файлов.
  В такие макросы можно передать как директорию в дереве исходных файлов, так и в дереве результатов сборки. Путь требуется всегда от корня репозитория и без [явного указания](common/vars.md#dir_vars)
  он считается в дереве исходных файлов. 

- [`PEERDIR`](./common/macros.md#peerdir) интерпретирует имена директорий, как ссылки на модули, которые будут там собраны. Это же справедливо для других макросов [межмодульных зависимостей](./index.md#mod_deps) --
  [`DEPENDS`](./tests/common.md#depends), [`BUNDLE`](./common/macros.md#bundle) и [`RUN_PROGRAM`](./common/macros.md#run_program), где директория указывается первым параметром как путь до инструмента. Путь в данном случае интерпретируется достаточно сложным образом:
  - Путь всегда интерпретируется как путь от корня репозитория. Корень указывать нельзя и не имеет смысла: генерированных ya.make не бывает (ну то есть сгенерировать можно,
    но интерпретироваться они не будут). 
  - В дереве исходных файлов должен лежать ya.make описывающий сборку.
  - Результатом этой сборки будет артефакт в аналогичном месте дерева результатов сборки. Зависимость получается от него.
  - В случае, если в ya.make описан [мультимодуль](./index.md#multi), то будет выбран подходящий для данной зависимости.

- [`RECURSE`](./common/macros.md#recurse) и подобные макросы интерпретируют имена директорий, как пути до ya.make в этих директориях. Все макросы, кроме [`RECURSE_ROOT_RELATIVE`](./common/macros.md#recurse) требуют пути относительно текущей директории.
  [`RECURSE_ROOT_RELATIVE`](./common/macros.md#recurse) требует пути от корня в дереве исходного кода. Корень указывать нельзя и не имеет смысла: генерированных ya.make не бывает (ну то есть сгенерировать можно,
   но интерпретироваться они не будут). 
   
- [`DATA`](common/data.md#data) интерпретирует директории, как зависимость от всех файлов в этой директории. Аналогично работают макросы, собирающие файлы по шаблону, например [`ALL_PY_SRCS`](python/macros.md#all_py_srcs).
  В [`DATA`](common/data.md#data) по историческим причинам путь внутри репозитория указывается как `arcadia/<path_from_root>`. При чём путём может быть как директория, так и файл. В любом случае зависимость допустима только
  на исходные файлы. Директории не могут быть результатами сборки и даже для файлов [резолвинг](../general/how_it_works.md#resolving) для [`DATA`](common/data.md#data) не работает.

- В большинство остальные макросы можно передать имя директории как строку, и она будет интерпретироваться как путь только самой сборочной командой.

