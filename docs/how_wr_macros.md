## Основные принципы по написанию макросов.

Макросы используются для создания повторно используемых блоков кода, которые выполняют определенные задачи, такие как настройка модулей, установка переменных, отключение функциональности и многое другое. 

Условно макросы можно разделить на две группы:

1. Макросы, задающие свойства: Эти макросы вызывают другие макросы, формируют переменные, которые будут использованы в командах других макросов или модуля. Кроме того, такие макросы могут добавлять зависимости или устанавливать свойства модуля.
2. Макросы, описывающие команды: Эти макросы описывают команды, которые должны быть исполнены в процессе сборки. Макрос формирует команду, которая встраивается в сборочный граф своего модуля за счёт связывания своих результатов с входами других команд (потребителей) и, возможно, своих входов с результатами других команд (источников). Такие макросы и формируют сборочный граф, который исполняется в процессе сборки.

Определение макроса осуществляется посредством ключевого слова `macro`, за которым следует имя макроса. Макрос может также принимать параметры, которые указываются в скобках сразу после его имени. При выхове макроса параметры указываются через пробел.

Пример:
```plaintext
macro MY_MACRO(PARAM1, PARAM2) {
   // Код макроса
 }
```
Параметры делятся на три типа: строки, списки строк и булевы. Они могут быть именованными и неименованными.

**Неименованные параметры** участвуют в вызове своим значением:
- Скалярные — строка (одно слово). Может быть опциональным.
В документации обозначается как `<значение>` (обязательный) или `[<значение>]` опциональный.
Важно, что слово, обозначающее значение, в таком случае одно и оно не целиком заглавными буквами.

Примеры:
```plaintext
  ### @usage: PY_NAMESPACE(<name.space>)
  PY_NAMESPACE(my.namespace)
  ### @usage: KV(<Key> <Value>)
  KV(the_key, the_value) # Key=the_key, Value=the_value
```
- Свободно-списочные — список слов, не отнесённых к другим параметрам.
В документации обозначается как `Значение...`.

 Примеры:
```plaintext
  ### @usage: ALL_SRCS([GLOBAL] Filenames...)
  ALL_SRCS(x.cpp GLOBAL y.cpp)       # Filenames=x.cpp y.cpp, GLOBAL=True
  
  ### @usage: SRC(<File>, Flags...)
  SRCS(x.cpp -Wno-error -std=c++17)  # Flags=-Wno-error -std=c++17
  SRCS(y.cpp)                        # Flags=<empty>
```
**Именованные параметры**  обозначены именем и возможным значением. Используются [SCREAMING_SNAKE_CASE](https://ru.wikipedia.org/wiki/Snake_case):
- Булевы — определяются в описании макроса по наличию в списке. В документации такой параметр описывается как `[PARM_NAME]`. Важно, что в данном случае имя параметра написано целиком большими буквами и без угловых скобок.

Пример:
 ```plaintext
  ### @usage: ALL_SRCS([GLOBAL] Filenames...)
  ALL_SRCS(GLOBAL x.cpp y.cpp)  # GLOBAL is True
  ALL_SRCS(a.cpp b.cpp)         # GLOBAL is False
 ```
- Скалярные — строка (одно слово) после имени параметра. Может быть опциональным. В документации такой параметр выглядит как `NAME <value>` или `[NAME <value>]`. Имя параметра целиком большими буквами, а значение — одно слово в угловых скобках.

Пример:
 ```plaintext
  ### @usage: COMPILE_LUA(Src, [NAME <import_name>])
  .
  COMPILE_LUA(func.lua NAME my.func)  # NAME=my.func
  COMPILE_LUA(the_func.lua)           # NAME=<default>
  ```
- Списочные — список слов после имени параметра и до следующего имени или закрывающей скобки. Может встречаться несколько раз. В документации такой параметр выглядит как `NAME <list of values>` или `[NAME <list of values>]`. Имя параметра целиком большими буквами, а значение — несколько слов в угловых скобках. 

Примеры:
 ```plaintext
  ### @usage: FROM_ARCHIVE(Src [RENAME <resource files>] OUT <output files> [PREFIX <prefix>] [EXECUTABLE])
  # Src    - обязательный неименованный скалярный
  # RENAME - опциональный именованный списочный
  # OUT    - обязательный именованный списочный
  # PREFIX - опциональный именованный скалярный
  # EXECUTABLE - булев
  .
  FROM_ARCHIVE(
      resource.tar.gz
      PREFIX y
      RENAME y/a.txt OUT y/1.txt
      RENAME y/b/c.txt OUT y/2.txt
      RENAME RESOURCE OUT 3.tar.gz
      OUT y/d.txt
  )
  # Src=resource.tar.gz 
  # PREFIX=y
  # RENAME=y/a.txt y/b/c.txt RESOURCE  ## RESOURCE в данном случае значение, а не имя параметра
  # OUT=y/1.txt y/2.txt 3.tar.gz y/d.txt
  ```
Условия в макросах могут быть заданы для выполнения действий в зависимости от значений переменных. Эти условия определяются с помощью ключевого слова `when` и проверяются на истинность.

Правила (триггеры) задают значения переменных на основе других переменных. Условные выражения в языке конфигурации не исполняются в последовательности их написания, а активируются при изменении значения соответствующего условия. Работают декларативно, а не ипнративно, поэтому вместо конструкции `if/then/else` используется синтаксис `when/elsewhen/otherwise`.

Пример:
```plaintext
   macro CONDITIONAL_SET(CONDITION) {
       when ($CONDITION == "yes") {
           SET(VAR "value1")
       }
       otherwise {
           SET(VAR "value2")
       }
   }
```
Отключение функциональности в макросах осуществляется с использованием функции `DISABLE` для отключения определённых функций или зависимостей, а включение осуществляется с помощью функции `ENABLE`.

Пример:
   ```plaintext
### @usage: WERROR()
### Consider warnings as errors in the current module.
### In the bright future will be removed, since WERROR is the default.
### Priorities: NO_COMPILER_WARNINGS > NO_WERROR > WERROR_MODE > WERROR.
macro WERROR() {
    ENABLE(WERROR)
}

### @usage: NO_WERROR()
### Override WERROR() behavior
### Priorities: NO_COMPILER_WARNINGS > NO_WERROR > WERROR_MODE > WERROR.
macro NO_WERROR() {
    DISABLE(WERROR)
}
```
Макросы могут использовать глобальные переменные и атрибуты, которые влияют на поведение всего проекта.

Пример:
```plaintext
   macro SET_GLOBAL_ATTRIBUTES() {
       .GLOBAL=_AARS _PROGUARD_RULES
   }
```
