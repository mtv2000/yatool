## Базовые термины и принципы системы сборки

### Сборочная цель или модуль

#### Понятие сборочной цели

Сборочной целью в системе сборки ya make называется программа, библиотека или пакет, которые будут собираться. Сборочная цель может быть интерпретирована двояко:

1. Артефакт — конкретный результат сборки, например, файл программы или библиотеки, пакет (файл или директория с файлами).
2. Описание сборки — файл ya.make, содержащий инструкцию по сборке.

Стоит отметить, что не каждая сборочная цель приводит к созданию артефакта. Такие цели могут быть полезны для установления зависимостей, внедрения сборочных флагов или других свойств в другие сборочные цели.

#### Указание сборочной цели

Сборочная цель указывается её директорией. В этой директории имеется файл ya.make, где описано, что и как будет собираться. Результаты сборки по умолчанию также размещаются в этой директории в виде символьных ссылок.

В системе сборки ya make действует следующее правило:
- Одна директория — одна сборочная цель. В каждой директории сборка описывается только в файле ya.make, и каждый файл ya.make содержит описание сборки не более чем одного модуля.

Это правило может быть неявно нарушено в двух случаях:
  1. Мультимодули — специальные сборочные цели, которые адаптируются к различным контекстам использования. Например, одна и та же сборочная цель может создать разный артефакт в зависимости от того, в каком контексте она используется.
  2. Неявные проверки — некоторые сборочные цели могут автоматически добавлять тесты, которые будут построены и запущены вместе с модулем, если запрошен запуск тестов.

#### Запуск сборки

Для запуска сборки используются команды вида: `ya make <target1> <target2>`

Если цель не указана явно, то сборка производится для текущей директории.

#### Сборка нескольких целей

Кроме прямого указания целей, можно собирать несколько целей вместе, используя макросы RECURSE и RECURSE_FOR_TESTS в файле ya.make. Эти макросы позволяют собрать несколько целей одновременно, но не делают сборочные цели зависимыми друг от друга.

Чтобы ограничить сборку только текущей целью, используйте ключ `-R/--ignore-recurses`.

#### Финальные и промежуточные модули

Модули в системе сборки делятся на финальные и промежуточные:

1. Финальные модули — программы, динамические библиотеки, тесты и т.п., которые могут быть исполнены и независимо распространяться.
2. Промежуточные модули — библиотеки, которые используются для сборки финальных модулей.

В ya make используется статическая линковка, поэтому финальные модули всегда замкнуты, то есть их сборка включает в себя сборку всех зависимых модулей по PEERDIR.

Даже в языках с динамическим связыванием, таких как Java, финальные артефакты включают все необходимые зависимости для выполнения программы. Промежуточные модули могут вызывать сборку своих PEERDIR-зависимостей только если это необходимо для их собственной сборки.

В языке C++ и Python промежуточные модули не вызывают сборку зависимых библиотек при своей сборке, а делают это только при сборке программы или теста.

### Что такое конфигурирование

Первое, что происходит при запуске сборки в системе ya make, — это конфигурирование. В процессе конфигурирования система анализирует зависимости и формирует граф сборочных команд. На этом этапе решаются три основные задачи:

1. Обнаружение изменений.
2. Анализ зависимостей.
3. [Построение графа сборочных команд](UIDwork.md)

#### Этапы конфигурирования

##### Обнаружение изменений

Система сборки ya make использует два метода для обнаружения изменений:

1. Файловая система: Сначала система анализирует изменения в файловой системе, выявляя измененные исходные файлы, файлы ya.make или состав файлов, указанных в шаблонах (glob-выражениях). Это позволяет избежать полного анализа зависимостей при каждой сборке и использовать кэш зависимостей.
2. Уникальный идентификатор команды (UID): На последнем этапе каждая сборочная команда получает уникальный идентификатор. Даже если кэш зависимостей недоступен, система будет использовать кэш результатов для инкрементальной сборки, избегая повторной сборки неизменных компонентов.

##### Анализ зависимостей

Анализ зависимостей — это не только считывание всех нужных ya.make-файлов.

На этом этапе система выявляет и фиксирует все зависимости каждой команды, включая:

1. Текст команд и содержимое входных файлов: Система учитывает не только текст команды, но и всех необходимых для нее файлов.
2. Межфайловые зависимости: Анализ исходных файлов для выявления зависимостей.
3. Хэширование файлов: Фиксация содержимого файлов для обнаружения изменений в последующих сборках.
4. Распределение свойств: Распространение и уточнение свойств по межмодульным зависимостям, включая управление зависимостями в Java (dependency management) и транзитивные списки зависимостей (например, сборка библиотек для линковки программ).
5. Вычисление уникального идентификатора (UID): Уникальный идентификатор команды создается на основе всех факторов, влияющих на результат команды (текст команды, аргументы, входные файлы и их содержимое).

##### Построение графа сборочных команд

Финальным результатом конфигурирования является граф сборочных команд, который включает:
1. Текст команд: Собственно команды, необходимые для сборки.
2. Имена результатов: Имена создаваемых файлов и других артефактов.
3. Требования и служебная информация: Информация для отображения в процессе сборки и в CI.
4. Производительно-потребительские связи: Связи между узлами в графе, где один узел производит результаты, которые потребляет другой узел. 

Как строится граф сборочных команд можно ознакомится в [описании](UIDwork.md)

Граф может быть сериализован и исполнен не там, где его строили, важно лишь, чтобы часть графа относящаяся к платформе сборки соответствовала реальной платформе, на которой его будут исполнять.

#### Платформы и конфигурации

Платформа в системе сборки ya make включает аппаратную конфигурацию, операционную систему и системное окружение. В рамках системы выделяются три основные платформы:

1. Реальная платформа конфигурирования: Платформа, где запускается команда ya make. Поддерживаются платформы Intel x86-64/Linux, PowerPC/Linux, Intel x86-64/macOS, Apple arm64/macOS и Windows.

2. Реальная сборочная платформа (Host): Платформа, на которой исполняется сборка. Она может совпадать с платформой конфигурирования, но не обязательно. Альтернативная сборочная платформа может быть указана флагом `--host-platform`.

3. Реальная целевая платформа (Target): Платформа, для которой собирается код. ya make поддерживает кросс-компиляцию, и целевые платформы могут быть указаны параметром `--target-platform` или добавив платформы в ya.conf

Система поддерживает одновременную сборку под несколько целевых платформ. Однако артефакты для разных платформ могут иметь одинаковые имена, что может привести к наложению и непредсказуемым результатам. Для более предсказуемой сборки следует использовать ya package.

Некоторые платформы недоступны в режиме кросс-компиляции. Так, например, из-под Darwin невозможна сборка целей для Windows.

#### Конфигурационные параметры

Часто под платформой понимают сборочную конфигурацию, то есть весь набор параметров, который влияет на формирование результатов сборки. Так для Java частью платформы может быть версия JDK, а для C++, например, сборка с address sanitizer. Даже тип сборки debug/release включают в такое расширенное понятие платформы. Сборочная конфигурация может меняться большим количеством разных флагов включая произвольные конфигурационные переменные или сборочные флаги, передаваемые в сборку опцией `-D`, `--target-platform-flags` или `[target_platform.flags]`.

Вся эта информация называется конфигурационными параметрами. Она учитывается в конфигурировании и определяет то, каким будет сборочный граф - какие в нём будут команды, входные файлы и результаты.

Сборочная и целевая платформы по умолчанию определяются на основе используемой платформы конфигурирования, то есть они, как правило, совпадают с платформой, на которой запустили систему сборки. Тем не менее, отдельные конфигурационные параметры могут различаться.

Сборочная конфигурация, включающая все эти параметры, определяется во время конфигурирования, и результаты кэшируются для обеспечения герметичности и воспроизводимости сборки.

### Исполнение сборки

После завершения конфигурирования, строится граф сборочных команд и начинается этап исполнения. Этот этап может происходить либо локально на машине, где была запущена команда `ya make`, либо на кластере распределённой сборки. Важно понимать процесс исполнения, так как он включает в себя использование кэша, работу с UID и обеспечение герметичности сборки.

#### Основные характеристики исполнения

##### Начало исполнения

Исполнение сборки начинается с целей, которые были запрошены в командной строке или указаны в макросах RECURSE в файле ya.make. Эти цели зафиксированы в сборочном графе и называются входами.

##### Использование UID и кэша

1. UID как ключ в кэше: Каждая команда в графе сборочных команд имеет уникальный идентификатор (UID). Этот UID используется как ключ в кэше результатов. Если какой-либо UID присутствует в кэше, система сразу возвращает закэшированные результаты, избегая повторного исполнения команды.
2. Инкрементальная сборка: Если UID отсутствует в кэше, сначала рекурсивно собираются все зависимости (также с использованием кэша), и только затем исполняется команда.

##### Рабочие директории

Каждая сборочная команда исполняется в своей рабочей директории, называемой `BUILD_ROOT`. Система обеспечивает наполнение этой директории результатами сборки зависимых команд.

1. BUILD_ROOT: Это отдельная директория для каждой сборочной команды. Система гарантирует, что в неё будут помещены результаты сборки всех зависимостей, известных системе сборки.
2. SOURCE_ROOT: Обычно это одна директория на все команды, указывающая на корень проекта. Однако, в специальном режиме строгого контроля зависимостей (--sandboxing), доступ к файлам в этой директории ограничен только теми файлами, зависимость от которых известна системе сборки.

#### Герметичность сборки

Герметичность означает зависимость сборки только от данных, известных системе сборки. Это важно для корректного кэширования и воспроизводимости сборочного процесса.

1. Полная информация о зависимостях: Все зависимости от исходного кода должны быть известны системе сборки. Команды не должны зависеть от отдельных файлов на локальной системе или внешних систем, не зафиксированных в конфигурации сборки.
2. Использование хранилища Sandbox: Все необходимые бинарные данные загружаются из хранилища Sandbox, что исключает возможность изменения данных для конкретной ревизии.
3. Строгий контроль зависимостей: Включается флагом `--sandboxing`. Этот режим запрещает доступ к неизвестным системе сборки файлам во время исполнения.

#### Воспроизводимость сборки

Если сборка герметична, то при фиксированном состоянии репозитория и заданных конфигурационных параметрах результаты будут воспроизводимы. Это обеспечивает следующие преимущества:

1. Репродуктивность проблем из CI: Любые проблемы, возникшие в CI, можно воспроизвести локально.
2. Обратная совместимость: Бинарный код может быть пересобран заново при необходимости отката или восстановления утерянных результатов, используя состояние репозитория.
3. Экономия ресурсов на кластере: Нет необходимости иметь серверы под разные ОС в кластере распределённой сборки. Например, сборка на Linux под Windows будет такой же функционально (даст такие же результаты), как и на “родной” платформе.

### Описание сборки

Процесс сборки в системе ya make описывается в специальных файлах с именем ya.make. Эти файлы размещаются рядом с кодом и содержат все необходимые инструкции и параметры для выполнения сборочного процесса. Описание в этих файлах является высокоуровневым и базируется на использовании различных макросов и модулей.

#### Структура файла ya.make

Файл ya.make состоит из набора макросов, каждый из которых выполняет специфические функции. Они делятся на несколько категорий:

1. Собственно сборочные макросы: например, SRCS для указания исходных кодов, PEERDIR для указания сборочных зависимостей.
2. Макросы интерпретации: например, IF, INCLUDE для условий и включений.
3. Макросы свойств сборки: например, SET(), GRPC().
4. Макросы определения целей: например, RECURSE.
5. Макросы для внешних систем: например, SUBSCRIBER.

Большинство макросов, не требуют указания команд для сборки. Команды — это скрытые свойства макросов, которые могут меняться в зависимости от конфигурационных параметров. Указывать в макросах обычно надо лишь аргументы для этих команд. Такие макросы как SRCS могут определить какую команду использовать для сборки по расширению файла, для каждого файла отдельно. И даже более того, если результат какого-то макроса — это файл с известным расширением, то команда обработки файла по расширению будет использована автоматически (как если бы этот файл написали в SRCS).


### Макросы

Макросы используются для управления сборочным процессом и имеют разные задачи:
- Описание сборки кода: включают такие макросы, как SRCS и PEERDIR, которые указывают на исходные коды и межмодульные зависимости.
- Контроль интерпретации: макросы IF и INCLUDE, которые позволяют управлять логикой интерпретации файла ya.make.
- Свойства сборки: макросы типа SET() или GRPC() позволяют задавать параметры сборки и влиять на работу других макросов.
- Определение сборочных целей: макрос RECURSE позволяет включать другие сборочные цели в процесс сборки.
- Фиксация свойств: макросы типа SUBSCRIBER позволяют фиксировать свойства сборки для внешних систем.

### Модули

Модули — это специальные макросы, которые определяют сборочную цель. В каждом файле ya.make может быть определён не более одного модуля, что позволяет однозначно идентифицировать модуль с помощью директории.

#### Свойства модулей

- Модульные макросы: макросы между началом модуля и END() описывают сборку для конкретного модуля.
- Единственность: макросы, описывающие сборку, нельзя писать вне модуля.
- Автоматическая сборка: при сборке директории будет собираться модуль, описанный в ya.make.
- Ошибка при отсутствии модуля: если модуль отсутствует в ya.make, это приведет к ошибке при попытке сборки или зависимостей.

#### Именование артефактов

Имя артефакта, создаваемого модулем, можно задать первым опциональным аргументом модуля. Это имя будет дополнено префиксом и суффиксом, зависящими от конкретного модуля и платформы. Например:

- Для статической библиотеки на C++ на Linux, будет добавлен префикс `lib` и суффикс `.a`.
- Для Windows, будет добавлен суффикс `.lib` и пустой префикс.
- Для Java-библиотеки, суффикс `.jar` и пустой префикс.

Если имя не указано, оно будет сконструировано на основе пути к модулю в проекте.

### Пример интерпретации ya.make

Примерный процесс интерпретации файла ya.make выглядит следующим образом:

1. Чтение и формирование свойств модуля.
2. Рекурсивное формирование свойств для зависимостей модуля.
3. Расширение свойств модуля глобальными свойствами, которые распространяются не только на модуль, но и на всех, кто от него зависит. Например, `ADDINCL(GLOBAL)` задаёт пути поиска инклудов для модуля и всех, кто от него зависит. Это нужно для корректной обработки `#include` в заголовочных файлах модуля, включенных из других модулей.
4. Формирование графа сборки модуля - команды сборки всего, что для него нужно, включая сборку результата самого модуля - библиотеки, программы или теста.

### Мультимодули

Некоторые модули могут вести себя по-разному в зависимости от контекста использования. Такие модули называются мультимодулями. Например:
- `PROTO_LIBRARY` может иметь варианты для нескольких языков программирования (C++, Python, Java и т.д.).
- `PY23_LIBRAR`Y может быть совместима как с Python 2, так и с Python 3, и выбор варианта зависит от контекста.

С точки зрения использования в ya.make мультимодули не отличаются от обычных модулей, но у них будет несколько вариантов сборки и какие-то макросы могут быть совместимы не со всеми вариантами, а какой-то исходный код может быть нужен не во всех вариантах. Система сборки определяет специальные переменные, чтобы при описании сборки мультимодуля описать разные варианты по-разному.

### Зависимости

#### Виды зависимостей

Для понимания, какие изменения требуют пересборки, система сборки разделяет зависимости на три основных вида:

1. Межмодульные зависимости: такие как PEERDIR — для сборки других целей, DEPENDS — для тестов, и BUNDLE — для интеграции результатов сборки.
2. Файловые зависимости: зависимостями на уровне файлов, включая явные и индуцированные зависимости.
3. Модульные зависимости от файлов: например, DATA() для тестовых данных.

##### Межмодульные зависимости
Основные зависимости между модулями — это:
* `PEERDIR` - цель нужна для сборки другой цели. Самая распространённая межмодульная зависимость.
* `DEPENDS` - цель нужна тесту во время его исполнения (она не является частью теста, а именно исполняется тестом во время его работы). DEPENDS-зависимости собираются только если был запрошен запуск соответствующего теста, либо по ключу `--force-build-depends`.
* `BUNDLE` - результат сборки цели нужен для сборки другой цели (например, так можно сложить одну программу внутрь другой). BUNDLE-зависимости всегда собираются вместе с модулем, в описании которого они написаны.
* Инструментальная` - результат сборки цели используется как инструмент при сборке другой цели. Такая зависимость возникает, например, при использовании макроса `RUN_PROGRAM`.
Она похожа по смыслу на зависимость `BUNDLE`, но она меняет платформу для зависимой цели: поскольку зависимая цель будет исполняться во время сборки, то сама она будет построена для сборочной платформы (host), в то время как её результат будет строиться для целевой платформы (target).

##### Файловые зависимости

Файловые зависимости делятся на *явные* и *индуцированные* или *наведённые*. Допустим в библиотеке `l` файл `a.cpp` инклудит `b.h`, а тот в свою очередь `c.h`. Теперь если меняется `c.h` то при сборке `l` надо перезапустить команду компиляции `a.cpp` в `a.cpp.o`, а также персборку `l.a` с изменившимся `a.cpp.o`. Зависимости `a.cpp` от `b.h` и `b.h` от `c.h` называются *явными* в том смысле, что эта зависимость явно указана в коде. Соответственно, на сборку `a.cpp.o` влияют все явные зависимости для `a.cpp` рекурсивно. Чтобы упростить описание таких зависимостей система сборки ya make умеет выводить их анализом файлов по расширениям.

##### Зависимости модулей от файлов

В большинстве случаев эта зависимость обозначает, что файл необходим для сборки модуля. В большинстве макросов, таких как SRCS, FILES и даже RUN_PROGRAM, упоминания файлов создают такую зависимость.

Однако есть 3 других варианта:
* `DATA()` — зависимость исполнения тестов от файлов проекта. Файлы не попадают в сборку тестов, а предоставляются непосредственно исполнению теста в исходном виде.
* `SRCS(GLOBAL file.cpp)` обозначает зависимость сборки от файла, но не от модуля, в котором этот макрос прописан. Если макрос находится в библиотеке, то компиляция этого файла влияет не на саму библиотеку, а на любую программу, использующую её. Это бывает необходимо, чтобы линкер не удалил код из файла, например, статическую инициализацию с регистрацией объектов.
* `CS(header.h)` или `PY_SRCS(my.pyi)` — такие файлы приписаны модулю, но не участвуют в процессе сборки. Это необходимо для интеграции с ya ide, чтобы дополнительные файлы могли включаться в проекты для модулей. Система сборки может использовать подобные зависимости для своих целей, например, учитывая принадлежность файлов к модулям.
