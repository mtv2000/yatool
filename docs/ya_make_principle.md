## Базовые термины и принципы системы сборки

### Сборочная цель или модуль

#### Понятие сборочной цели

Сборочной целью в системе сборки ya make называется программа, библиотека или пакет, которые будут собираться. Сборочная цель может быть интерпретирована двояко:

1. Артефакт — конкретный результат сборки, например, файл программы или библиотеки, пакет (файл или директория с файлами).
2. Описание сборки — файл ya.make, содержащий инструкцию по сборке.

Стоит отметить, что не каждая сборочная цель приводит к созданию артефакта. Такие цели могут быть полезны для установления зависимостей, внедрения сборочных флагов или других свойств в другие сборочные цели.

#### Указание сборочной цели

Сборочная цель указывается её директорией. В этой директории имеется файл ya.make, где описано, что и как будет собираться. Результаты сборки по умолчанию также размещаются в этой директории в виде символьных ссылок.

В системе сборки ya make действует следующее правило:
- Одна директория — одна сборочная цель. В каждой директории сборка описывается только в файле ya.make, и каждый файл ya.make содержит описание сборки не более чем одного модуля.

Это правило может быть неявно нарушено в двух случаях:
  1. Мультимодули — специальные сборочные цели, которые адаптируются к различным контекстам использования. Например, одна и та же сборочная цель может создать разный артефакт в зависимости от того, в каком контексте она используется.
  2. Неявные проверки — некоторые сборочные цели могут автоматически добавлять тесты, которые будут построены и запущены вместе с модулем, если запрошен запуск тестов.

#### Запуск сборки

Для запуска сборки используются команды вида:

ya make <target1> <target2>

Если цель не указана явно, то сборка производится для текущей директории.

#### Сборка нескольких целей

Кроме прямого указания целей, можно собирать несколько целей вместе, используя макросы RECURSE и RECURSE_FOR_TESTS в файле ya.make. Эти макросы позволяют собрать несколько целей одновременно, но не делают сборочные цели зависимыми друг от друга.

Чтобы ограничить сборку только текущей целью, используйте ключ `-R/--ignore-recurses`.

#### Финальные и промежуточные модули

Модули в системе сборки делятся на финальные и промежуточные:

1. Финальные модули — программы, динамические библиотеки, тесты и т.п., которые могут быть исполнены и независимо распространяться.
2. Промежуточные модули — библиотеки, которые используются для сборки финальных модулей.

В ya make используется статическая линковка, поэтому финальные модули всегда замкнуты, то есть их сборка включает в себя сборку всех зависимых модулей по PEERDIR.

Даже в языках с динамическим связыванием, таких как Java, финальные артефакты включают все необходимые зависимости для выполнения программы. Промежуточные модули могут вызывать сборку своих PEERDIR-зависимостей только если это необходимо для их собственной сборки.

В языке C++ и Python промежуточные модули не вызывают сборку зависимых библиотек при своей сборке, а делают это только при сборке программы или теста.

### Что такое конфигурирование

Первое, что происходит при запуске сборки в системе ya make, — это конфигурирование. В процессе конфигурирования система анализирует зависимости и формирует граф сборочных команд. На этом этапе решаются три основные задачи:

1. Обнаружение изменений.
2. Анализ зависимостей.
3. [Построение графа сборочных команд](UIDwork.md)

#### Этапы конфигурирования

##### Обнаружение изменений

Система сборки ya make использует два метода для обнаружения изменений:

1. Файловая система: Сначала система анализирует изменения в файловой системе, выявляя измененные исходные файлы, файлы ya.make или состав файлов, указанных в шаблонах (glob-выражениях). Это позволяет избежать полного анализа зависимостей при каждой сборке и использовать кэш зависимостей.
2. Уникальный идентификатор команды (UID): На последнем этапе каждая сборочная команда получает уникальный идентификатор. Даже если кэш зависимостей недоступен, система будет использовать кэш результатов для инкрементальной сборки, избегая повторной сборки неизменных компонентов.

##### Анализ зависимостей

Анализ зависимостей — это не только считывание всех нужных ya.make-файлов.

На этом этапе система выявляет и фиксирует все зависимости каждой команды, включая:

1. Текст команд и содержимое входных файлов: Система учитывает не только текст команды, но и всех необходимых для нее файлов.
2. Межфайловые зависимости: Анализ исходных файлов для выявления зависимостей.
3. Хэширование файлов: Фиксация содержимого файлов для обнаружения изменений в последующих сборках.
4. Распределение свойств: Распространение и уточнение свойств по межмодульным зависимостям, включая управление зависимостями в Java (dependency management) и транзитивные списки зависимостей (например, сборка библиотек для линковки программ).
5. Вычисление уникального идентификатора (UID): Уникальный идентификатор команды создается на основе всех факторов, влияющих на результат команды (текст команды, аргументы, входные файлы и их содержимое).

##### Построение графа сборочных команд

Финальным результатом конфигурирования является граф сборочных команд, который включает:
1. Текст команд: Собственно команды, необходимые для сборки.
2. Имена результатов: Имена создаваемых файлов и других артефактов.
3. Требования и служебная информация: Информация для отображения в процессе сборки и в CI.
4. Производительно-потребительские связи: Связи между узлами в графе, где один узел производит результаты, которые потребляет другой узел. 

Как строится граф сборочных команд можно ознакомится в [описании](UIDwork.md)

Граф может быть сериализован и исполнен не там, где его строили, важно лишь, чтобы часть графа относящаяся к платформе сборки соответствовала реальной платформе, на которой его будут исполнять.

#### Платформы и конфигурации

Платформа в системе сборки ya make включает аппаратную конфигурацию, операционную систему и системное окружение. В рамках системы выделяются три основные платформы:

1. Реальная платформа конфигурирования: Платформа, где запускается команда ya make. Поддерживаются платформы Intel x86-64/Linux, PowerPC/Linux, Intel x86-64/macOS, Apple arm64/macOS и Windows.

2. Реальная сборочная платформа (Host): Платформа, на которой исполняется сборка. Она может совпадать с платформой конфигурирования, но не обязательно. Альтернативная сборочная платформа может быть указана флагом --host-platform.

3. Реальная целевая платформа (Target): Платформа, для которой собирается код. ya make поддерживает кросс-компиляцию, и целевые платформы могут быть указаны параметром --target-platform.

> Важно: Система поддерживает одновременную сборку под несколько целевых платформ. Однако артефакты для разных платформ могут иметь одинаковые имена, что может привести к наложению и непредсказуемым результатам. Для более предсказуемой сборки следует использовать ya package.

#### Конфигурационные параметры

Конфигурационными параметрами называются все параметры, влияющие на сборку, включая версии JDK для Java или флаги для компиляции C++. Эти параметры передаются через опции -D, --target-platform-flags или [target_platform.flags].

Сборочная конфигурация, включающая все эти параметры, определяется во время конфигурирования, и результаты кэшируются для обеспечения герметичности и воспроизводимости сборки.

### Заключение

Конфигурирование в системе ya make — это критический этап, который позволяет эффективно управлять зависимостями, обнаруживать изменения и формировать граф сборочных команд для различных платформ. Это обеспечивает корректность сборки и её воспроизводимость, существенно упрощая процесс управления проектами и CI/CD.


### Исполнение сборки

#### Введение

После завершения конфигурирования, которое строит граф сборочных команд, начинается этап исполнения. Этот этап может происходить либо локально на машине, где была запущена команда ya make, либо на кластере распределённой сборки. Важно понимать процесс исполнения, так как он включает в себя использование кэша, работу с UID и обеспечение герметичности сборки.

#### Основные характеристики исполнения

##### Начало исполнения

Исполнение сборки начинается с целей, которые были запрошены в командной строке или указаны в макросах RECURSE в файле ya.make. Эти цели зафиксированы в сборочном графе и называются входами.

##### Использование UID и кэша

1. UID как ключ в кэше: Каждая команда в графе сборочных команд имеет уникальный идентификатор (UID). Этот UID используется как ключ в кэше результатов. Если какой-либо UID присутствует в кэше, система сразу возвращает закэшированные результаты, избегая повторного исполнения команды.
2. Инкрементальная сборка: Если UID отсутствует в кэше, сначала рекурсивно собираются все зависимости (также с использованием кэша), и только затем исполняется команда.

##### Рабочие директории

Каждая сборочная команда исполняется в своей рабочей директории, называемой BUILD_ROOT. Система обеспечивает наполнение этой директории результатами сборки зависимых команд.

1. BUILD_ROOT: Это отдельная директория для каждой сборочной команды. Система гарантирует, что в неё будут помещены результаты сборки всех зависимостей, известных системе сборки.
2. SOURCE_ROOT: Обычно это одна директория на все команды, указывающая на корень проекта (Аркадии). Однако, в специальном режиме строгого контроля зависимостей (--sandboxing), доступ к файлам в этой директории ограничен только теми файлами, зависимость от которых известна системе сборки.

#### Герметичность сборки

Герметичность означает зависимость сборки только от данных, известных системе сборки. Это важно для корректного кэширования и воспроизводимости сборочного процесса.

1. Полная информация о зависимостях: Все зависимости от исходного кода должны быть известны системе сборки. Команды не должны зависеть от отдельных файлов на локальной системе или внешних систем, не зафиксированных в конфигурации сборки.
2. Использование хранилища Sandbox: Все необходимые бинарные данные загружаются из хранилища Sandbox, что исключает возможность изменения данных для конкретной ревизии.
3. Строгий контроль зависимостей: Включается флагом --sandboxing. Этот режим запрещает доступ к не известным системе сборки файлам во время исполнения.

> Важно: Не все проекты могут быть собраны в режиме строгого контроля зависимостей. Некоторым проектам необходимо разрешение из комитета поддержки devtools.

#### Воспроизводимость сборки

Если сборка герметична, то при фиксированном состоянии репозитория и заданных конфигурационных параметрах результаты будут воспроизводимы. Это обеспечивает следующие преимущества:

1. Репродуктивность проблем из CI: Любые проблемы, возникшие в CI, можно воспроизвести локально.
2. Обратная совместимость: Бинарный код может быть пересобран заново при необходимости отката или восстановления утерянных результатов, используя состояние репозитория.
3. Экономия ресурсов на кластере: Нет необходимости иметь серверы под разные ОС в кластере распределённой сборки. Например, сборка на Linux под Windows будет такой же функционально, как и на “родной” платформе.

#### Заключение

Исполнение сборки в системе ya make ориентировано на максимальную производительность и точность за счет использования UID, кэширования и герметичности. Понимание процесса исполнения позволяет оптимизировать сборочный процесс, обеспечить его воспроизводимость и сделать управление зависимостями прозрачным и эффективным

### Описание сборки

#### Введение

Процесс сборки в системе ya make описывается в специальных файлах с именем ya.make. Эти файлы размещаются рядом с кодом и содержат все необходимые инструкции и параметры для выполнения сборочного процесса. Описание в этих файлах является высокоуровневым и базируется на использовании различных макросов и модулей.

#### Структура файла ya.make

Файл ya.make состоит из набора макросов, каждый из которых выполняет специфические функции. Они делятся на несколько категорий:

1. Собственно сборочные макросы: например, SRCS для указания исходных кодов, PEERDIR для указания сборочных зависимостей.
2. Макросы интерпретации: например, IF, INCLUDE для условий и включений.
3. Макросы свойств сборки: например, SET(), GRPC().
4. Макросы определения целей: например, RECURSE.
5. Макросы для внешних систем: например, SUBSCRIBER.

### Макросы

Макросы используются для управления сборочным процессом и имеют разные задачи:
- Описание сборки кода: включают такие макросы, как SRCS и PEERDIR, которые указывают на исходные коды и межмодульные зависимости.
- Контроль интерпретации: макросы IF и INCLUDE, которые позволяют управлять логикой интерпретации файла ya.make.
- Свойства сборки: макросы типа SET() или GRPC() позволяют задавать параметры сборки и влиять на работу других макросов.
- Определение сборочных целей: макрос RECURSE позволяет включать другие сборочные цели в процесс сборки.
- Фиксация свойств: макросы типа SUBSCRIBER позволяют фиксировать свойства сборки для внешних систем.

### Модули

Модули — это специальные макросы, которые определяют сборочную цель. В каждом файле ya.make может быть определён не более одного модуля, что позволяет однозначно идентифицировать модуль с помощью директории.

#### Свойства модулей

- Модульные макросы: макросы между началом модуля и END() описывают сборку для конкретного модуля.
- Единственность: макросы, описывающие сборку, нельзя писать вне модуля.
- Автоматическая сборка: при сборке директории будет собираться модуль, описанный в её ya.make.
- Ошибка при отсутствии модуля: если модуль отсутствует в ya.make, это приведет к ошибке при попытке сборки или зависимостей.

#### Именование артефактов

Имя артефакта, создаваемого модулем, можно задать первым опциональным аргументом модуля. Это имя будет дополнено префиксом и суффиксом, зависящими от конкретного модуля и платформы. Например:

- Для статической библиотеки на C++ на Linux, будет добавлен префикс lib и суффикс .a.
- Для Windows, будет добавлен суффикс .lib.
- Для Java-библиотеки, суффикс .jar.

Если имя не указано, оно будет сконструировано на основе пути к модулю в проекте (Аркадии).

### Пример интерпретации ya.make

Примерный процесс интерпретации файла ya.make выглядит следующим образом:

1. Чтение и формирование свойств модуля.
2. Рекурсивное формирование свойств для зависимостей модуля.
3. Расширение свойств модуля глобальными свойствами.
4. Формирование графа сборки модуля.
5. Создание команд для сборки всех необходимых компонентов модуля.

### Мультимодули

Некоторые модули могут вести себя по-разному в зависимости от контекста использования. Такие модули называются мультимодулями. Например:
- PROTO_LIBRARY может иметь варианты для нескольких языков программирования (C++, Python, Java и т.д.).
- PY23_LIBRARY может быть совместима как с Python 2, так и с Python 3, и выбор варианта зависит от контекста.

> Совет: При непосредственной сборке мультимодуля будут построены все его варианты. При сборке по PEERDIR только те вариации, которые требуются этими зависимостями.

### Зависимости

#### Виды зависимостей

Для понимания, какие изменения требуют пересборки, система сборки разделяет зависимости на три основных вида:

1. Межмодульные зависимости: такие как PEERDIR — для сборки других целей, DEPENDS — для тестов, и BUNDLE — для интеграции результатов сборки.
2. Файловые зависимости: зависимостями на уровне файлов, включая явные и индуцированные зависимости.
3. Модульные зависимости от файлов: например, DATA() для тестовых данных.

### Заключение

Файлы ya.make служат основой для описания и управления процессом сборки в системе ya make. Понимание структуры и функционала макросов и модулей позволяет эффективно разрабатывать и поддерживать сборочные скрипты, обеспечивая корректную и воспроизводимую сборку проектов.
