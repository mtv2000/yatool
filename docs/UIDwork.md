Переписать полностью

https://docs.yandex-team.ru/ya-make/general/how_it_works#content_uids

Шаг 1. Построение графа зависимостей (ymake)
После того, как конфигурация прочитана, система сборки начинает строить граф зависимостей. Зачитывая файлы ya.make. Процесс начинается с непосредственных сборочных целей и продолжается по зависимостям, найденным в ya.make или исходных файлах.

Работает это примерно так:

Зачитывается и интерпретируется ya.make файл в директории сборочной цели.
Все связанные (по RECURSE ya.make добавляются в очередь.
Если ya.make содержит описание сборки модуля, то выясняются свойства его сборки и зависимости.
Зачитываются и интерпретируются ya.make зависимостей, RECURSE-связи от них игнорируются.
Процесс 3-4 идёт рекурсивно пока не достигнет модуля без зависимостей, пройденные модули запоминаются в стек.
Если есть зависимые модули - их глобальные свойства применяются. Анализируются зависимости модуля от файлов, формируются команды модуля. Здесь же анализируются файлы на наличие кросс-файловых зависимостей
Глобальные свойства модуля фиксируются для распространения.
Повторяются шаги 3.4 пока не пройдены все зависимости, потом шаги 6,7.
При достижении дна стека берётся следующий ya.make из очереди. который ещё не обрабатывали (в обходе по зависимостям). Начальный модуль и модули из очереди называются стартовыми.
Когда очередь исчерпана построен Граф зависимостей.
Граф зависимостей:

Отражает информацию в формате близком к описанию сборки. Это позволяет кэшировать и редактировать граф при изменениях.
Быстро строится в ущерб точности. В отличие от реального препроцессирования ymake парсит хедеры и строит зависимости между хедерами. Это позволяет избежать дублирования работы в препроцессинге .cpp-файлов: каждый хедер читается ровно один раз. Аналогично строятся зависимости по PEERDIR между библиотеками: они отражают описание в ya.make-файлах, а не реальную зависимость программ от библиотек.
Относительно компактный граф. За счёт глубины/высоты графа транзитивные связи не дублируются; команды представлены графом, где общие части объединены. Имена файлов и директорий дедуплицированы.
Ключами узлов являются имена (файлов, артефактов, модулей, директорий, команд и т.п.). Когда простого имени недостаточно может использоваться ID модуля как часть имени (в свойствах и командах).
Наша система сборки строит граф зависимостей в основном за один проход DFS от целей к листьям. При этом межмодульные зависимости (PEERDIR) имеют приоритет в обходе по модулям. Каждая дуга посещается один раз, а из посещений вершин по разным путям бОльшая часть работы делается в момент первого посещения. В рамках этого единственного прохода мы делаем и зачитывание ya.make-файлов и парсинг зависимостей из исходных файлов и разрешение зависимостей: выяснение реальных файлов, стоящих за именами в include/import/...).

Нынешний алгоритм построения графа зависимостей

Позволяет относительно надёжно распространять конфигурационные параметры со своих зависимостей на собственные узлы модуля.
Не позволяет распространять конфигурационные параметры из с одних зависимостей на другие. Свойства модуля распространяются на обработку файлов модуля и его команды, глобальные свойства распространяются с модуля на всех, кто от него зависит. Изменить из модуля свойства его зависимостей нельзя, поскольку несколько модулей могло бы попытаться сделать это по-разному для одной и той же зависимости, что привело бы к дроблению конфигураций для неё, т.е. системе сборки пришлось бы строить эту зависимость в нескольких разных конфигурациях, в пределе - по числу использований.
Зависеть от свойств модуля могут любые узлы (команды, файлы и модули), однако структура графа не позволяет обрабатывать один файл в разных контекстах: каждый файл в графе представлен одной вершиной, а единственный проход по дуге не даёт возможности обрабатывать одну вершину несколько раз. Кроме того, фиксация обработки в виде дополнительных дуг не позволяет эффективно разметить результаты обработки в разных контекстах. Чтобы обойти это ограничение, в представлении имён файлов в графе предусмотрены ссылки — специальные модифицированные имена, содержащие дополнительно указание на контекст. Поскольку у такого имени отдельный узел в графе, его можно отдельно обработать и при необходимости зафиксировать результат исходящими дугами.
dep_graph

Совет

Посмотреть как выглядит граф зависимостей для определённой сборочной цели можно командой ya dump dep-graph <target>

После того, как граф построен на нём делается ряд вычислений дополнительными обходами. Они включают:

Вывод диагностики. В определённых случаях мы не можем сконфигурировать только то, что нужно и конфигурируем с запасом. Чтобы это не было заметно ошибки конфигурирования при построении кэшируются и выводятся только для того, что точно будет нужно в сборке запрошенных целей.
Транзитивные проверки — лицензии, PROVIDES, CHECK_DEPENDENT_DIRS и т.п.
Управление зависимостями для Java.
Проверки include без PEERDIR, вывод и вырезание циклов по зависимостям.
Сбор транзитивной информации для подстановки в команды (PEERS, GLOBAL_SRCS и т.п.).
Шаг 2. Построение графа сборочных команд (ymake->ya)
После того, как граф зависимостей полностью построен и проанализировал его можно превращать в граф сборочных команд. Для этого мы сначала отдельным проходом строим UID-ы (уникальные идентификаторы узлов с учётом зависимостей) на основе графа зависимостей, а потом, собственно, строим граф команд.

Граф сборочных команд

Отражает реальные зависимости между сборочными командами.
Каждый узел в графе — это команда или набор команд, исполняющиеся вместе (с общими входами, выходами и зависимостями).
Каждая команда идентифицируется уникальным идентификатором (UID), который является хешем от текста команды, всех её входов (включая неявные) и всех зависимостей. UID ассоциирован с результатом работы команды: неизменность UID означает неизменность результатов команды. Изменение означает возможное (но не обязательное) изменение результатов.
Зависимость (дуга) в графе означают, что команда на исходящем конце дуги зависит от результатов команды на входящем конце. Дуги фиксируются перечислением UID-ов зависимостей.
В графе перечислением UID-ов зафиксированы результаты или стартовые команды — это команды, порождающие результаты сборки.
В графе полностью утрачена информация о модулях и описании сборки. Информация о хедерах зачтена в UID-ы, сами хедеры в явном виде в графе не присутствуют кроме случаев, когда они являются результатами команд генерации либо при явном включении всех зависимостей в граф с целью изолированного исполнения команд.
Граф гораздо более плоский: зависимости транзитивно замкнуты в финальных целях (или там, где нужны).
Граф сериализуется в JSON и таким образом может быть создан на одной машине, а исполнен на другой и даже на кластере распределённой сборки.
Из-за существенного дублирования более бедный граф по размерам сопоставим с внутренним. Внешнее представление (JSON) гораздо больше.
Для ускорения построения графа внедрено отдельное кэширование на основе UID-ов (полное переиспользование) и RenderID (ускорение рендеринга текста команд). RenderID - это хэш от предполагаемого текста узла, позволяющий получить узел без перерендеринга, только апдейтом UID-ов зависимостей и другой вспомогательной информации в узле.
Кроме собственно графовой информации (узлов команд и списка результатов) граф содержит глобальную информацию: ресурсы, доступные всем командам; информацию для исполнителей и т.п.
cmd_graph

Каждый анализатор зависимостей ymake строит граф команд для одной платформы/конфигурации и отдаёт их в виде JSON в ya make.

Совет

Посмотреть как выглядит граф сборочных команд для определённой сборочной цели можно командой ya dump build-plan <target> или ya make -G -j0 <target>.

К данному моменту у нас есть граф сборочных команд для одной целевой платформы. От платформы зависят как минимум стадии 1., 3. (ya.make может содержать условные конструкции) и стадия 6 (формирование свойств и команд зависит от платформы) построения сборочного графа. Однако, граф сборочных команд может содержать команды сборки сборочных инструментов, а их надо сформировать для сборочной платформы.
Шаг 3. Склейка, очистка, обогащение и ещё раз склейка (ya)
В графе команд для целевой платформы есть узлы соответствующие вызовам сборочных инструментов. Эти узлы обнаруживаются и для них запускается отдельный анализ зависимостей (Шаги 1. и 2.) для сборочной платформы. После этого несколько графов команд склеиваются в один сборочный граф, где правильно представлены узлы для целевой и сборочной платформ. Для Linux такой граф получается склейкой не двух, а 4х графов поскольку отдельно строятся графы для PIC и non-PIC вариантов целевой и сборочной конфигураций.

Примечание

Наличие этой части связано с тем, что ymake не умеет строить кроссплатформенные и мульти-платформенные графы. Добавление в него соответствующих возможностей — это одно из направлений развития.

Отдельно в граф прямо кодом в ya добавляются узлы запуска тестов. Они строятся на основе информации, собранной в запусках ymake и переданной через вспомогательные файлы в соответствующие части ya make, а также, собственно, графа команд. Файлы ya.make при этом не читаются, но могут читаться файлы, необходимые для запуска тестов, чтобы правильно рассчитать UID-ы для создаваемых узлов.

Примечание

Наличие этой части — это печальное легаси. Постепенно соответствующие возможности должны переноситься в ymake.

Чтобы тесты были исполнены, они добавляютмя к результатвм графа. Если запрошена опция --add-result, то к результатам добавляются запрошенные промежуточные результаты.

После окончания обогащения графа лишние узлы удаляются.

При построении одним вызовом ya make кода для нескольких целевых платформ, финальные графе для разных платформ ещё раз склеиваются.

На данном этапе у нас есть полностью готовый граф команд и его можно исполнять.
Шаг 4. Вычитание (опционально, автосборка)
В автоматических CI-проверках строится два результирующих графа условно "c изменениями" и "без изменений". Эти графы специальным образом вычитаются для удаления не изменившихся узлов. В разности остаётся только те узлы, что UID-ы которых изменились и то, от чего эти узлы зависят. Последние остаются, чтобы граф был замкнут, т.е. по нему можно было построить все описанные в нём узлы без привлечения кэшей.

Измененная часть специально помечена и только её результаты попадают в результаты проверки. Это позволяет сократить объём графа на исполнении и гарантированно не строить то, что 'не задето'.

Шаг 5. Исполнение сборки
Исполнение сборки в ya make очень простое. Начиная от входов в граф команд (результатов сборки) выполняется такая рекурсивная процедура:

Если для UID команды её результат исполнения есть в кэше — он возвращается.
Если нет - повторить начиная с п.1. для зависимостей команды.
Выполнить команду и закэшировать результат её исполнения по UID.
Шаги 1-3. могут делаться параллельно для независимых команд.
Процесс заканчивается, когда результаты построены.
exec

Сборка исполняет свои команды в специальных сборочных директориях, каждую команду в своей. Это обеспечивает изоляцию. Перед исполнением команды в сборочную директорию переносятся результаты сборки её зависимостей. Необходимые файлы из репозитория не переносятся, по умолчанию каждая команда имеет доступ ко всему репозиторию. Однако в специальном режиме строгого контроля зависимостей (задаётся ключом --sandboxing) система сборки даёт доступ только до файлов в репозитории, зависимость от которых известна системе сборки. Это позволяет проверять герметичность сборки.

Полученные там результаты попадают в отдельные директории сборочного кэша, а также выборочно становятся результатами сборки - символическими ссылками в рабочей копии и файлами в выходной директории, если указана опция --output. При распределённой сборке если указано скачивание результатов, то скачиваются только результаты сборки, а не всё, что было построено.

Внимание

Очень важно понимать, что сборка не оперирует собранными файлами (символическими ссылками) в рабочей копии, они туда попадают после того, как сборка завершилась. Более того, можно полностью отключить доставку результатов опцией --no-srcs-links или перенаправить их в отдельную директорию опцией --output. Это никак не повляет на исполнение сборки. Ровно также на неё не влияют опции вида --add-result .h и т.п. Нельзя рассчитывать на взаимное расположение результатов в рабочей копии во время сборки, каждый сборочный узел исполняется в своей директории и имеет доступ к другим сборочным артефактам только если он от них зависит. Исходные файлы расположены в другом дереве и нельзя рассчитывать что дерево исходных и генерируемых файлов совпадают. В частности если в исходном cpp-файле написано #include "generated.h", сгенерированный хедер не окажется во время сборки рядом с исходным, даже если указать --add-result .h. Он окажется в сборочной директории узла компиляции поскольку система сборки обнаружит зависимость через include и переложит его из сборочного дерева команды генерации. Однако, он не будет найден обычным для #include "some_file.h" способом без ADDINCL(${BINDIR}) поскольку сборочные деревья команд и дерево исходных файлов все различны.

Так устроено исполнение как локальное, так и на кластере распределённой сборки. Отличаются только детали — устройство планировщика, устройство кэша, предоставление репозитория и т.п.

Граф может быть отдельно создан и отдельно исполнен. Например, при локальной сборке на кластере распределённой сборки ya make --dist шаги 0.-3. исполняются локально на машине пользователя, построенный граф, а также все необходимые файлы отправляются на кластер и исполнение графа (шаг 5.) делается уже там.

Сборка с контентными UIDами
В режиме --content-uids (используется в локальной сборке по умолчанию) работа системы сборки меняется следующим образом:

На 2м шаге система сборки рассчитывает собственный UID каждой команды - в него засчитываются всё что и в обычный, кроме UID-ов зависимых команд.

Исполнение сборки тоже немного усложняется:

Если для UID команды её результат исполнения есть в кэше — он возвращается.
Если нет - повторить начиная с п.1. для зависимостей команды.
Для каждой из зависимостей посчитать хэш от результатов. Собрать общий Контентный UID из этих хэшей и собстсвенного UID команды.
Если для контентного UID есть результат, закэшировать его по UID и вернуть.
Иначе выполнить команду и закэшировать результат её исполнения по UID и Контентному UID.
В результате незначащие изменения в зависимостях не приводят к перезапуску всех тренизитивно зависящих команд.

Ограничения

Эффективность работы такого режима сборки ограничена бинарной воспроизводимостью результатов команд. Известно, что бинарной воспроизводимости совсем нет для java и для команд, порождающих .tar - там в артефакты внедляются времена. В целом бинарная воспроизводимость - это хорошее свойство, к которому надо стремиться.
Поскольку мы оперируем результатами узла как единым целым, то хэш рассчитывается один на все результаты команды. Если у команды результатов много, а меняется только один это повляет на все команды-потребители, даже если они реально не используют изменившийся результат. Решать эту проблему можно введением промежуточных легковесных узлов (напр. move), передающих в зависящие команды только нужные аутупуты. Сами узлы будут перезапускаться на любые изменения в результатах генерации, но это дёшево по сравнению с реальными командами компиляции.
Совет

Отключить режим можно удалением настройки или разово ключом --no-content-uids или добавив content_uids = false в свой ya.conf. Однако, в случае проблем может потребоваться полная пересборка с удалением кэша или --rebuild.
