
# Как строится и исполняется сборочный граф

## Базовая модель

Наша система сборки основывается на модели, где все зависимости известны заранее, что подразумевает использование полностью статического графа зависимостей. Unique ID (UID) каждой сборочной команды также рассчитываются заранее на основе зависимостей и остаются неизменными на протяжении всего процесса сборки.

## Процесс построения и исполнения сборочного графа

Команда `ya make` сейчас работает так:

*  Для построения сборочного графа несколько раз запускается анализатор зависимостей ymake. Он умеет анализировать зависимости и строить граф команд ровно для одной конфигурации. Соответственно, он запускается отдельно (параллельно) для PIC и non-PIC вариантов целевой конфигурации (для Linux, для других платформ в этом месте один запуск). Потом он отдельно запускается для целевой платформы (tools) только для частей доступным по зависимостям вида "результат"->"генератор"
*  Выходные графы ymake склеиваются
*  Графы обогащаются, например, сборкой документации, запуском тестов или заливкой результатов индексирования кодонавигации в YT.
*  Если заказано несколько целевых платформ или конфигураций, то все действия выше делаются для каждой из них. И в конце все графы склеиваются в один.
* В автосборке мы строим два графа по описанным выше шагам для состояний "было" и "стало". После этого мы вычитаем графы на основе UID-ов, и замыкаем их.
*  Полученный граф исполняется локальным или распределённым исполнителем.
Посмотрим подробнее на все этапы построения и исполнения сборочного графа

### Шаг 0: Подготовка и загрузка конфигурации системы сборки (ya -> yamake)

1. Настройка конфигурации: Процесс сборки начинается с генерации конфигурационного файла системы сборки, который включает:
- Содержимое build/yamake.core.conf;
- Настройки, зависящие от системы, и динамическую часть настроек, генерируемых build/yamake_conf.py;
- Конфигурационные параметры командной строки (например, -D, --target-platform-flags, --musl).

2. Конфигурационный файл: Файл содержит описание макросов и модулей, используемых в системе сборки. Расширения на Python или C++ исполняются во время конфигурирования. Файл генерируется на декларативном языке, описывающем:
- Макросы и модули;
- Шаблоны команд;
- Граф зависимостей команд;
- Правила вычисления переменных и привязки команд к файлам.

3. Запуск анализатора зависимостей: yamake запускается несколько раз для разных конфигураций, создавая отдельные файлы для каждой конфигурации, после чего готов к анализу зависимостей.

### Шаг 1: Построение графа зависимостей (yamake)

1. Чтение конфигурации: После загрузки конфигурации система начинает строить граф зависимостей, зачитывая файлы ya.make.

2. Анализ зависимостей: Система зачитывает ya.make файлы из директорий сборочных целей и их зависимостей, формируя команды и анализируя межфайловые зависимости:
- Начальная цель зачитывается из ya.make;
- Рекурсивно добавляются связанные файлы;
- Свойства сборки и зависимости модулей анализируются и фиксируются.

3. Построение графа: Система строит граф зависимостей в формате, удобном для кэширования и редактирования:
- Узлы обозначаются именами файлов, артефактов и команд;
- Свойства модулей распространяются, но не могут менять конфигурацию других модулей.

4. Дополнительные вычисления на графе: После построения графа выполняются дополнительные обходы для:
- Вывода диагностики;
- Проверок лицензий;
- Управления зависимостями для Java;
- Сборки транзитивной информации для команд.

### Шаг 2: Построение графа сборочных команд (yamake -> ya)

1. Создание UID: На основе графа зависимостей генерируются уникальные идентификаторы узлов.

2. Формирование графа команд: Построенный граф команд отражает реальные зависимости между командами:
- Каждая команда идентифицируется уникальным идентификатором (UID), что позволяет фиксировать результаты команд и обеспечивать неизменность.
- Граф сериализуется в формат JSON для возможного переноса между разными машинами или кластерами.

### Шаг 3: Склейка, очистка, обогащение и окончательная склейка (ya)

1. Склейка графов: Графы команд для различных конфигураций склеиваются в один объединённый граф:
- Для Linux склеиваются графы PIC и non-PIC вариантов.
- Встраиваются узлы для запуска тестов на основе информации из графа команд.

### Шаг 4: Вычитание (опционально, автосборка)

1. Построение графов для CI: В автоматических CI-проверках строятся два графа: с изменениями и без.
- Графы вычитаются, сохраняя изменённые узлы и их зависимости для оптимизации исполнения.

### Шаг 5: Исполнение сборки

1. Процесс исполнения:
- Если результат команды есть в кэше, он используется.
- В противном случае выполняются команды и результаты кэшируются.
- Сборка исполняется в изолированных директориях, обеспечивая герметичность процесса.

2. Доставка результатов: Результаты команд переносятся в сборочные директории, а после завершения сборки — в рабочую копию или выходную директорию.

### Сборка с контентными UID-ами

1. Оптимизация по контенту: В режиме --content-uids UID команды включает хэши зависимых команд:
- Изменения в зависимостях не приводят к перезапуску всех зависимых команд, если их результаты не изменились.

2. Ограничения: Эффективность зависит от бинарной воспроизводимости результатов команд.

### Заключение

Этот процесс обеспечивает эффективное построение и управление сложными графами зависимостей, поддерживая модульность и оптимизируя повторное использование результатов в средах CI
