
# Как строится и исполняется сборочный граф

## Базовая модель

Наша система сборки основывается на модели, где все зависимости известны заранее, что подразумевает использование полностью статического графа зависимостей. Unique ID (UID) каждой сборочной команды также рассчитываются заранее на основе зависимостей и остаются неизменными на протяжении всего процесса сборки.

## Процесс построения и исполнения сборочного графа

Команда ya make выполняет свою работу следующим образом:

1. Анализ зависимостей: Анализатор зависимостей ymake запускается несколько раз для построения сборочного графа. Он может анализировать зависимости и строить граф команд только для одной конфигурации. Поэтому `ya make` запускается отдельно для вариантов PIC и non-PIC (в случае Linux, для других платформ достаточно одного запуска). Затем он отдельно запускается для целевой платформы (tools), анализируя зависимости типа “результат” -> “генератор”.
2. Склейка графов: Графы, созданные `ya make`, объединяются в один.
3. Обогащение графов: Графы дополняются дополнительными задачами, такими как сборка документации, запуск тестов и загрузка результатов индексирования кода в кэш.
4. Множественные платформы и конфигурации: Если для сборки требуется несколько целевых платформ или конфигураций, шаги 1-3 повторяются для каждой из них, и в конце все графы объединяются в один общий граф.
5. Автосборка: Для автосборки строятся два графа: один для текущего состояния (“было”), другой для состояния с изменениями (“стало”). Затем графы сравниваются и вычитаются на основе UID-ов, создавая финальный граф.
6. Исполнение: Окончательный граф исполняется локальным или распределённым исполнителем.

### Шаг 0: Подготовка и загрузка конфигурации системы сборки (ya -> yamake)

1. Настройка конфигурации: Процесс сборки начинается с генерации конфигурационного файла системы сборки, который включает:
- Содержимое build/yamake.core.conf;
- Настройки, зависящие от системы, и динамическую часть настроек, генерируемых build/yamake_conf.py;
- Конфигурационные параметры командной строки (например, -D, --target-platform-flags, --musl).

2. Конфигурационный файл: Файл содержит описание макросов и модулей, используемых в системе сборки. Расширения на Python или C++ исполняются во время конфигурирования. Файл генерируется на декларативном языке, описывающем:
- Макросы и модули;
- Шаблоны команд;
- Граф зависимостей команд;
- Правила вычисления переменных и привязки команд к файлам.

3. Запуск анализатора зависимостей: `ya make` запускается несколько раз для разных конфигураций, создавая отдельные файлы для каждой конфигурации, после чего готов к анализу зависимостей.

### Шаг 1: Построение графа зависимостей (`ya make`)
`
1. Чтение конфигурации: 

После загрузки конфигурации система начинает строить граф зависимостей, зачитывая файлы ya.make.

Наша система сборки строит граф зависимостей в основном за один проход DFS от целей к листьям. При этом межмодульные зависимости (PEERDIR) имеют приоритет в обходе по модулям. Каждая дуга посещается один раз, а из посещений вершин по разным путям бОльшая часть работы делается в момент первого посещения. В рамках этого единственного прохода мы делаем и зачитывание ya.make-файлов и парсинг зависимостей из исходных файлов и разрешение зависимостей: выяснение реальных файлов, стоящих за именами в include/import/...).

2. Анализ зависимостей: 

Система зачитывает ya.make файлы из директорий сборочных целей и их зависимостей, формируя команды и анализируя межфайловые зависимости:
  1. Сборочная цель зачитывается из ya.make;
  2. Рекурсивно по `RECURSE` в очередь добавляются связанные файлы;
  3. Свойства сборки и зависимости модулей анализируются и фиксируются.
  4. Зачитываются и интерпретируются ya.make зависимостей, RECURSE-связи от них игнорируются.
  5. Процесс 3-4 идёт рекурсивно пока не достигнет модуля без зависимостей, пройденные модули запоминаются в стек.
  6. Если есть зависимые модули - их глобальные свойства применяются. Анализируются зависимости модуля от файлов, формируются команды модуля. Здесь же анализируются файлы на наличие кросс-файловых зависимостей
  7. Глобальные свойства модуля фиксируются для распространения.
  8. Повторяются шаги 3.4 пока не пройдены все зависимости, потом шаги 6,7.
  9. При достижении дна стека берётся следующий ya.make из очереди. который ещё не обрабатывали (в обходе по зависимостям). Начальный модуль и модули из очереди называются стартовыми.

3. Построение графа:Когда очередь исчерпана построен Граф зависимостей.

Система строит граф зависимостей в формате близком к описанию сборки, удобном для кэширования и редактирования:
  - Узлы обозначаются именами файлов, модулей, директорий, команд и т.п.. Когда простого имени недостаточно может использоваться ID модуля как часть имени (в свойствах и командах).
  - Не позволяет распространять конфигурационные параметры из с одних зависимостей на другие. Свойства модуля распространяются на обработку файлов модуля и его команды, глобальные свойства распространяются с модуля на всех, кто от него зависит. Изменить из модуля свойства его зависимостей нельзя.
  - Зависеть от свойств модуля могут любые узлы (команды, файлы и модули), однако структура графа не позволяет обрабатывать один файл в разных контекстах: каждый файл в графе представлен одной вершиной, а единственный проход по дуге не даёт возможности обрабатывать одну вершину несколько раз.

4. Дополнительные вычисления на графе:

После построения графа выполняются дополнительные обходы для:
- Вывода диагностики.
- Проверок лицензий, `PROVIDES`, `CHECK_DEPENDENT_DIRS` и т.п.
- Управления зависимостями для `Java`;
- Сборки транзитивной информации для команд (`PEERS`, `GLOBAL_SRCS` и т.п.).

Посмотреть как выглядит граф зависимостей для определённой сборочной цели можно командой `ya dump dep-graph <target>`

### Шаг 2: Построение графа сборочных команд (yamake -> ya)

1. Создание UID: На основе графа зависимостей генерируются уникальные идентификаторы узлов.

Каждый узел в графе — это команда или набор команд, исполняющиеся вместе (с общими входами, выходами и зависимостями).

2. Формирование графа команд:

Построенный граф команд отражает реальные зависимости между командами:  
  - Каждая команда идентифицируется уникальным идентификатором (UID), что позволяет фиксировать результаты команд и обеспечивать неизменность.
  - Зависимость (дуга) в графе означают, что команда на исходящем конце дуги зависит от результатов команды на входящем конце. Дуги фиксируются перечислением UID-ов зависимостей.
  - В графе перечислением UID-ов зафиксированы результаты или стартовые команды — это команды, порождающие результаты сборки.
  - В графе полностью утрачена информация о модулях и описании сборки. Информация о хедерах зачтена в UID-ы, сами хедеры в явном виде в графе не присутствуют кроме случаев, когда они являются результатами команд генерации либо при явном включении всех зависимостей в граф с целью изолированного исполнения команд.
  - Граф сериализуется в формат JSON для возможного переноса между разными машинами или кластерами.
  - Для ускорения построения графа внедрено отдельное кэширование на основе UID-ов (полное переиспользование) и RenderID (ускорение рендеринга текста команд). RenderID - это хэш от предполагаемого текста узла, позволяющий получить узел без необходимости повторного рендеринга, только обновлением UID-ов зависимостей и другой вспомогательной информации в узле.
  - Кроме собственно графовой информации (узлов команд и списка результатов) граф содержит глобальную информацию: ресурсы, доступные всем командам; информацию для исполнителей и т.п.

Посмотреть как выглядит граф сборочных команд для определённой сборочной цели можно командой `ya dump build-plan <target>` или `ya make -G -j0 <target>`.

### Шаг 3: Склейка, очистка, обогащение и окончательная склейка (ya)

Графы команд для различных конфигураций склеиваются в один объединённый граф:
  - В графе команд для целевой платформы есть узлы соответствующие вызовам сборочных инструментов. Эти узлы обнаруживаются и для них запускается отдельный анализ зависимостей (Шаги 1. и 2.) для сборочной платформы. После этого несколько графов команд склеиваются в один сборочный граф, где правильно представлены узлы для целевой и сборочной платформ.
Для Linux дополнительно склеиваются графы PIC и non-PIC вариантов.
  - Встраиваются узлы для запуска тестов на основе информации из графа команд. Чтобы тесты были исполнены, они добавляютмя к результатвм графа.
  - После окончания обогащения графа лишние узлы удаляются.

### Шаг 4: Вычитание (опционально, автосборка)

В автоматических CI-проверках строятся два графа: с изменениями и без.
  - Графы вычитаются, сохраняя изменённые узлы и их зависимости для оптимизации исполнения.
  - Это уменьшает объём графа во время исполнения и гарантирует, что не будут перестраиваться те части, которых изменения не коснулись.

### Шаг 5: Исполнение сборки

1. Процесс исполнения:
- Если результат команды есть в кэше, он используется.
- В противном случае выполняются команды и результаты кэшируются.
- Сборка исполняется в изолированных директориях, обеспечивая герметичность процесса.

2. Доставка результатов: Результаты команд переносятся в сборочные директории, а после завершения сборки — в рабочую копию или выходную директорию.

### Сборка с контентными UID-ами

1. Оптимизация по контенту: В режиме --content-uids UID команды включает хэши зависимых команд:
- Изменения в зависимостях не приводят к перезапуску всех зависимых команд, если их результаты не изменились.

2. Ограничения: Эффективность зависит от бинарной воспроизводимости результатов команд.

### Заключение

Этот процесс обеспечивает эффективное построение и управление сложными графами зависимостей, поддерживая модульность и оптимизируя повторное использование результатов в средах CI
