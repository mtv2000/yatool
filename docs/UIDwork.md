
# Как строится и исполняется сборочный граф

## Базовая модель

Наша система сборки основывается на модели, где все зависимости известны заранее, что подразумевает использование полностью статического графа зависимостей. Unique ID (UID) каждой сборочной команды также рассчитываются заранее на основе зависимостей и остаются неизменными на протяжении всего процесса сборки.

## Процесс построения и исполнения сборочного графа

Команда ya make выполняет свою работу следующим образом:

1. Анализ зависимостей: Анализатор зависимостей ymake запускается несколько раз для построения сборочного графа. Он может анализировать зависимости и строить граф команд только для одной конфигурации. Поэтому `ya make` запускается отдельно для вариантов PIC и non-PIC (в случае Linux, для других платформ достаточно одного запуска). Затем он отдельно запускается для целевой платформы (tools), анализируя зависимости типа “результат” -> “генератор”.
2. Склейка графов: Графы, созданные `ya make`, объединяются в один.
3. Обогащение графов: Графы дополняются дополнительными задачами, такими как сборка документации, запуск тестов и загрузка результатов индексирования кода в кэш.
4. Множественные платформы и конфигурации: Если для сборки требуется несколько целевых платформ или конфигураций, шаги 1-3 повторяются для каждой из них, и в конце все графы объединяются в один общий граф.
5. Автосборка: Для автосборки строятся два графа: один для текущего состояния (“было”), другой для состояния с изменениями (“стало”). Затем графы сравниваются и вычитаются на основе UID-ов, создавая финальный граф.
6. Исполнение: Окончательный граф исполняется локальным или распределённым исполнителем.

### Шаг 0: Подготовка и загрузка конфигурации системы сборки (ya -> yamake)

1. Настройка конфигурации: Процесс сборки начинается с генерации конфигурационного файла системы сборки, который включает:
- Содержимое build/yamake.core.conf;
- Настройки, зависящие от системы, и динамическую часть настроек, генерируемых build/yamake_conf.py;
- Конфигурационные параметры командной строки (например, -D, --target-platform-flags, --musl).

2. Конфигурационный файл: Файл содержит описание макросов и модулей, используемых в системе сборки. Расширения на Python или C++ исполняются во время конфигурирования. Файл генерируется на декларативном языке, описывающем:
- Макросы и модули;
- Шаблоны команд;
- Граф зависимостей команд;
- Правила вычисления переменных и привязки команд к файлам.

3. Запуск анализатора зависимостей: `ya make` запускается несколько раз для разных конфигураций, создавая отдельные файлы для каждой конфигурации, после чего готов к анализу зависимостей.

### Шаг 1: Построение графа зависимостей (`ya make`)
`
1. Чтение конфигурации: После загрузки конфигурации система начинает строить граф зависимостей, зачитывая файлы ya.make.

2. Анализ зависимостей: Система зачитывает ya.make файлы из директорий сборочных целей и их зависимостей, формируя команды и анализируя межфайловые зависимости:
  1. Сборочная цель зачитывается из ya.make;
  2. Рекурсивно по `RECURSE` в очередь добавляются связанные файлы;
  3. Свойства сборки и зависимости модулей анализируются и фиксируются.
  4. Зачитываются и интерпретируются ya.make зависимостей, RECURSE-связи от них игнорируются.
  5. Процесс 3-4 идёт рекурсивно пока не достигнет модуля без зависимостей, пройденные модули запоминаются в стек.
  6. Если есть зависимые модули - их глобальные свойства применяются. Анализируются зависимости модуля от файлов, формируются команды модуля. Здесь же анализируются файлы на наличие кросс-файловых зависимостей
  7. Глобальные свойства модуля фиксируются для распространения.
  8. Повторяются шаги 3.4 пока не пройдены все зависимости, потом шаги 6,7.
  9. При достижении дна стека берётся следующий ya.make из очереди. который ещё не обрабатывали (в обходе по зависимостям). Начальный модуль и модули из очереди называются стартовыми.

3. Построение графа:Когда очередь исчерпана построен Граф зависимостей.
  - Система строит граф зависимостей в формате близком к описанию сборки, удобном для кэширования и редактирования:
  - Узлы обозначаются именами файлов, модулей, директорий, команд и т.п.. Когда простого имени недостаточно может использоваться ID модуля как часть имени (в свойствах и командах).
  - Свойства модулей распространяются, но не могут менять конфигурацию других модулей.

4. Дополнительные вычисления на графе: После построения графа выполняются дополнительные обходы для:
- Вывода диагностики;
- Проверок лицензий;
- Управления зависимостями для Java;
- Сборки транзитивной информации для команд.

Посмотреть как выглядит граф зависимостей для определённой сборочной цели можно командой `ya dump dep-graph <target>`

### Шаг 2: Построение графа сборочных команд (yamake -> ya)

1. Создание UID: На основе графа зависимостей генерируются уникальные идентификаторы узлов.

2. Формирование графа команд: Построенный граф команд отражает реальные зависимости между командами:
- Каждая команда идентифицируется уникальным идентификатором (UID), что позволяет фиксировать результаты команд и обеспечивать неизменность.
- Граф сериализуется в формат JSON для возможного переноса между разными машинами или кластерами.

### Шаг 3: Склейка, очистка, обогащение и окончательная склейка (ya)

1. Склейка графов: Графы команд для различных конфигураций склеиваются в один объединённый граф:
- Для Linux склеиваются графы PIC и non-PIC вариантов.
- Встраиваются узлы для запуска тестов на основе информации из графа команд.

### Шаг 4: Вычитание (опционально, автосборка)

1. Построение графов для CI: В автоматических CI-проверках строятся два графа: с изменениями и без.
- Графы вычитаются, сохраняя изменённые узлы и их зависимости для оптимизации исполнения.

### Шаг 5: Исполнение сборки

1. Процесс исполнения:
- Если результат команды есть в кэше, он используется.
- В противном случае выполняются команды и результаты кэшируются.
- Сборка исполняется в изолированных директориях, обеспечивая герметичность процесса.

2. Доставка результатов: Результаты команд переносятся в сборочные директории, а после завершения сборки — в рабочую копию или выходную директорию.

### Сборка с контентными UID-ами

1. Оптимизация по контенту: В режиме --content-uids UID команды включает хэши зависимых команд:
- Изменения в зависимостях не приводят к перезапуску всех зависимых команд, если их результаты не изменились.

2. Ограничения: Эффективность зависит от бинарной воспроизводимости результатов команд.

### Заключение

Этот процесс обеспечивает эффективное построение и управление сложными графами зависимостей, поддерживая модульность и оптимизируя повторное использование результатов в средах CI
