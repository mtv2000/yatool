# Описание сборки в ya.make

## Что такое описание сборки

Система сборки должна построить из *исходных файлов* на различных языках по определённым *правилам* библиотеки, программы и тесты (*результаты сборки*), и по запросу запустить тесты.
При этом очень желательно, чтобы пересборка была *минимальной* в том смысле, что при внесении изменений перестроилось бы только то, что изменениями *затронуто*.

Поэтому для системы сборки:

- Должны быть описаны правила, по которым исходные файлы превращаются в результаты.
- Так или иначе должна быть предоставлена информация о *зависимостях* разного рода, чтобы система сборки могла обеспечить минимальность.
- Описаны сборочные свойства для тех, кто от цели зависит, с тем, чтобы сборка цели и её зависимостей были согласованы.
- Могут быть указаны дополнительные описательные и/или контролируемые свойства. Примером описательного свойства может быть владелец кода, а контролируемого — лицензия библиотеки.

## Как описывается сборка для ya make { #how }

Описание сборки ya make является модульным, т. е. сборка конкретного результата в общем случае описывается не одним файлом, где перечислены все
его правила сборки и весь необходимый исходный код. Вместо этого код разбивается на *модули* (библиотеки, пакеты и т.п.) и для каждого из них
пишется отдельный файл с описанием. Такое описание включает сборку собственного исходного кода библиотеки или программы и ссылки на описания
сборки для других модулей, от которых зависит библиотека или программа. Описание сборки ya make очень высокоуровневое и в основном декларативное:

- Обычно указываются факты, необходимые для сборки, а не её порядок. Вроде "быть исходным файлом", "использовать флаги для компиляции", "из
 такого входного файла генерируется такой выходной такой командой".

- В ya.make существуют переменные, однако (в отличие от cmake) они должны быть заданы до использования в конструкциях вроде [`IF()/ELSEIF()/ELSE()/ENDIF()`](./syntax.md#if). Использование неинициализированных переменных запрещено.

- Многие факты система сборки умеет выводить из расширений файлов (как исходных, так и промежуточных результатов). Подробнее об этом [ниже](#ext)

Описание сборки для ya make делается в файлах `ya.make`. Поскольку имя файла фиксировано, то в каждой директории может быть только один такой файл.
В качестве цели в команде сборки указывается имя директории с `ya.make`-файлом, и этот файл определяет, какие модули будут собраны в результате выполнения команды.

Все конструкции, которые можно написать в файлах `ya.make`, называются **макросами**. В тексте они выглядят как вызовы функций с параметрами, разделёнными пробелом.
Исторически для их именования используется [SCREAMING_SNAKE_CASE](https://ru.wikipedia.org/wiki/Snake_case).  Кроме макросов есть только комментарии.
В ya.make символом начала комментария является `#`. Комментарий длится до конца строки.

- [`Подробнее про синтаксис ya.make`](./syntax.md)
- [`Подробнее о том, как интерпретируется ya.make`](#interp)

Каждый `ya.make`-файл синтаксически содержит описание сборки не более чем одного **модуля**. Модуль — это библиотека/модуль/пакет, программа, тест или группа сборочных целей
(модули [`PACKAGE`](./package/modules.md#package) и [`UNION`](./package/modules.md#union)). Поскольку один `ya.make` содержит описание сборки не более чем одного модуля, для указания любых зависимостей между модулями,
как и для ссылок между `ya.make` достаточно указывать имя директории.

{% note info %}

В некоторых случаях правило *один ya.make = один модуль* нарушается в том смысле, что *логический* модуль реализован в нескольких различных *вариантах* ,
т. е. из него могут получаться разные *результаты*. Такая конструкция называется **мультимодуль**. По описанию сборки он не отличается от обычного модуля,
и ссылки на него всё равно делаются указанием директории с описанием. Выбор нужного варианта в этом случае определяется самой зависимостью,
а не явным указанием варианта.

Примеры мультимодулей — это [`PY23_LIBRARY`](./python/modules.md#py23_library) и [`PROTO_LIBRARY`](./proto/modules.md#proto_library)

{% endnote %}

Файлы `ya.make `могут содержать описание сборки *модуля* в данной директории и/или *связи* с другими файлами. Сборка модуля описывается макросами, которые надо размещать между
макросом типа модуля или мультимодуля и специальным макросом `END()`. Макросы, не описывающие сборку модуля, пишутся за его пределами. Там, в частности, надо писать
макросы [`RECURSE`](./common/macros.md#recurse) и подобные, которые выражают **связи** между сборками. Они позволяют при указании сборки для директории собрать несколько целей. Так можно указать,
что при сборке библиотеки надо собрать и тесты для неё (и запустить их, если запрошен запуск тестов).


### Самые первые ya.make

ya.make для списка проектов содержит только список директорий в одном из макросов [`RECURSE`](./common/macros.md#recurse)

```
RECURSE(
    commie
    core
    lib
    solver
    ut
)
```

При сборке такого `ya.make` будут собраны все цели, указанные в нём. Цели сами тоже могут содержать [`RECURSE`](./common/macros.md#recurse), что приведёт к сборке вложенных целей и т.д.

Система сборки поддерживает сборку разнообразных модулей на различных языках. Ниже приведены примеры для основных языков, но кроме них есть ещё модули для Protocol Buffers и Flatbuffers,
модули для агрегации результатов, модули специфичные для проектов и т.п.

Описание модуля обычно содержит:

- Указание на владельца модуля — макрос [`OWNER`](./common/macros.md#owner). Он может быть как в [глобальном скоупе](./syntax.md#global_scope), так и в [скоупе модуля](./syntax.md#mod_scope) (после макроса типа модуля).
- Макрос типа модуля: что именно будет строиться.
- Возможно, макрос для указания зависимостей модуля от других модулей — [`PEERDIR`](./common/macros.md#peerdir).
- Макрос с перечислением исходных файлов модуля [`SRCS`](./common/macros.md#srcs)/[`PY_SRCS`](./python/macros.md#py_srcs)/[`JAVA_SRCS`](./java/macros.md#java_srcs).
- Макрос `END`, завершающий [скоуп модуля](./syntax.md#mod_scope).
- Возможно, связанные сборочные цели (чаще всего тесты), указанные макросом [`RECURSE`](./common/macros.md#recurse) или [`RECURSE_FOR_TESTS`](./common/macros.md#recurse)

Для разных языков описание сборки *программы* будет выглядеть так:

{% list tabs %}

- C++

  __Структура директорий:__

  ```
  project/program
  ├── test
  │   ├── test.cpp
  │   └── ya.make
  ├── main.cpp
  └── ya.make
  ```

  __project/program/ya.make:__

  ```
  OWNER(username)  # Информационный (не сборочный) макрос, описывающий владельцев модуля

  PROGRAM()         # Макрос типа модуля: программа (на C++)

  PEERDIR(          # Макрос зависимостей модуля
      util/draft    # Это зависимость на модуль, описанный в util/draft/ya.make
  )

  SRCS(             # Макрос исходных файлов модуля
      main.cpp
  )

  END()             # Закрывающий макрос модуля

  RECURSE_FOR_TESTS(test) # Макрос связи - при тестировании вместе с программой
                          # строить и исполнять тест в поддиректории test
  ```

  * [Пошаговое руководство по описанию сборки на C++](../tutorials/cpp.md)

- Python

  __Структура директорий:__

  ```
  project/program
  ├── test
  │   ├── test.py
  │   └── ya.make
  ├── main.py
  └── ya.make
  ```

  __project/program/ya.make:__

  ```
  OWNER(username)  # Информационный (не сборочный) макрос, описывающий владельцев модуля

  PY3_PROGRAM()                # Макрос типа модуля: программа на 3м питоне

  PEERDIR(                     # Макрос зависимостей модуля
      contrib/python/requests  # Это зависимость на модуль, описанный в contrib/python/requests/ya.make
  )

  PY_SRCS(                     # Макрос исходных файлов модуля
     MAIN main.py              # Дополнительно указана, что в файле точка входа в программу
  )

  END()                        # Закрывающий макрос модуля

  RECURSE_FOR_TESTS(test) # Макрос связи - при тестировании вместе с программой
                          # строить и исполнять тест в поддиректории test
  ```

  * [Немного о сборке Python](#python)
  * [Пошаговое руководство по описанию сборки на Python](../tutorials/python.md)


- Java

  __Структура директорий:__

  ```
  project/program
  ├── src
  │   ├── main
  │   │   └── java
  │   │       └── ru
  │   │           └── yandex
  │   │               └── example
  │   │                   └── lib
  │   │                       └── Greet.java
  │   └── test
  │       ├── java
  │       │   └── ru
  │       │       └── yandex
  │       │           └── example
  │       │               └── lib
  │       │                   └── test
  │       │                       └── GreetTest.java
  │       └── ya.make
  └── ya.make
  ```

  __project/program/ya.make:__

  ```
  OWNER(username)  # Информационный (не сборочный) макрос, описывающий владельцев модуля

  JAVA_PROGRAM()               # Макрос типа модуля: программа на Java

  PEERDIR(                     # Макрос зависимостей модуля
      contrib/java/org/yaml/snakeyaml   # Это зависимость на общую библиотеку, описанную в contrib/python/requests/ya.make
  )

  DEPENDENCY_MANAGEMENT(       # Макрос выбора версионированной зависимости
      contrib/java/org/yaml/snakeyaml/1.27
  )

  JAVA_SRCS(                   # Макрос исходных файлов модуля
      SRCDIR src/main/java **/*.java    # Все .java файлы в указанной директории рекурсивно
  )

  END()                        # Закрывающий макрос модуля

  RECURSE_FOR_TESTS(test) # Макрос связи - при тестировании вместе с программой
                          # строить и исполнять тест в поддиректории src/test
  ```

  * [Немного о сборке Java](#java)
  * [Пошаговое руководство по описанию сборки на Java](../tutorials/java.md)

- Go

  __Структура директорий:__

  ```
  project/library
  ├── gotest
  │   └── ya.make
  ├── greeting.go
  ├── greeting_test.go
  └── ya.make
  ```

  __project/library/ya.make:__

  ```
  OWNER(username)  # Информационный (не сборочный) макрос, описывающий владельцев модуля

  GO_LIBRARY()     # Макрос типа модуля: библиотека (пакет) на Go

  SRCS(            # Макрос исходных файлов модуля
      greeting.go
  )

  GO_TEST_SRCS(    # Макрос исходных файлов внутренних тестов модуля
      greeting_test.go
  )

  END()            # Закрывающий макрос модуля

  RECURSE_FOR_TESTS(gotest) # Макрос связи - при тестировании вместе с программой
                            # строить и исполнять тест в поддиректории gotest
  ```

  * В описании сборки на Go обычно не указываются зависимости: система сборки находит их сама в исходном коде
  * Для Go поддерживаются внутренние (internal) и внешние (external) тесты. Первые попадают при запуске с тестированием в сам пакет,
    вторые — это отдельная тестовая программа с зависимостью на пакет
  * [Пошаговое руководство по описанию сборки на Go](../tutorials/java.md)

{% endlist %}

{% note tip %}

*Связь* [`RECURSE`](./common/macros.md#recurse) часто противоположна по направлению *зависимости* [`PEERDIR`](./common/macros.md#peerdir): рядом с библиотекой часто написана
*связь* на тесты, в то время как тесты *зависят* от библиотеки.

{% endnote %}

Описание библиотеки будет очень похоже, поменяется только макрос типа модуля (LIBRARY вместо PROGRAM).

Более сложное описание сборки может включать:

- Дополнительные свойства модуля и его команд
- Изменение поведения для разных платформ и конфигураций
- Макросы генерации исходных файлов или специальной обработки данных
- Более сложные зависимости.
- У тестов можно задать много свойств, связанных с исполнением этих тестов




**Для справки**

- [Откуда берутся модули и макросы](./syntax.md#conf)
- [Полный автогенерируемый набор модулей в Аркадии](https://a.yandex-team.ru/arc_vcs/build/docs/readme.md)


### Правила при написании ya.make

{% note alert %}

Это важные правила, которое нужно соблюдать.

{% endnote %}

- Любое включение заголовка из другой библиотеки должно сопровождаться соответствующим [`PEERDIR`](./common/macros.md#peerdir) в `ya.make`. То есть `#include bla/blabla/blah.h` (или `import bla.blabla`) должно вести к `PEERDIR(bla/blabla)`.

- Если директория состоит из одних заголовков, нужно написать в ней `ya.make`, включающий строчки
```
LIBRARY()
    PEERDIR(
        # директории, заголовки из которых есть
        # в заголовках данной директории
    )
END()
  ```
  и ставить [`PEERDIR`](./common/macros.md#peerdir) на эту директорию в местах, где включаются заголовки данной директории.

- Библиотекам и программам нельзя включать заголовки или как-то ещё зависеть от программ без использования [`PEERDIR`](./common/macros.md#peerdir). Исключение сделано только для тестов во всех языках кроме C++).
   Если часть кода программы нужно использовать повторно, выделите его в отдельную библиотеку.

- Архитектура интерфейс/реализация: если библиотека IR содержит две части (интерфейс I и реализацию R), и не хочется, чтобы части кода, включающие только I,
   зависели от R, нужно разбить библиотеку на две части. Конечно, такое разбиение делать разумно,
   если библиотека используется более чем в одном месте и есть несколько разных реализаций интерфейса.

- Ложные зависимости: если библиотека AB состоит из двух частей - A и B, и существует существенная часть другого кода, зависящая (включающая заголовки из) A, но не зависящая от B,
   то библиотеку AB нужно разбить на две части - A и B.

- Макрос [`SRCDIR`](./common/macros.md#srcdir) разрешается использовать **только** для сборки внешнего кода, структуру директорий которого менять нежелательно.
     Если одни и те же файлы надо включить в разные проекты, необходимо выделить их в отдельную библиотеку. Если файлы нужно собрать с разными [`CFLAGS`](cpp/macros.md#cflags),
     следует перечислить [`CFLAGS`](cpp/macros.md#cflags) в отдельном файле и включить его в `ya.make`.
     Этим правилом следует руководствоваться не только в С++, а во всех разрешённых языках.

- Поддиректории с названиями `/common`, `/util` и им подобными заводить не следует - такие названия приводят к тому, что в этом месте со временем образуется мусорная свалка.
     Называйте свои поддиректории осмысленными именами.

- Все генерируемые в процессе сборки файлы должны находиться в каталоге сборки ([`BINDIR`, `ARCADIA_BUILD_ROOT`](common/vars.md#dir_vars)). Запрещено генерировать файлы в каталоге с исходниками
    ([ARCADIA_ROOT SRCDIR](common/vars.md#dir_vars)).

- В `ya.make` проекта запрещается устанавливать флаги сборки (компиляции, дефайны), влияющие на сборку других проектов. Тем более запрещается менять глобальные флаги, влияющие на
     конфигурацию сборки (вызывающие включение / исключение компонент и файлов в компоненты). Такие флаги разрешается устанавливать только глобально, для сборки в целом.

- Все проекты должны  быть достижимы от корня по цепочке `RECURSE() + PEERDIR()` от директории `/autocheck` для нужд автосборки и тестирования.

### Описание сборки модуля { #mod }

Описание сборки модуля содержит все необходимые для него исходные файлы, включая команды генерации исходных файлов, свойства и опции его сборки, а также необходимые
*зависимости* как ссылки на другие модули. Тестовые модули могут также содержать данные, зависимости и свойства, необходимые для запуска теста.

Начинается описания модуля **макросом типа модуля**, в котором опционально могут быть указаны имя его результата (может быть важно для программ и динамических библиотек) и иногда
другая необходимая для описания самого модуля информация. Заканчивается описание модуля макросом `END`.


**Модули** условно делятся на *финальные* и *промежуточные*.

- Промежуточные модули — это модули, родственные [`LIBRARY`](./cpp/modules.md#library) и [`UNION`](./package/modules.md#union). На них можно ставить зависимость ([`PEERDIR`](./common/macros.md#peerdir)) как из аналогичных модулей,
  так и из соответствующих финальных модулей (для [`LIBRARY`](./cpp/modules.md#library) это [`PROGRAM`](./cpp/modules.md#program), `DLL`, `UNITTEST` и т.п.). При сборке промежуточных модулей как целей их зависимости
  **не строятся**. Не имеет смысл указывать промежуточные модули в макросах [`BUNDLE`](./common/macros.md#bundle) и [`DEPENDS`](./tests/common.md#depends) поскольку они не замкнуты по зависимостям.
  Их также нельзя использовать как инструменты в макросах типа [`RUN_PROGRAM`](./common/macros.md#run_program). Единственное исключение - [`DEPENDS`](./tests/common.md#depends) на [`UNION`](./package/modules.md#union), см. ниже.

- Финальные модули — это программы, тесты и [`PACKAGE`](./package/modules.md#package). При сборке они замыкают транзитивно все свои зависимости. На них нельзя ставить зависимость [`PEERDIR`](./common/macros.md#peerdir) в других модулях кроме [`PACKAGE`](./package/modules.md#package).
  Их можно использовать как артефакты в макросах [`DEPENDS`](./tests/common.md#depends) и [`BUNDLE`](./common/macros.md#bundle). Исполняемые финальные модули могут выступать инструментами в макросе [`RUN_PROGRAM`](./common/macros.md#run_program) и аналогичных.

- Если сослаться на [`UNION`](./package/modules.md#union) в макросе [`DEPENDS`](./tests/common.md#depends), то все зависимости [`UNION`](./package/modules.md#union) транзитивно построятся и будут доступны в build-директории по путям, соответствующим своему размещению в репозитории.

{% note tip %}

Для упрощения написания тестов для программ и реализации традиционных возможностей для отдельных языков, программы могут быть *мультимодулями*, состоящими из *промежуточного* модуля-библиотеки и
*финального* модуля программы. Такая организация позволяет иметь [`PEERDIR`](./common/macros.md#peerdir)-зависимость из теста на программу, чтобы протестировать функции в программах непосредственными вызовами,
а не запуском программы (как при использовании [`DEPENDS`](./tests/common.md#depends)). Такая реализация сейчас у [`JAVA_PROGRAM`](./java/modules.md#java_program) и [`PY3_PROGRAM`](./python/modules.md#py3_program).

{% endnote %}

Система сборки ya make предоставляет развитую систему модулей для различных языков и применений. Они описаны в соответствующих разделах:

- [Более подробно о синтаксисте ya.make](./syntax.md)
- [Модули для C++](cpp/modules.md)
- [Модули для Python](python/modules.md)
- [Модули для Java](java/modules.md)
- [Модули для Go](go/modules.md)
- [Модули для Protocol Buffers](proto/modules.md)
- [Модули для Flat Buffers](flatbuf/modules.md)
- [Модули для агрегации](package/modules.md)
- Модули для тестов [на С++](tests/cpp.md), [на Python](tests/cpp.md), [для Java](tests/cpp.md), [для Go](tests/cpp.md).
- [Полный автогенерируемый набор модулей в Аркадии](https://a.yandex-team.ru/arc_vcs/build/docs/readme.md)


### Макросы в модуле { #module_macros }

Условно макросы в модуле можно разделить на три группы:

1. Управляющие макросы.

   Это [условные макросы](./syntax.md#if), макрос [`INCLUDE`](./syntax.md#include), макросы [`EXCLUDE_TAGS`/`ONLY_TAGS`/`ONLY_TAGS`](./syntax.md#exclude_tag)
   Они влияют на то, как интерпретируется `ya.make`.

   Условными макросами `IF()/ELSEIF()/ELSE()/ENDIF()` можно настроить разную сборку на основе значений переменных как заданных локально (макросом [`SET()`](./syntax.md#var_macros)),
   так и глобальных, определяющих конфигурацию сборки для данного модуля (например, `OS_WINDOWS` при сборке под Windows или `PYTHON3` в соответствующем варианте мультимодуля).

2. Макросы, задающие свойства.

   Такие макросы могут влиять на встроенные свойства непосредственно, например, [`PEERDIR`](./common/macros.md#peerdir) задаёт зависимости для модуля,
   [`SRCDIR`](./common/macros.md#srcdir) или [`ADDINCL`](./common/macros.md#addincl) задают пути поиска для [разрешения имён](../general/how_it_works.md#resolving).
   Макрос [`PY_NAMESPACE`](python/macros.md#py_namespace) задаёт пространства имён для импорта описанных в модуле файлов и т.п.

   Также они могут формировать значения [переменных](./syntax.md#vars), которые будут использованы в командах других макросов или модуля. Например, `СFLAGS` задаёт
   флаги для команд компиляции C/C++ файлов в модуле. Макросом [`SET(VAR VALUE)`](./syntax.md#var_macros) можно задать значение переменной. Если переменная присутствует в
   глобальной конфигурации, её значение изменится для данного модуля, если нет - переменная появится и будет доступна в контексте данного модуля в макросах, идущих ниже по тексту.

   Макрос [`OWNER`](./common/macros.md#owner) можно писать за пределами модуля и даже в файлах `ya.make` не описывающих никаких модулей. Этот макрос позволяет внешним системам
   (Arcanum и CI) находить ответственных за код. Поскольку эта информация не имеет отношения к системе сборки, то в скором времени вместо этого макроса владельцев кода надо писать
   в конфигурации проектов в репозитории (файле `a.yaml`).

3. Макросы, описывающие команды.

   Такие макросы описывают команды, которые должны быть исполнены в процессе сборки. Макрос формирует команду, которая встраивается в сборочный граф своего модуля за счёт
   [связывания](../general/how_it_works.md#resolving) своих результатов с входами других команд (потребителей) и, возможно, своих входов с результатами других команд (источников).

   Так, например, макрос `COMPILE_LUA` создаёт команду, компилирующую код на Lua в представление, пригодное для LuaJit. Его результат будет связан с командой модуля
   (например, упаковкой в библиотеку), а библиотеку по зависимостям влинкует в себя программа.


Макросы, описывающие сборку модуля, могут ссылаться на файлы, директории в репозитории и другие модули.

- Ссылки на файлы могут относиться как к файлам в репозитории, так и к генерированным файлам. Для первых проверяется наличие в файловой системе, для вторых - доступность
  в соответствующем модуле по графу сборки. Для точного указания о каком файле идёт речь можно использовать пути в формате `${ARCADIA_ROOT}/project/path/file.name` для
  файлов в репозитории и `${ARCADIA_BUILD_ROOT}/project/path/file.name` для генерированных файлов. [Подробнее о разрешении имён](../general/how_it_works.md#resolving).

- Ссылки на директории практически всегда фиксируют только имя директории, но не её содержимое. Единственное исключение - макрос `DATA()`, задающий данные для тестов.
  При указании в нём директории тест будет зависеть от всех файлов в указанной директории.

- Ссылки на модули всегда описываются указанием директории, но в такой директории должен быть `ya.make` с описанием сборки модуля или мультимодуля.
  Ссылки на директории с `ya.make` без модулей запрещены. Это относится к любым макросам, задающим межмодульные зависимости: [`PEERDIR`](./common/macros.md#peerdir), [`DEPENDS`](./tests/common.md#depends), [`BUNDLE`](./common/macros.md#bundle), а также к ссылкам на инструменты в
  макросах запуска инструментов (`RUN_PROGRAM`) и подобным. Это не относится к макросам, задающим *связи* — [`RECURSE`](./common/macros.md#recurse) и подобным. Такие макросы могут ссылаться на `ya.make`
  только с [`RECURSE`](./common/macros.md#recurse) для рекурсивного задания связей.


Система сборки ya make предоставляет огромное количество макросов для различных языков и применений. Они описаны в соответствующих разделах:

- [Более подробно о синтаксисте ya.make](./syntax.md)
- [Макросы для C++](cpp/macros.md)
- [Макросы для Python](python/macros.md)
- [Макросы для Java](java/macros.md)
- [Макросы для Go](go/macros.md)
- [Макросы для Protocol Buffers](proto/macros.md)
- [Макросы для Flat Buffers](flatbuf/macros.md)
- [Макросы для агрегации](package/macros.md)
- [Макросы для тестов](tests/common.md)
- [Полный автогенерируемый набор макросов в Аркадии](https://a.yandex-team.ru/arc_vcs/build/docs/readme.md)

### Мультимодули { #multi }

**Мультимодуль** — это модуль, который может быть собран в различных вариантах в зависимости от того, как его используют. По описанию сборки он не отличается от обычного модуля,
ссылки на него делаются по имени директории, а выбор нужного варианта делается по следующим правилам:

- Если мультимодуль используют по зависимости [`PEERDIR`](./common/macros.md#peerdir), то вариант выбирается по *входящей зависимости* - модуль,
  который зависит от мультимодуля определяет какой вариант ему нужен. Каждый отдельный модуль может зависеть только от одного варианта, но в рамках
  одной сборки может быть собрано несколько вариантов для разных зависимостей.
- Если мультимодуль является непосредственной целью собираются все его варианты (более точно см. документацию по соответствующему мультимодулю).
- Если мультимодуль указан в [`DEPENDS`](./tests/common.md#depends) или [`BUNDLE`](./common/macros.md#bundle) будет выбран единственный вариант со свойством `FINAL_TARGET`. Если такой вариант не единственный
  или его нет вовсе - будет выдана ошибка конфигурации.

**Пример**

__Структура директорий:__

```
project/interface
├── cpp
│   ├── iface.cpp
│   └── ya.make
├── go
│   ├── iface.go
│   └── ya.make
├── java
│   ├── iface.java
│   └── ya.make
├── proto
│   ├── iface.proto
│   └── ya.make
├── python
│   ├── iface.py
│   └── ya.make
└── ya.make
```

__project/interface/ya.make:__

```
OWNER(username)  # Информационный (не сборочный) макрос, описывающий владельцев модуля

RECURSE(
    proto

    cpp
    go
    java
    python
)
```

__project/interface/proto/ya.make:__

```
OWNER(username)  # Информационный (не сборочный) макрос, описывающий владельцев модуля

PROTO_LIBRARY()  # Макрос типа модуля: мультимодуль библиотеки protobuf (для разных языков)

SRCS(            # Макрос исходных файлов модуля. Интерпретируется по-разному в разных вариантах
    iface.proto
)

END()            # Закрывающий макрос модуля
```

__Зависимости на эту библиотеку в разных языках:__

{% list tabs %}

- C++

  __project/interface/cpp/ya.make:__

  ```
  OWNER(username)  # Информационный (не сборочный) макрос, описывающий владельцев модуля

  LIBRARY()         # Макрос типа модуля: библиотека (на C++)

  PEERDIR(          # Макрос зависимостей модуля
      project/interface/proto    # Это зависимость на модуль, описанный в project/interface/proto/ya.make
  )

  SRCS(             # Макрос исходных файлов модуля
      iface.cpp
  )

  END()
  ```

  * Такая библиотека получит зависимость на `project/interface/proto/libproto.a`
  * Библиотеке будет доступен для `#include` файл `project/interface/proto/iface.pb.h`
  * И библиотека и файл будут результатами сборки варианта [`PROTO_LIBRARY`](./proto/modules.md#proto_library) для C++ по зависимости из этой библиотеки

- Python

  __project/interface/python/ya.make:__

  ```
  OWNER(username)  # Информационный (не сборочный) макрос, описывающий владельцев модуля

  PY3_LIBRARY()    # Макрос типа модуля: библиотека (на Python 3)

  PEERDIR(         # Макрос зависимостей модуля
      project/interface/proto    # Это зависимость на модуль, описанный в project/interface/proto/ya.make
  )

  PY_SRCS(         # Макрос исходных файлов модуля
      iface.py
  )

  END()
  ```

  * Библиотеке будет доступен для `import` модуль `project.interface.proto.iface_pb2`
  * При сборке по зависимости из этой библиотеки будет построит Python 3 вариант [`PROTO_LIBRARY`](./proto/modules.md#proto_library).
    Это будет сгенерированный и прекомпилированный Python-код, доступный для импорта. Немножко о сборке Python [ниже](#python).

- Java

  __project/interface/java/ya.make:__

  ```
  OWNER(username)  # Информационный (не сборочный) макрос, описывающий владельцев модуля

  JAVA_LIBRARY()   # Макрос типа модуля: библиотека (на Python 3)

  PEERDIR(         # Макрос зависимостей модуля
      project/interface/proto    # Это зависимость на модуль, описанный в project/interface/proto/ya.make
  )

  JAVA_SRCS(       # Макрос исходных файлов модуля
      iface.java
  )

  END()
  ```

  * Библиотеке будут доступен для `import` класс `project.interface.proto.iface.Message` (в предположении, что в `iface.proto` описано сообщение `Message`.
  * При сборке по зависимости из этой библиотеки будет собран Java-вариант [`PROTO_LIBRARY`](./proto/modules.md#proto_library). В результате будет сгенерирован набор .java-файлов и все они
    будут откомпилированы в `project/interface/proto/iface.jar`, который и станет зависимостью для этой библиотеки.


- Go

  __project/interface/go/ya.make:__

  ```
  OWNER(username)  # Информационный (не сборочный) макрос, описывающий владельцев модуля

  GO_LIBRARY()   # Макрос типа модуля: библиотека (на Python 3)

  SRCS(          # Макрос исходных файлов модуля
      iface.go
  )

  END()
  ```

  * В коде на Go [`PEERDIR`](./common/macros.md#peerdir) указывать не надо, он будет получен из исходного файла.
  * import будет выглядеть как `"a.yandex-team.ru/project/interface/proto/iface"`. Для правильной его работы в `iface.proto` должно быть указано
    `option go_package = "a.yandex-team.ru/project/interface/proto/iface";`
  * При сборке по зависимости из этой библиотеки будет собран Go-вариант [`PROTO_LIBRARY`](./proto/modules.md#proto_library). Для этого будет сгенерирован и скомпилирован go-код.
    Получившаяся библиотеке (пакет) станут зависимостью этой библиотеки.

{% endlist %}

Как несложно заметить [`PEERDIR`](./common/macros.md#peerdir) выглядит одинаково для всех языков, однако в зависимости от потребителя будет предоставлен
разный *вариант* [`PROTO_LIBRARY`](./proto/modules.md#proto_library): для go — это будет собранный пакет, для C++ библиотека, для java - .jar, для Python - набор
сгенерированных и прекомпилированных Python-модулей. Такое поведение определяется двумя встроенными *переменными*, поддержанными в коде системы сборки:

- `MODULE_TAG` позволяет различать варианты и говорит о назначении модуля. У разных вариантов мультимодуля он разный.
- `PEERDIR_TAGS` говорит какой вариант надо выбирать из мультимодуля по [`PEERDIR`](./common/macros.md#peerdir). На данный момент из каждого мультимодуля можно выбирать только
  один вариант, список нужен для выбора вариантов в разных видах мультимодулей. Кроме выбора вариантов этот же механизм используется для контроля
  совместимости обычных модулей по зависимостям.

{% note tip %}

Если необходима разная сборка в зависимости от выбранного варианта, то надо использовать макрос [`IF()/ELSEIF()/ELSE()/ENDIF()`](./syntax.md#if) с условием на переменную
`MODULE_TAG` или другие переменные специфичные для интересующего варианта (например, `PYTHON2`/`PYTHON3`).

{% endnote %}


### Как интерпретируется ya.make { #interp }

К моменту начала зачитывания и интерпретации ya.make уже:

- Зачитана конфигурация с описанием всех макросов, глобальных правил и переменных
- Переменные, относящиеся к платформе уже означены

ya.make файл интерпретируется следующим образом:

**Чтение ya.make**

- Макросы читаются в том порядке, в котором написаны, но интерпретируются сразу далеко не все.
- В интерпретируемые макросы известные переменные подставляются, условные выражения отрабатывают по сложившимся к моменту их вызова значениям.
- Изменения переменных, для которых есть правила в описании модуля, приводят к вызову этих правил и соответствующему изменению значений внутри правил.
- Макросы, меняющие переменные, срабатывают сразу. Если в макросах есть вызовы других макросов, они тоже срабатывают в этом смысле. Если в макросах есть использования переменных -- они подставятся.
- Все макросы кроме изменений переменных помещаются в приоритизированную очередь, где [`PEERDIR`](./common/macros.md#peerdir) имеет самый высокий приоритет, а [`SRCS`](./common/macros.md#srcs) один из самых низких.
  Также очень низкий приоритет имеют макросы, реализованные в [плагинах](#plugins).
- Для мультимодулей это делается для каждого варианта отдельно.

**Построение графа зависимостей**

- Отдельным проходом очередь разбирается
- [`PEERDIR`](./common/macros.md#peerdir) вызывает переход к обработке `ya.make` по зависимостям. Это необходимо для корректного распространения [глобальных свойств](#global).
- Выясняются входы и выходы команд, происходит их [связывание](../general/how_it_works.md#resolving) в соответствии с [`SRCDIR`](./common/macros.md#srcdir) этого модуля.
- Команды макросов помещаются в [граф зависимостей](../general/how_it_works.md) в соответствии с зависимостями. [Глобальные переменные](#global) остаются не подставленными. Отдельно формируются [глобальные команды](#global), чтобы их мог получить модуль, который их агрегирует.
- Все входы всех команд транзитивно парсятся на предмет зависимостей [в соответствии с их расширениями](./extensions.md#parsing), напарсенные имена [превращаются в зависимости на файлы](../general/how_it_works.md#resolving) в соответствии с [`ADDINCL`](./common/macros.md#addincl) применимыми в этом модуле.
- После всех команд из макросов в модуле добавляется команда модуля, она получает входы от других команд как обычными связыванием, так и специальным, [модульным](../general/how_it_works.md#mod_resolve).
- Когда граф полностью построен, на нём отрабатывает код для макросов, анализирующих граф целиком ([`DEPENDENCY_MANAGEMENT`](./java/macros.md#dependency_namagement), [`CHECK_DEPENDENT_DIRS`](./common/macros.md#check_dependent_dirs), [`LICENSE_RESTRICTION`](./common/macros.md#license_restriction) и т.п.).
- После этого формируется [граф команд](../general/how_it_works.md). В него записываются тексты команд с учётом подстановки всех переменных, включая [глобальные](#global)
- Отдельно формируется информация, которую будет использовать [обогащение графа](../general/how_it_works.md), например, для формирования команд запуска тестов. Туда попадает часть переменных и свойств модуля.


#### Глобальные свойства, переменные и команды { #global }

В системе сборки ya make есть понятие *локальных* и *глобальных* свойств, переменных и команд.

- Локальные свойства, переменные и команды относятся к тому модулю, в котором описаны. Локальные свойства — это свойства только этого модуля; локальные переменные — переменные доступные только в нём; локальные команды — это команды,
  результаты которых являются (возможно, транзитивно) входами команды модуля.

- Глобальны свойства, переменные и команды относятся к тем, кто от данного модуля зависит, т. е. они могут распространяться от библиотек (целей зависимостей) к программам (источникам зависимостей).

**Глобальными свойствами** могут являться:

- [`PEERDIR`](./common/macros.md#peerdir), в C++, Python и Go: если программа `P` зависит от библиотеки `A`, а библиотека `A` зависит от библиотеки `B`, то программа `P` тоже зависит от библиотеки `B`. В частности эта
  библиотека должна быть передана в команду линковки программы.

- [`ADDINCL`](./common/macros.md#addincl) может быть глобальным, если указан параметр `GLOBAL`. В это случае он станет свойством как самой библиотеки, так и всех модулей (библиотек и программ), зависящих от этой библиотеки.
  Это нужно в том случае, если в заголовочных файлах библиотеки в `#include` указан относительный путь. Поскольку такой заголовочный файл может быть включён в файлах из других модулей, они должны
  знать где файл искать.

Есть и другие глобальные свойства.

**Глобальные переменные**

Некоторые переменные могут распространять свои значения по зависимостям. Примерами могут служить `LDFLAGS` — если библиотека требует указания каких-то флагов при линковке, она макросом
`LDFLAGS` может добавить их в список одноимённой переменной `LDFLAGS`, которая будет использована в команде линковки программы. Аналогично работает `CFLAGS(GLOBAL ...)` но в этом случае
переменная `CFLAGS` будет использована во всех командах компиляции во всех модулях, зависящих от библиотеки.

Глобальные переменные конфигурируются для каждого типа модуля и новые нельзя создать синтаксисом в `ya.make`. Если вам кажется, что для решения вашей сборочной задачи необходима глобальная переменная,
[обращайтесь в devtools](https://st.yandex-team.ru/createTicket?queue=DEVTOOLSSUPPORT).

{% note alert %}

Распространять свойства и переменные в сторону зависимостей нельзя. Иначе разные цели могли бы для одного и того же
модуля запросить разные свойства, и его конфигурация бы размножилась. Для изменения свойств зависимостей надо использовать [установку переменной на всю сборку `ya make -DVAR`](../usage/ya_make/index.md#D).

У этого правила есть три исключения:
- Транзитивные межмодульные инварианты проверяются на всём подграфе и могут запрещать транзитивную зависимость.
- dependency management для java формирует граф зависимостей глобально для узла учитывая, но не полностью следуя зависимостям своих зависимостей
- Связывание по PEERDIR варианта [мультимодуля](#multi) — это выбор конфигурации зависимости, но из ограниченного набора вариантов.

{% endnote %}


**Глобальные команды**

Иногда возникает необходимость сделать команду зависимостью не самого модуля (библиотеки), а финального артефакта (программы). Например, при линковке С++ кода объектные файлы из библиотек
могут быть полностью удалены, если у них нет использований. Если код регистрирует себя при статической инициализации он может быть исключён из программы. Чтобы этого не произошло, такой код надо
подать на линковку непосредственно программе. Этой цели служат *глобальные команды*. Чаще всего они возникают из вызова макроса [`SRCS`](./common/macros.md#srcs) c параметром `GLOBAL`, но есть и другие макросы, порождающие
глобальные команды.

{% note tip %}

Несмотря на то, что глобальные команды не нужны самому модулю и не попадают в его артефакт (например, в библиотеку), для упрощения разработки они собираются вместе с модулем, в котором описаны,
но формируют отдельный результат — объектный файл или специальную *глобальную библиотеку*. Это позволяет проверить компилируемость такого кода при сборке библиотеки.

{% endnote %}

#### Автоматическая обработка по расширениям { #ext }

Макросы, задающие исходный код для модуля, такие как [`SRC`](./common/macros.md#srcs)/[`SRCS`](./common/macros.md#srcs)/[`PY_SRCS`](./python/macros.md#py_srcs)/[`JAVA_SRCS`](./java/macros.md#java_srcs) полиморфны. Они задают обработку файла в соответствии с расширением.
Поддерживается достаточно большой [список расширений](./extensions.md#srcs). Если файл, с поддерживаемым расширением является результатом работы команды в каком-то макросе,
например, перечислен в параметре `OUT` (есть у многих генерирующих макросов), такой файл будет обработан **автоматически** так, как будто он указан в [`SRCS`](./common/macros.md#srcs).
Дополнительно указывать его там не нужно. Если такая обработка является нежелательной или обработка по расширению не поддерживается - используйте параметр `OUT_NOAUTO` вместо `OUT`.
Конкретные команды обработки по расширениям могут зависеть от модуля, для которого обрабатываются файлы. Так в контексте [`LIBRARY`](./cpp/modules.md#library) (библиотеки для C++), файл `.proto` будет обработан по цепочке `.proto -> .pb.cc/pb.h -> .pb.cc.o`, после чего все `.o` файлы
соберутся в библиотеку. В контексте `GO_LIBRARY` цепочка получится уже `.proto -> .pb.go -> .pb.go.o`. Таким образом, команда для `.proto` будет разной в зависимости от типа модуля, а
команды для компиляции `.cc` и `.go` будут предоставлены неявно по факту появления промежуточного результата с таким расширением.

Описание сборки в `ya make` очень высокоуровневое, она не требует описания зависимостей файлов от других файлов (например, `#include` в C++), если исходный файл доступен на файловой системе.
Система сборки сама парсит такие файлы, основываясь на расширениях и находит зависимости. Более того, система сборки может выводить парсингом межмодульные зависимости (в go), а также [наведённые](#induced)
зависимости генерируемых файлов от других генерируемых. Так из `import` в .proto система сборки делает вывод не только о зависимости между .proto-файлами, но и о
зависимости .pb.cc файла от импортируемого .pb.h. Какие файлы и как парсятся можно посмотреть в [списке расширений поддержанных парсингом и командами](./extensions.md#parsing)


## Зависимости в сборке { #deps }

### Зависимости между модулями { #mod_deps }

Основной зависимостью между модулями является [`PEERDIR`](./common/macros.md#peerdir) — она примерно эквивалентна import-зависимости между пакетами/модулями в модульных языках.
[`PEERDIR`](./common/macros.md#peerdir)-зависимости между модулями могут быть *логическими* или *сборочными* в зависимости от языка и типа модуля.

- В C++ зависимость одной библиотеки ([`LIBRARY`](./cpp/modules.md#library)) от другой **логическая**: для сборки зависящей библиотеки, зависимую библиотеку собирать не нужно. Зависимость между библиотеками в данном случае означает что при сборке программы вместе
с зависящей библиотекой надо линковать и зависимую. Кроме этого, по такой зависимости могут распространяться свойства. Например, зависимая библиотека может добавить путь поиска
`#include` всем, кто от неё зависит или отправить во все программы по зависимостям флаги линковки и т.п.

- Зависимость программы ([`PROGRAM`](./cpp/modules.md#program)) от библиотек ([`LIBRARY`](./cpp/modules.md#library)) является **сборочной** — все библиотеки по зависимостям будут собраны и предоставлены программе для линковки.

Сборка в Python устроена аналогично С++ с логическими связями между библиотеками. В отличие от C++, Java и Go — модульные языки, сборка пакета/модуля требует наличия всех предсобранных зависимостей,
поэтому зависимости `JAVA_LIBRARY` и `GO_LIBRARY` от себе подобных **сборочные** и пересборка любой такой библиотеки вызывает пересборку всех зависимостей.

Кроме [`PEERDIR`](./common/macros.md#peerdir) между модулями могут быть следующие зависимости:

- **инструментальная зависимость** — зависимость команды модуля от другого (*финального*) модуля, как инструмента. Описывается такая зависимость через упоминание в макросе
  [`RUN_PROGRAM`](./common/macros.md#run_program) или в параметре `TOOL` многих генерирующих макросов.

  {% note warning %}

  Такая зависимость является кроссплатформенной. В то время как модуль, в котором написан [`RUN_PROGRAM`](./common/macros.md#run_program) будет собираться под [*целевую платформу*](../general/base_concepts.md#configs),
  модуль, от которого есть *инструментальная зависимость* будет собираться под [*сборочную платформу*](../general/base_concepts.md#configs), поскольку он будет исполняться в процессе сборки.

  {% endnote %}

- **[`BUNDLE`](./common/macros.md#bundle) — зависимость от модуля как от файла**. Результат сборки модуля становится входом команды в другом модуле. Например, его можно сложить внутрь модуля макросом [`RESOURCE`](./common/macros.md#resource)

- **[`DEPENDS`](./tests/common.md#depends) — нужно для исполнения**. Результат сборки модуля (обычно программы) нужен в запуске теста. Такая программа будет собрана независимо и доступна тесту по пути, предоставляемому тестовым фреймворком.

#### Какие модульные зависимости не поддержаны

Есть несколько разумных зависимостей, которые, однако, у нас сейчас не поддержаны.

- **Дополнительный результат. ([`DEPENDS`](./tests/common.md#depends) для программ)** Зависимость такого рода, например, могла бы возникать у программы на динамическую библиотеку и приводить к тому,
  что результатом сборки программы была бы ещё и динамическая библиотека. На данный момент такая возможность не поддержана, мы рекомендуем использовать [`UNION`](./package/modules.md#union) +
  [`BUNDLE`](./common/macros.md#bundle) или [`PACKAGE`](./package/modules.md#package) + [`PEERDIR`](./common/macros.md#peerdir) для сборки программы с динамической библиотекой. Однако мы думаем о том, чтобы добавить такую возможность.

- **Наведённый [`PEERDIR`](./common/macros.md#peerdir)**. Таким образом можно было бы описать, что для работы порождённого генератором кода нужна библиотека. Это не поддержано в силу рядя причин:
  - Такая возможность сделала бы описание PEERDIR-ов нелокальным и усложнила бы конфигурирование.
  - Технически генератор конфигурируется под сборочную платформу, а его рантайм-библиотека нужна в целевой, поэтому такая зависимость требовала бы распространения свойств между разными платформами

### Зависимости модулей и команд от файлов { #mod_to_file }

Модули естественным образом зависят от своих входных файлов либо через свои команды, либо напрямую. Команды модуля также зависят от своих входных файлов.

- Такие макросы как [`SRCS`](./common/macros.md#srcs), `FILES`, [`RESOURCE`](./common/macros.md#resource) и многие другие порождают команды, которые работают над файлами, перечисленными в макросе, и порождают файлы результата. Последние могут быть [обработаны по расширению](#ext) и так несколько раз,
  пока в итоге не станут входами модуля. При пересборке изменение такого файла приведёт к перезапуску команды из макроса дале по цепочке вплоть до модульной команды и далее по модульным зависимостям.
  Про то как выходы одних команд становятся входами других, можно почитать в разделе про [связывание имён входов с файлами и результатами](../general/how_it_works.md#resolving).

- Модули для языков, не поддерживающих раздельную компиляцию (например, Java и go) собирают все исходные файлы прямо в модульной команде. Их макросы [`SRCS`](./common/macros.md#srcs) и [`JAVA_SRCS`](./java/macros.md#java_srcs) формируют только список
  исходных файлов, который подаётся на вход модульной команде.

Как описано [выше](#ext), не все зависимости и даже команды нужно указывать явно:

- Модульная команда [собирает все результаты сборки и даже исходные файлы](../general/how_it_works.md#mod_resolve), перечисленные в `SRCS` по расширениям [зафиксированным для модуля](./extensions.md#auto)
- Файлы, возникающие как результаты команд (кроме тех, где это явно отменено и тех, которые попали под правило выше) будут обработаны так, словно написаны в `SRCS`. Сам макрос `SRCS`
  [обрабатывает файлы в соответствии с расширением](./extensions.md#srcs). Причём, если обработка в `SRCS` порождает файл с расширением, поддержанный в `SRCS`, он будет снова обработан.


### Зависимости файлов от файлов { #file_to_file }

Единицей сборки является команда, поэтому зависимость команд от файлов, описанная выше, достаточно естественна и понятна. Однако, в системе сборки ya make одни файлы могут зависеть от других.
В реальности такие зависимости превращаются в зависимость команды обработки файла от него и всех его зависимостей, но, если делать эти зависимости явными получится очень много дуг. Например,
в C++ каждая команда компиляции зависит вообще от всех заголовочных файлов, транзитивно включённых в исходный. А ведь заголовочные файлы могут включать другие заголовочные файлы и т.д. создавая
огромные повторяющиеся наборы зависимостей. В системе сборки ya make такие `#include` (а также `import`-ы в `.proto` и многие другие подобные связи) представлены непосредственно.

Это позволяет заметно сэкономить память и время обработки графа: в большинстве внутренних обходов каждая дуга посещается не более одного раза.

Зависимости файлов от файлов по своему происхождению бывают двух видов:

- Непосредственные зависимости, выясняются [парсингом](#parsing) на основе [расширений](./extensions.md#parsing). Это зависимости непосредственно написанные исходном в файле.
- Наведённые зависимости — это зависимости генерированных файлов. Они могут быть [предсказаны парсером или указаны явно](#induced)

#### Парсинг { #parsing }

Сборочные инструменты, например компилятор, обрабатывают все инклуды рекурсивно во время компиляции. В частности, это означает, что каждый хедер файл будет прочитан за время сборки столько раз,
сколько .cpp файлов его используют (транзитивно). Повторять такую логику при анализе зависимостей крайне дорого, поэтому система сборки ya make читает каждый файл ровно один раз. В неё встроено
достаточно большое количество быстрых парсеров для файлов разных типов, [определяемых расширением](./extensions.md#parsing). Эти парсеры не разбирают язык полностью, а лишь ищут межфайловые
зависимости (инклуды, импорты и т.п.). В файлах могут быть условные инклуды и даже в одной сборке они могут отработать по-разному в контексте разных компиляций.
Поскольку система сборки парсит файл ровно один раз она игнорирует условия и использует все include как источники зависимостей. Это избыточно, но лишние зависимости лучше, чем неучтённые.

Получающийся набор имён потом транслируется в зависимости от исходных файлов или результатов сборки с помощью [*резолвинга*](../general/how_it_works.md#resolving).


#### Наведённые зависимости { #induced }

Не все зависимости система сборки может получить парсингом: ya make анализирует зависимости до исполнения сборки, поэтому зависимости генерируемых файлов она получить не может.
Такие зависимости называются **наведёнными** и могут быть получены тремя способами:

- Зависимости, приносимые инструментами. Если какой-то генератор порождает фиксированные инклуды, то их можно указать в модуле самого генератора макросом [`INDUCED_DEPS`](./common/macros.md#induced_deps). Поскольку такие инклуды будут
  использованы в генерированном коде, который даже относится к другой платформе (инструмент относится к сборочной, а хедеры будут использованы в контексте сборке для целевой), то мы не делаем для них
  полноценный [резолвинг](../general/how_it_works.md#resolving). В этом макросе должны быть указаны [*полные имена*](../general/how_it_works.md#resolving). Поскольку один генератор может генерировать код на разных языках в макросе можно указать разные наведённые инклуды для
  разных языков.

- Зависимости, приносимые вызовом инструментов. Конкретный вызов инструмента в макросе [`RUN_PROGRAM`](./common/macros.md#run_program) может определять набор зависимостей, которые будут у результата. Такие зависимости должны быть
  указаны в параметре `OUTPUT_INCLUDES` самого макроса. Поскольку в данном случае результат макроса принадлежит тому же модулю, что и вызов макроса, то имена, указанные в параметре будут предметом
  резолвинга, как и обычные инклуды. Для вызова одного и того же инструмента могут применяться оба вида зависимостей.

- Наведённые зависимости, получаемые [парсингом](#parsing). Код обработки импортов в отдельных случаях может делать выводы о том, какие зависимости получатся у генерированного кода. Так из импорта
  файла `imp.proto` в файле `use.proto` система сборки делает вывод о наличии include `imp.pb.h` в `use.pb.h` n `use.pb.cc`.

## Исполнение сборки по описанию

Более подробно о том, как работает сборка, написано в [соответствующем разделе](../general/how_it_works.md#build)

При запуске сборки для выбранной директории происходит примерно следующее:

1. Зачитывается глобальная конфигурация, из неё ya make узнаёт о доступных макросах и модулях.
2. Инициализируются переменные связанные с платформой и конфигурацией.
3. Зачитывается и интерпретируется ya.make файл в директории сборочной цели.
4. Все связанные ya.make добавляются в очередь.
5. Если ya.make содержит [описание сборки модуля](#mod), то выясняются свойства его сборки и зависимости.
6. Зачитываются и интерпретируются ya.make зависимостей, [связи](./common/macros.md#recurse) от них игнорируются.
7. Процесс 5–6 идёт рекурсивно пока не достигнет модуля без зависимостей, пройденные модули запоминаются в стек.
8. Если есть зависимые модули - их [глобальные свойства](#global) применяются. Анализируются [зависимости модуля от файлов](#mod_to_file), формируются команды модуля.
9. [Глобальные свойства](#global) модуля фиксируются для распространения.
10. Повторяются шаги 5,6 пока не пройдены все зависимости, потом шаги 8,9.
11. При достижении дна стека берётся следующий ya.make из очереди. который ещё не обрабатывали (в обходе по зависимостям). Начальный модуль и модули из очереди называются *стартовыми*.
12. Когда очередь исчерпана - построен *Граф зависимостей*.
13. На построенном графе **анализируются глобальные свойства**, делается [dependency management](./java/dependencies.md) для Java, проверяются транзитивные инварианты (например, [`CHECK_DEPENDENT_DIRS`](./common/macros.md#check_dependent_dirs)).
14. *Граф зависимостей* трансформируется в *граф сборочных команд* для конкретной платформы, в котором каждый промежуточный или финальный результат формирует узел с ассоциированной командой,
    входами, выходами и зависимостями от таких же узлов, а также **UID** - хэш от всех собственных зависимостей команды (входов, зависимых файлов, текста команды,
    необходимого окружения, а также *UID*-ов зависимых команд). Команды сборки стартовых модулей становятся в этом графе **результатами**.
15. **Граф сборочных команд сохраняется.**
16. К данному моменту у нас есть граф сборочных команд для одной целевой платформы. От платформы зависят как минимум шаги 1, 3 (ya.make может содержать условные конструкции) и шаг 6.
    (формирование свойств и команд зависит от платформы). Однако, граф сборочных команд может содержать команды сборки сборочных инструментов, а их надо сформировать для сборочной платформы.
17. Находим все сборочные инструменты в графе команд.
18. Для инструментов запускаем шаги 1–16.
19. Заменяем части графа с шага 14, относящиеся к инструментам, на соответствующие части графа с шага 16.
20. Если запрошен запуск тестов - обогащаем граф узлами запуска тестов (это делается отдельным проходом по историческим причинам). Запуск тестов и получение результатов — это обычные узлы в графе команд.
    Чтобы тесты были исполнены, они добавляются к результатам графа. Если запрошена опция `— add-result`, то к результатам добавляются запрошенные промежуточные результаты.
21. Недостижимые от результатов узлы удаляются из графа.
22. *Граф сборочных команд* готов и его можно исполнять.
23. **Исполнение** начинается от результатов.
24. Если *UID* команды есть в кэше, то из кэша поднимается результат.
25. Если нет - пытается построить зависимости по шагам 24.-25.
26. Когда все зависимости построены, исполняем команду в узле.
27. Шаги 24.-25. могут делаться параллельно для независимых команд.
28. Процесс заканчивается, когда результаты построены.

### Немного про сборку Python { #python }

Обычно для Python нет понятия *сборки*, однако ya make собирает Python-код в исполняемые программы (описывается как `PY3_PROGRAM`). В такую программу попадает пре-компилированный код всех
зависимых пакетов, описанных как `PY3_LIBRARY`, код генерированных пакетов, например [`PROTO_LIBRARY`](./proto/modules.md#proto_library) а также, возможно бинарно откомпилированный C/C++ код доступный через биндинги на Cython.
Программа содержит интерпретатор, который и исполняет Python-код начиная с main-функции или модуля, описанных для этой программы.

Подробнее об этом можно прочитать в [разделе о сборке Python](./python)

## Полезные ссылки

- [Начало работы с системой сборки](../general/getting_started.md)
- [Базовые понятия системы сборки ya make](../general/base_concepts.md)
- [Как работает система сборки](../general/how_it_works.md)
- [Использование системы сборки](../usage/ya_make/index.md)
- Описание сборки:
  - [Описание синтаксиса ya.make](./syntax.md)
  - [Общие модули и макросы](./common/index.md)
  - С++: [пошаговое руководство](../tutorials/cpp.md) и [подробная инструкция](./cpp/index.md)
  - Python: [пошаговое руководство](../tutorials/python.md) и [подробная инструкция](./python/index.md)
  - Java: [пошаговое руководство](../tutorials/java.md) и [подробная инструкция](./java/index.md)
  - Go: [пошаговое руководство](../tutorials/go.md) и [подробная инструкция](./go/index.md)
  - Protobuf: [пошаговое руководство](../tutorials/protobuf.md) и [подробная инструкция](./proto/index.md)
  - Flatbuf: [пошаговое руководство](../tutorials/flatbuf.md) и [подробная инструкция](./flatbuf/index.md)
  - [Описание сборки и исполнения тестов](./tests/index.md)
- [Запуск сборки](../usage/ya_make/index.md)
- [Запуск тестов](../usage/ya_make/tests.md)

# Как писать ya.make

Сборка в ya.make-файлах описывается *макросами*. Использование макроса выглядит как `<ИМЯ>([опциональные параметры через пробел])`.
Никаких других конструкций в языке ya.make нет, [`ELSE()`](#if), [`ENDIF()`](#if) и [`END()`](#if) — тоже макросы. Кроме макросов есть только комментарии.
В языке ya.make символом начала комментария является `#` и комментарий длится до конца строки.

Макросы `ya.make` зачитываются последовательно, но не все из них [интерпретируются](./index.md#interp) непосредственно при зачитывании.

Сразу интерпретируются:

- Макросы макросы выставления переменных [`SET`/`SET_APPEND` и подобные](#var_macros). Значения переменных доступы в параметрах других макросов ниже по тексту ya.make. Макросы, внутри которых
  выставляются переменные ведут себя также.
- [Условные конструкции](#if). Они видят сложившиеся значения переменных и выбирают ветку для интерпретации в соответствии со значением условия в конкретной точке ya.make
- [INCLUDE](#include) выполняют текстовую подстановку сразу при чтении ya.make и в позицию, где встречен макрос.
- Макросы, формирующие списки ([`PEERDIR`](./common/macros.md#peerdir), [`ADDINCL`](./common/macros.md#addincl) и т.п.) формируют их в текстуальном порядке. Однако, обрабатываться эти списки могут в произвольном порядке (например, запросто может быть,
  что модуль, написанный в [`PEERDIR`](./common/macros.md#peerdir) позже будет сконфигурирован раньше).

[Макросы модулей](#module_macros), устанавливающие свойства и формирующие команды, макросы задающие зависимости и связи применяются в тот момент, когда соответствующая информация нужна и в порядке,
определяемом самой системой сборки. Полагаться на определённый порядок исполнения таких макросов не стоит.


## Скоупы в ya.make

Некоторые макросы называются *модульными макросами*. Такие макросы определяют начало описания модуля, а также его базовые свойства. Заканчивается описание модуля макросом `END()`.
Между этими макросами содержится собственно всё описание сборки модуля. Таким образом в ya.make-файле выделяется два скоупа:

- **Глобальный** — до начала описания модуля и после него, если модуль есть. Весь файл, если модуля нет.
- **Модульный** — от макроса начала модуля (например [`PROGRAM`](./cpp/modules.md#program)) до макроса `END()`.

### Глобальный скоуп { #global_scope }

Глобальный скоуп — это то, что относится ко всему ya.make-файлу, а не к модулю, который в нём собирается.

Только в глобальном скоупе пишутся:

- **Связи** — макросы [`RECURSE`](./common/macros.md#recurse) и т.п. Этот макрос говорит, что при сборке данного ya.make как цели надо собирать ещё и другие цели — аргументы макроса. Могут существовать ya.make состоящие только из
  [`RECURSE`](./common/macros.md#recurse) и служащие для агрегации сборочных целей. Также [`RECURSE`](./common/macros.md#recurse) и особенно [`RECURSE_FOR_TESTS`](./common/macros.md#recurse) может соседствовать с модулем, например библиотека может добавлять в сборку свой тест, чтобы проверить
  не только сборку, но и линковку.

- **Модули** и END(). Начало и конец модуля могут быть только в глобальном скоупе. Вложенные модули запрещены.

Также в глобальном скоупе могут быть использованы:

- *Информационные* макросы [`OWNER`](./common/macros.md#owner) и [`SUBSCRIBER`](./common/macros.md#subscriber). Они не интерпретируются системой сборки и нужны другим системам.
- [`INCLUDE`](#include) — макрос текстового включения.
- Макросы выставления переменных [`SET`/`SET_APPEND` и подобные](#var_macros). Такие переменные доступны для использования в макросах всего ya.make ниже по тексту, но не влияют на модульные свойства.
  Например, [`SET_APPEND(CFLAGS -fno-lto)`](common/macros.md#set_append) не повлияет на флаги компиляции в модуле, описанном в таком ya.make.
- [Условные конструкции](#if)


В глобальном скоупе можно использовать только [*встроенные*](./index.md#conf) макросы и макросы начала модуля. Все остальные [*конфигурируемые*](./index.md#conf) макросы,
могут быть использованы только в модульном скоупе.

Конструкции, указанные в глобальном скоупе, интерпретируются ровно один раз в любом ya.make, даже в описывающем [*мультимодуль*](./index.md#multi).
Исключение составляет собственно макрос начала [мультимодуля](./index.md#multi):
он интерпретируется как макрос начала модуля, соответствующего варианту. Например, [`PY23_LIBRARY()`](./python/modules.md#py23_library) будет интерпретирован сначала как
[`PY2_LIBRARY`](./python/modules.md#py2_library), а потом как [`PY3_LIBRARY()`](./python/modules.md#py3_library).

__Пример ya.make состоящего только из глобального скоупа:__

```
OWNER(g:owners)

INCLUDE(my_vars.inc)

RECURSE(lib)
IF (WITH_PROGRAM)
    RECURSE(program)
ENDIF()
```


### Модульный скоуп { #mod_scope }

В модульном скоупе располагается всё [описание сборки модуля](./index.md#mod)

В нём размещаются все [макросы, описывающие как собрать этот модуль](./index.md#module_macros), а также какими свойствами этот модуль обладает и какие
[глобальные свойства, переменные и команды](./index.md#globals) он определяет для тех модулей, которые от него зависят.

Там же могут размещаться макросы [выбора вариантов мультимодуля](#multi_macro), доступных для сборки этого конкретного модуля.

Также как и в глобальном, в модульном скоупе могут быть использованы:

- *Информационные* макросы [`OWNER`](./common/macros.md#owner) и [`SUBSCRIBER`](./common/macros.md#subscriber). Они не интерпретируются системой сборки и нужны другим системам.
- [`INCLUDE`](#include) — макрос текстового включения.
- Макросы выставления переменных [`SET`/`SET_APPEND` и подобные](#var_macros). Такие переменные доступны для использования в макросах в пределах модуля ниже по тексту, и могут влиять на модульные свойства.
  Например, [`SET_APPEND(CFLAGS -fno-lto)`](common/macros.md#set_append) поменяет флаги компиляции во всех командах компиляции модуля. Даже если [`SRCS`](./common/macros.md#srcs) с перечислением исходных файлов написано выше по тексту.
- [Условные конструкции](#if)

{% note alert %}

В `ya.make` файлах можно встретить `IF` разрывающий скоуп модуля примерно так:

```
IF(DYNAMIC)
    DLL()
        EXPORT_SCRIPT(my.exports)
ELSE()
    LIBRARY()
ENDIF()
        SRCS(
            some_file.cpp
        )
    END()
```

Работоспособность этой конструкции не гарантируется. Это пока может работать для некоторых типов модулей, а для других работать не будет. Мы не рекомендуем использовать разные типы модуля по однному пути в разных случаях в принципе, но если это необходимо, то правильный способ - убрать под `IF` весь модуль и вынести общую часть через `INCLUDE`.

```
IF(DYNAMIC)
    DLL()
        EXPORT_SCRIPT(my.exports)
        INCLUDE(module_body.inc)
    END()
ELSE()
    LIBRARY()
        INCLUDE(module_body.inc)
    END()
ENDIF()
```

{% endnote %}

## Макросы

Сборка в ya.make-файлах описывается *макросами*. Использование макроса выглядит как `<ИМЯ>(параметры)`. Исторически для их именования используется
[SCREAMING_SNAKE_CASE](https://ru.wikipedia.org/wiki/Snake_case).

Система сборки ya make предоставляет огромное количество макросов для различных языков и применений. Они описаны в соответствующих разделах:

- [Макросы для C++](cpp/macros.md)
- [Макросы для Python](python/macros.md)
- [Макросы для Java](java/macros.md)
- [Макросы для Go](go/macros.md)
- [Макросы для Protocol Buffers](proto/macros.md)
- [Макросы для Flat Buffers](flatbuf/macros.md)
- [Макросы для агрегации](package/macros.md)
- [Макросы для тестов](tests/common.md)
- [Полный автогенерируемый набор макросов в Аркадии](https://a.yandex-team.ru/arc_vcs/build/docs/readme.md)
- [Откуда берутся модули и макросы](#conf)

Ниже приводится информация общая для всех вызовов макросов, а также специальные макросы, общие для всех языков.


### Передача параметров

Параметры в макросах ya.make разделяются пробелами или переводами строк соответственно в большинстве случаев каждое отдельное слово — это отдельный параметр.
Макросы с длинным набором параметров можно переносить на несколько строк, разделяя по параметрам. Множественные пробелы в отступах считаются одним разделителем.

Поэтому можно так:

```
SET(FILE_LIST x y z)
```

Или так
```
SET(FILE_LIST
    x y z)
```
Или так
```
SET(
   FILE_LIST
   x
   y
   z
)
```

### Типы и виды параметров

Параметры в ya.make бывают всего трёх типов: строки, списки строк и булевы (по признаку наличия, см. ниже).

Параметры в ya.make бывают *именованные* и *неименованные*.

**Неименованные параметры** участвуют в вызове своим значением, они бывают:

- **Скалярные** — значением параметра является строка (одно слово). Иногда такой параметр может быть опциональным. Например, имя модуля 
   (параметр макроса заголовка модуля) — это обычно опциональный скалярный параметр.  Если таких параметров несколько, они принимают свои
   значения в соответствии с позицией

  - В документации обычно параметр описывается как `<значение>` (обязательный) или `[<значение>]` опциональный. Иногда угловые скобки опущены для читаемости.
    Важно, что слово, обозначающее значение, в таком случае одно и оно не целиком заглавными буквами.

  __Примеры:__
  ```
  ### @usage: PY_NAMESPACE(<name.space>)
  PY_NAMESPACE(my.namespace)
  .
  ### @usage: KV(<Key> <Value>)
  KV(the_key, the_value) # Key=the_key, Value=the_value
  ```

- **Свободно-списочные** — значением параметра является список всех строк (слов), не отнесённых ни к какому другому параметру. Если таких не находится, список остаётся пустым.
  - В документации такой параметр описывается как `Значение...`. 

  __Примеры:__
  ```
  ### @usage: ALL_SRCS([GLOBAL] Filenames...)
  .
  ALL_SRCS(x.cpp GLOBAL y.cpp)       # Filenames=x.cpp y.cpp, GLOBAL=True
  .
  ### @usage: SRC(<File>, Flags...)
  SRCS(x.cpp -Wno-error -std=c++17)  # Flags=-Wno-error -std=c++17
  SRCS(y.cpp)                        # Flags=<empty>
  ```

**Именованные параметры** участвуют в вызове своим именем и, возможно, значением. Исторически для именования параметров макросов, как и самих макросов, используется
(SCREAMING_SNAKE_CASE)[https://ru.wikipedia.org/wiki/Snake_case].

Именованные параметры бывают:

- **Булевы** — значение параметра определяется в описании самого макроса, а в вызове различается факт присутствия параметра в списке (*истина*) или отсутствия (*ложь*).
  - В документации такой параметр описывается как `[PARM_NAME]`. Важно, что в данном случае имя параметра написано целиком большими буквами и без угловых скобок.

  __Пример:__
  ```
  ### @usage: ALL_SRCS([GLOBAL] Filenames...)
  .
  ALL_SRCS(GLOBAL x.cpp y.cpp)  # GLOBAL is True
  ALL_SRCS(a.cpp b.cpp)         # GLOBAL is False
  ```

- **Скалярные** — значением параметра является строка (слово), идущее в вызове сразу после имени параметра. Такой параметр может быть *опциональным*, если он не указан,
  то параметр получит значение по умолчанию.
  - В документации такой параметр выглядит как `NAME <value>` или `[NAME <value>]`. Имя параметра целиком большими буквами, а значение — одно слово в угловых скобках.

  __Примеры:__
  ```
  ### @usage: COMPILE_LUA(Src, [NAME <import_name>])
  .
  COMPILE_LUA(func.lua NAME my.func)  # NAME=my.func
  COMPILE_LUA(the_func.lua)           # NAME=<default>
  ```

- **Списочные** — значением параметра является список строк (слов), идущих после имени параметра и до следующего имени параметра или закрывающей скобки.
  Имя параметра может встречаться в строке несколько раз, давая в результате конкатенацию всех списков. Если имя параметра не встречается, список остаётся пустым.
  - В документации такой параметр выглядит как `NAME <list of values>` или `[NAME <list of values>]`. Имя параметра целиком большими буквами, а
    значение — несколько слов в угловых скобках. 

  __Пример:__
  ```  
  ### @usage: FROM_ARCHIVE(Src [RENAME <resource files>] OUT <output files> [PREFIX <prefix>] [EXECUTABLE])
  # Src    - обязательный неименованный скалярный
  # RENAME - опциональный именованный списочный
  # OUT    - обязательный именованный списочный
  # PREFIX - опциональный именованный скалярный
  # EXECUTABLE - булев
  .
  FROM_ARCHIVE(
      resource.tar.gz
      PREFIX y
      RENAME y/a.txt OUT y/1.txt
      RENAME y/b/c.txt OUT y/2.txt
      RENAME RESOURCE OUT 3.tar.gz
      OUT y/d.txt
  )
  # Src=resource.tar.gz 
  # PREFIX=y
  # RENAME=y/a.txt y/b/c.txt RESOURCE  ## RESOURCE в данном случае значение, а не имя параметра
  # OUT=y/1.txt y/2.txt 3.tar.gz y/d.txt
  ```

### Экранирование значений параметров

Для объединения нескольких слов в параметре в одно можно использовать `"..."` (двойные кавычки) или, если что-то идёт не так `"'...'"` одинарные кавычки внутри двойных.

{% note warning %}

Экранирование кавычками может работать только на весь список параметров. Например:

Значением переменной будет одна неразрывная строка:
```
SET(FILE_LIST "a.x b.x c.x")
```

Значением переменной станет список из 4-х элементов, а не из 3-х:
```
SET(FILE_LIST a.x "with space.x" c.x)
```
{% endnote %}


{% note warning %}

Внутри ya make в качестве разделителя также используется запятая (`,`) и в некоторых случаях её невозможно надёжно экранировать. Единственным надёжным решением на данный
момент является использование специальной переменной `${__COMMA__}`

{% endnote %}

Пример:

```
SET(
  OPENAPI_GENERATOR_GENERATE_MODELS_VALUE
  models${__COMMA__}apis=false${__COMMA__}modelTests=false${__COMMA__}apiTests=false${__COMMA__}modelDocs=false${__COMMA__}apiDocs=false
)
```

### Интерпретация значений параметров

Параметрами макросов может быть практически что угодно и интерпретацией параметров могут заниматься разные системы в разные моменты времени:

- Часть значений интерпретирует сама система сборки. При чём это касается не только *встроенных* макросов, но и [*конфигурируемых*](./index.md#conf).
  Встроенные макросы могут полностью разбирать свои параметры, например [логические выражения в `IF`](#if), а также могут [интерпретировать имена директорий](#dirs).
  Для [имён файлов есть общая интерпретация](#files). Они могут обрабатываться, формируя входы, результаты, текстовые параметры команд.
  Система сборки также поддерживает ограниченный набор строковых и списочных операций для превращения значений параметров в параметры сборочных команд. Но как-то глубоко
  интерпретировать строковые значения она не умеет.

- Часть значений с помощью системы сборки могут интерпретировать [плагины для макросов](./index.md#plugins). Поскольку они пишутся на развитых языках программирования,
  их возможности в интерпретации значений практически неограниченны. Единственное ограничение к плагинам — это скорость их работы.

- Многие значения параметров макросов долетают до сборочных команд и интерпретируются уже самими командами во время исполнения. При чём это могут быть как оригинальные
  сборочные инструменты, так и их обёртки (обычно на языке Python). Большая часть таких обёрток описана в [build/scripts](https://a.yandex-team.ru/arc_vcs/build/scripts).
  Сама система сборки (своей исполнительной подсистемой), тоже может кое-что интерпретировать на этом этапе. Она поддерживает:
  - Свёртку списков параметров в файлы аргументов
  - Подстановку ссылок на глобальные ресурсы (переменные вроде `$(PYTHON)`)
  - Подстановку путей до дерева исходного кода и дерева сборки (новое на каждую сборочную команду) — переменные `$(ARCADIA_ROOT)` и `$(BUILD_ROOT)`.

#### Имена директорий { #dirs }

Макросы, такие как [`PEERDIR`](./common/macros.md#peerdir), [`ADDINCL`](./common/macros.md#addincl), [`RECURSE`](./common/macros.md#recurse) и [`DATA`](common/data.md#data) принимают имена директорий. Однако в этих конкретных 4-х макросах 4 различных интерпретации этих путей:

- [`ADDINCL`](./common/macros.md#addincl), а также [`SRCDIR`](./common/macros.md#srcdir) интерпретируют директории просто как пути. Далее они используются для [отображения имён на файлы](../general/how_it_works.md#resolving),
  но, по сути, это просто строки с дополнительной проверкой их наличия в дереве исходных файлов.
  В такие макросы можно передать как директорию в дереве исходных файлов, так и в дереве результатов сборки. Путь требуется всегда от корня репозитория и без [явного указания](common/vars.md#dir_vars)
  он считается в дереве исходных файлов. 

- [`PEERDIR`](./common/macros.md#peerdir) интерпретирует имена директорий, как ссылки на модули, которые будут там собраны. Это же справедливо для других макросов [межмодульных зависимостей](./index.md#mod_deps) --
  [`DEPENDS`](./tests/common.md#depends), [`BUNDLE`](./common/macros.md#bundle) и [`RUN_PROGRAM`](./common/macros.md#run_program), где директория указывается первым параметром как путь до инструмента. Путь в данном случае интерпретируется достаточно сложным образом:
  - Путь всегда интерпретируется как путь от корня репозитория. Корень указывать нельзя и не имеет смысла: генерированных ya.make не бывает (ну то есть сгенерировать можно,
    но интерпретироваться они не будут). 
  - В дереве исходных файлов должен лежать ya.make описывающий сборку.
  - Результатом этой сборки будет артефакт в аналогичном месте дерева результатов сборки. Зависимость получается от него.
  - В случае, если в ya.make описан [мультимодуль](./index.md#multi), то будет выбран подходящий для данной зависимости.

- [`RECURSE`](./common/macros.md#recurse) и подобные макросы интерпретируют имена директорий, как пути до ya.make в этих директориях. Все макросы, кроме [`RECURSE_ROOT_RELATIVE`](./common/macros.md#recurse) требуют пути относительно текущей директории.
  [`RECURSE_ROOT_RELATIVE`](./common/macros.md#recurse) требует пути от корня в дереве исходного кода. Корень указывать нельзя и не имеет смысла: генерированных ya.make не бывает (ну то есть сгенерировать можно,
   но интерпретироваться они не будут). 
   
- [`DATA`](common/data.md#data) интерпретирует директории, как зависимость от всех файлов в этой директории. Аналогично работают макросы, собирающие файлы по шаблону, например [`ALL_PY_SRCS`](python/macros.md#all_py_srcs).
  В [`DATA`](common/data.md#data) по историческим причинам путь внутри репозитория указывается как `arcadia/<path_from_root>`. При чём путём может быть как директория, так и файл. В любом случае зависимость допустима только
  на исходные файлы. Директории не могут быть результатами сборки и даже для файлов [резолвинг](../general/how_it_works.md#resolving) для [`DATA`](common/data.md#data) не работает.

- В большинство остальные макросы можно передать имя директории как строку, и она будет интерпретироваться как путь только самой сборочной командой.

#### Имена файлов { #files }

Многие макросы принимают имена файлов. В подавляющем большинстве случаев эти имена трактуются как имена входных файлов.

Некоторые макросы, такие как [`INCLUDE`](#include) и [`INDUCED_DEPS`](common/macros.md#induced_deps) требуют указания *полных имён файла* включая корень, к которому этот файл относится
(корень репозитория исходных файлов или корень результатов сборки). Корни указываются с помощью [специальных встроенных переменных](common/vars.md#dir_vars).

Основная часть макросов этого не требует и имена файлов [отображаются на реальные файлы (*резолвятся*)](../general/how_it_works.md#resolving). Реальное имя потом может быть
непосредственно интерпретировано как вход команды и/или обработано чтобы сформировать имя результата команды, а также текстуальное представление этого имени в строке запуска команды.
Кроме того, обработка, может, например включать получение директории по файлу и помещение этой директории в [`ADDINCL`](./common/macros.md#addincl) для модуля, где написан вызов макроса на этом файле.

{% note tip %}

Если в макросе имя файла встречается в *текстовой позиции* (там, где оно не должно по идее интерпретироваться) и в позиции входа (там, где применяется [резолвинг](../general/how_it_works.md#resolving))
Имя файла заменится на *реальное* в обеих позициях. Если команда к такому не готова необходимо каким-то образом сделать имя в команде отличающимся от реального. 

__Пример:__

```
    RUN_PROGRAM(tools/x2y a.x IN a.x OUT_NOAUTO a.y)   # Здесь a.x в первой позиции заменится на полное
# vs
    RUN_PROGRAM(tools/x2y a.x- IN a.x OUT_NOAUTO a.y)  # Здесь a.x- останется как есть и будет
                                                       # интерпретироваться инструментом
```

{% endnote %}

Поскольку [отображение имён на файлы](../general/how_it_works.md#resolving) может получить ссылку на результат исполнения другой команды. Через этот механизм команды связываются между собой
зависимостями. Так можно написать цепочку зависимых макросов [`RUN_PROGRAM`](./common/macros.md#run_program) обрабатывающих один файл в несколько этапов.

__Пример:__

```
OWNER(g:generators)

LIBRARY(mylib)
    # Ниже $S — это ссылка на корень репозитория исходного кода
    #      $B — это ссылка на директорию с результатами сборки
    # $B будет разный у каждой команды, но совпадение на этом уровне обеспечивает связывание между командами.
    # Перенос данных между командами осуществляется системой сборки в процессе исполнения

    # Сконвертируем a.x в a.y
    # a.x _отобразится_ на $S/libs/my/a.x как вход (IN)
    # a.y _сгенерируется_ как $B/libs/my/a.y инструментом в tool/x2y и будет _предсказан_ таким в OUT_NOAUTO
    RUN_PROGRAM(tools/x2y a IN a.x OUT_NOAUTO a.y)


    # Теперь сконвертируем a.y в a.z
    # a.y _отобразится_ на $B/libs/my/a.y как вход (IN) в силу отсутствия $S/libs/my/a.y
    # Это приведёт к зависимости от предыдущей команды (порядок команд на самом деле не важен)   
    # a.z _сгенерируется_ как $B/libs/my/a.z инструментом в tool/y2z и будет _предсказан_ таким в OUT_NOAUTO
    RUN_PROGRAM(tools/y2z a IN a.y OUT_NOAUTO a.z)

    # Теперь сконвертируем a.z в a.cpp
    # a.z _отобразится_ на $B/libs/my/a.z как вход (IN) в силу отсутствия $S/libs/my/a.z
    # Это приведёт к зависимости от предыдущей команды (порядок команд на самом деле не важен)   
    # a.cpp _сгенерируется_ как $B/libs/my/a.cpp инструментом в tool/y2z и будет _предсказан_ таким в OUT
    RUN_PROGRAM(tools/z2cpp a IN a.z OUT a.cpp)

    # Дальше в силу OUT для $B/libs/my/a.cpp и наличия автоматической обработки для .cpp 
    # $B/libs/my/a.cpp будет скомпилирован в $B/libs/my/a.cpp.o
    
    # Ещё дальше в силу автоматической обработки .o на уровне модуля
    # $B/libs/my/a.cpp.o поступит на вход модульной команды и попадёт в библиотеку mylib.a
END()


```

Более того, [отображение имён на файлы](../general/how_it_works.md#resolving) работает через границы модулей, поэтому поставив зависимость на библиотеку из примера выше
можно получить генерированный файл как вход в макросе в другом модуле:

__Ещё один пример:__

```
OWNER(g:generators)

LIBRARY(deplib)
    # Ниже $S — это ссылка на корень репозитория исходного кода
    #      $B — это ссылка на директорию с результатами сборки
    # $B будет разный у каждой команды, но совпадение на этом уровне обеспечивает связывание между командами
    # Перенос данных между командами осуществляется системой сборки в процессе исполнения

    PEERDIR(libs/my)             # Директория, где живёт mylib в репозитории

    # Сконвертируем a.y в a.сpp
    # a.y _отобразится_ на $B/libs/my/a.y, который найдётся в силу PEERDIR
    # Он будет засчитан как зависимость и одновременно подставится в команду (в параметр --input)
    # Это приведёт к зависимости от команды из другого модуля
    # a.cpp _сгенерируется_ как $B/libs/dep/a.cpp инструментом в tool/y2cpp и будет _предсказан_ таким в OUT_NOAUTO
    # Заметим, что результат будет в директории нашего модуля и потому не совпадёт по имени с таковым у mylib
    RUN_PROGRAM(tools/y2cpp a --input a.y IN ${ARCADIA_BUILD_ROOT}/libs/my/a.y OUT_NOAUTO a.cpp)

    # Дальше всё отработает как в примере выше
END()

```


## Переменные { #vars }

В ya.make активно используются переменные. Переменные содержат значения, которые можно передавать в макросы, включая [условные](#if). По историческим причинам переменные 
именуются в (SCREAMING_SNAKE_CASE)[https://ru.wikipedia.org/wiki/Snake_case], но пользовательские переменные могут использовать и другие схемы именования.


Значения переменных — это всегда строки или списки строк (слов), разделённые пробелом. 

__Пример:__

```
LIBRARY()

SET(MSG "Hello wor!d")
SET(SOURCES greet.cpp colors.cpp)

SSRCS($SOURCES)  # Here will be list
MESSAGE($MSG)    # Here will be just string

END()
```

Семантически значения переменных могут быть очень [разными](#var_sources). Они могут приходить извне как свойства [платформы/конфигурации](../general/base_concepts.md#configs),
а могут быть [заданы](#var_macros) прямо в этом же ya.make-файле.

Использование переменной обычно выглядит как `$VAR_NAME` или `${VAR_NAME}` и обычно заменяется на значения в момент использования. Однако,
часть переменных вычисляется позже. Такие переменные нельзя использовать в [условных конструкциях](#if) и их значение может остаться нераскрытым
при использовании в значении макроса [`SET` и подобных](#var_macros).

К таким переменным относятся:

- Переменные [`ARCADIA_ROOT`, `ARCADIA_BUILD_ROOT`, `CURDIR` и `BINDIR`](common/vars.md#dir_vars): в ссылках на файлы они интерпретируются прямо по именам (без подстановки),
  но, например, при использовании их как части значения в макросе (`SET`)[#var_macros] они останутся не подставленными.

- Глобальные переменные вроде `LDFLAGS`, `PEERS` и т.п. определяются очень поздно, когда полностью построен [граф зависимостей](../general/how_it_works.md#build_deps).
  Поэтому никаких внятных значений в них быть не может. На них можно сослаться с тем, чтобы они попали в текст команд и позже раскрылись, но никакие проверки
  относительно них сделать нельзя.

### Откуда берутся переменные { #var_sources }

Есть 5 источников переменных:

1. Встроенные переменные. Эти переменные система сборки предоставляет сама. К ним относятся переменные [`ARCADIA_ROOT` и подобные](common/vars.md#dir_vars), перемененные `PEERS`. `INCLUDE`, `TARGET` и т.п.,
   которые позволяют получить свойства модуля такие как его зависимости, пути поиска инклудов, имя главного результата его сборки и т.п.

2. Переменные переданные через [командную строку](../usage/ya_make/index.md#D).

3. Переменные, описанные в [конфигурации](./index.md#conf). Эти переменные бывают двух видов:
   - Общие, [описывающие](common/vars.md#platform_vars) текущую [сборочную конфигурацию](../general/base_concepts.md#configs), например `OS_LINUX` или `SANITIZER_TYPE`. Обычно менять такие переменные не имеет смысла.
     Однако, [часть таких переменных](common/vars.md#D) имеет смысл значений по умолчанию и для конкретного модуля они могут быть изменены. Например, по умолчанию в сборке выставлено `STRP=no` для сохранения
     отладочной информации, но модуль, где это не нужно может [переопределить](#var_macros) эту переменную в значение `yes` макросом `STRIP()`.
   - Модульные, относящиеся к свойствам модуля или его команд (например, `CFLAGS`). Обычно такие переменные имеют значения по умолчанию, но могут быть [переопределены](#var_macros) в модуле.

4. [Глобальные переменные](./index.md#global), пришедшие по зависимостям. Такие переменные подставляются поздно, поэтому прочитать их значение в ya.make не получится. Однако, они могут быть
   отданы в макросы, создающие команды, чтобы значение подставилось в текст команды. Однако, обычно такие переменные уже используются в командах и передавать их явно не нужно. Модуль может
   изменить значение такой переменной и другие, зависящие от него, модули его получат. Так, например, макрос `LDFLAGS` собирает флаги нужные библиотекам в переменную `LDFLAGS`, которая
   используется в команде модуля  [`PROGRAM`](./cpp/modules.md#program), которая отвечают за линковку программ.

5. Переменные, [установленные](#var_macros) пользователем в этом ya.make или в тех, которые этот ya.make [включает](#onclude).


### Макросы установки переменных { #var_macros }

Для работы с переменными предусмотрены макросы [`SET`](./common/macros.md#set), [`SET_APPEND`](./common/macros.md#set_append), [`DEFAULT`](./common/macros.md#default), 
[`ENABLE`](./common/macros.md#enable) и [`DISABLE`](./common/macros.md#enable).

Все они позволяют так или иначе задать значения переменных. Их можно использовать как в [глобальном скоупе](#global_scope), так и в [модульном](#mod_scope). 

- В глобальном скоупе можно определить новые переменные, которые не описаны в [конфигурации](./index.md#conf). Действовать такие переменные будут во всём ya.make.

- В модульном скоупе также можно определить новые переменные, которые не описаны в [конфигурации](./index.md#conf). Но кроме того, можно переопределить
  переменные, описанные там, как общие, так и специфичные данному типу модуля. В любом случае такие переменные выставляются на модуль и, например, в разных вариантах
  [мультимодуля](./index.md#multi) с помощью макроса [`IF`](#if) им можно задать разные значения. Также можно изменить значения [глобальных переменных](./index.md#global)
  и они распространяться в модули, зависящие от данного. 


Макросы, принимающие значения ([`SET`](./common/macros.md#set), [`SET_APPEND`](./common/macros.md#set_append), [`DEFAULT`](./common/macros.md#default)) могут иметь ссылки на другие переменные как часть значения. Например:

```
SET(SUFFIX res)
SET(INP xx.scheme)
SET(OUTP $(MODDIR)/${INP}.${SUFFIX})
```

При этом все переменные, кроме тех, что вычисляются поздно будут сразу подставлены, *поздние* переменные останутся как есть. Если такое значение, с не подставленной переменной
окажется в контексте, где значение не подставленной переменной станет известно (например, в тексте команды), то оно подставится.


Макросы установки переменных создают новые переменные, если переменная с таким именем не описана в конфигурации. В этом случае её надо использовать ниже по тексту непосредственно в макросах
модуля или всего ya.make (если переменная установлена вне модуля). Однако, если переменные описаны в [конфигурации](./index.md#conf) модуля или макросов модуля, то макрос переопределит значение
такой переменной.

__Пример:__

```
SRCS(x.cpp)               # Здесь внутри используется CFLAGS

SET(LLVM_VER 11)          # LLVM_VER создаётся здесь

PEERDIR(contrib/libs/llvm${LLVM_VER})       # LLVM_VER здесь подставится по сложившемуся значению

# SET(LLVM_VER 8)         # Это та же LLVM_VER, но это бы повлияло на IF ниже, но не на PEERDIR выше.

IF (LLVM_VER == 11)
  SET(CFLAGS -Wno-error)  # Это влияет на SRCS выше
ENDIF()

```

### Полезные ссылки

- Макросы установки переменных [`SET`](./common/macros.md#set), [`SET_APPEND`](./common/macros.md#set_append), [`DEFAULT`](./common/macros.md#default).
[`ENABLE`](./common/macros.md#enable) и [`DISABLE`](./common/macros.md#enable).
- Общие [встроенные переменные](common/vars.md#dir_vars).
- Общие [переменные платформ и конфигураций](common/vars.md#platform_vars).
- Общие [переопределяемые переменные](common/vars.md#D).
- Переменные сконфигурированные для [C++](cpp/vars.md), [Python](python/vars.md), [Java](java/vars.md), [Go](go/vars.md), [Protobuf](proto/vars.md), [Flatbuf](flatbuf/vars.md).

## Специальные макросы

### INCLUDE { #include }

Система сборки ya make поддерживает текстовые включения макросом `INCLUDE(<full_file_name>)`. Текст из файла, переданного параметром будет подставлен вместо `INCLUDE` и интерпретирован.

Соответственно этот текст:

- Будет относиться к тому же скоупу, что и макрос `INCLUDE`.
- [Переменные](#vars), определённые в тексте будут определять модульные переменные, если `INCLUDE` размещён в модуле и будут видны в [условных конструкциях](#if) и параметрах других макросов ниже этого макроса.
- [Переменные](#vars), определённые выше `INCLUDE` будут доступны в параметрах макросов включённого файла, включая [условных конструкциях](#if)
- Сейчас по умолчанию включения файлов обрабатываются каждый раз, когда встречаются при интерпретации ya.make и включенных в него файлов. В частности макросы [`SET_APPEND`](common/macros#set_append) во включенном файле будут вызваны столько раз, сколько встрется файл внутри одного ya.make.
  Это может привести к неоправданному росту значений переменных. Изменить поведение на однократную обработку для каждого начального `ya.make` можно макросом [`INCLUDE_ONCE`](#include_once).
- `INCLUDE` внутри [мультимодуля](./index.md#multi), независимо от реальной реализации, действует так, словно все текстовые ключения сделаны до порождения вариантов [мультимодуля](./index.md#multi). Т.е. конструкции из включенного файла будут интерптетированы во всех вариантах [мультимодуля](./index.md#multi).

Параметром макросом должно быть полное имя, с указанием [`${ARCADIA_ROOT}/`](common/vars.md#dir_vars) как принадлежность к дереву исходных файлов. 

{% note warning %}

Циклические текстовые включения запрещены и вызывают ошибку конфигурирования.

{% endnote %}

{% note alert %}

Включайте файлы так, чтобы границы модуля (макрос начала модуля и `END`) и части конструкции [`IF/ELSEIF/ELSE/ENDIF`](common/macros#if) находились в одном файле. Даже если вынос начала модуля в отдельный файл сейчас работает, не гарантируется, что это продолжит работать.

**Хорошо:**
```
PY23_TEST()

INCLUDE(${ARCADIA_ROOT}/project/tests_body.inc)

END()
```
**или**

mod.inc

```
PY23_TEST()

TEST_SRCS($FILES)

END()
```

ya.make
```
SET(FILE test_my.py)
INCLUDE(mod.inc)
```

**Плохо:**

mod.inc
```
PY23_TEST()

SIZE(MEDIUM)
```

ya.make
```
INCLUDE(mod.inc)

TEST_SRCS(test_my.py)
END()
```

{% endnote %}

### INCLUDE_ONCE

```
INCLUDE_ONCE([yes|no])
```

Тестовые включения могут приводить к тому, что один и тот же файл будет по разным путям от основного ya.make включен несколько раз.
Это будет приводить к замедлению работы а также, возможно, к дублированию значений при вызове макроса [`SET_APPEND`](common/macros#set_append).

Чтобы избежать этого рекомендуется использовать макрос `INCLUDE_ONCE()`. Файл, в котором написан такой макрос будет обработан только один раз для
каждого `ya.make`-файла. Остальные его включения при обработке этого `ya.make` будут проигнорированы.

- Макрос без параметров или с параметром `yes` включает однократную обработку файла.
- Макрос с параметром `no` выключает однократную обработку файла. Это может быть полезно чтобы зафиксировать явно, что файл
  предназначен для многократного включения. И особенно это будет полезно при смене поведения [`INCLUDE`](#include) по-умолчанию.

{% note tip %}

Где бы макрос `INCLUDE_ONCE` не исполнился в файле, этот файл не будет интерпретирован второй раз. Однако рекомендуется писать 
макрос в самом начале файла и настоятельно не рекомендуется ставить его под [`IF`](common/macros#if).

{% endnote %}


### Условные конструкции { #if }

Система сборки позволяет чтобы сделать часть макросов в ya.make обрабатывалась только при определённых условиях. Для этого служат
[условные конструкции IF/ELSEIF/ELSE/ENDIF](common/macros.md#if)

```
IF (Expr)
    ...
ELSEIF (Expr)
    ...
ELSE()
    ...
ENDIF()
```

Условия могут быть наложены на значения любых доступных [переменных](#vars), как определённых выше по тексту макросами [`SET`](#var_macros), так и [пришедших извне](#var_sources).

Синтаксис макроса и, в частности, доступные условия описаны в [соответствующем разделе](common/macros#if).

Условные конструкции исполняются непосредственно во время интерпретации ya.make и оперируют значениями переменных, сложившимися к тому моменту, когда
до `IF` дошла очередь. Это имеет два следствия:

1. Непосредственная интерпретация не гарантирует даже валидации конструкций в ветви, которая не была выполнена.
2. Переменные могут отражать не окончательную конфигурацию модуля. Конструкции ниже по тексту могут напрямую (перезаписав значения переменных) или косвенно (через правила конфигурации)
   изменить значения переменной, на которую наложены условия. А некоторые переменные вносят вклад в конфигурацию, но не определяют свойство самостоятельно.

   Так, например, переменная `ALLOCATOR` выставляется макросом `ALLOCATOR()`. Однако, она определяет лишь желаемый аллокатор для программы. Он может быть недоступен на данной платформе или
   в данной конфигурации. В этом случае значение переменной и реальное свойство модуля разойдутся.


### Работа с мультимодулями

Поскольку [*мультимодуль*](./index.md#multi) описывает сборку сразу нескольких разных модулей, то есть конструкции, позволяющие:

- Отключить какие-то варианты мультимодуля, например, потому что код с ними несовместим, или наоборот включить отключенные по умолчанию варианты.
- Сделать разное поведение для разных вариантов в мультимодуле
- Переопределить варианты мультимодулей, доступные по [`PEERDIR`](./common/macros.md#peerdir) из данного.

У каждого варианта в мультимодуле есть тэг (`Tag`) — имя варианта. Имена уникальны только внутри конкретного типа мультимодуля, но могут переиспользоваться между разными типами
для упрощения настройки. Так тэг `PY3` стоит на варианте для Python 3 в большинстве мультимодулей. 

#### `EXCLUDE_TAGS`,`INCLUDE_TAGS`,`ONLY_TAGS` { #multi_macro }

Макросы `EXCLUDE_TAGS`,`INCLUDE_TAGS`,`ONLY_TAGS` позволяют управлять доступным набором вариантов в каждом конкретном мультимодуле.

- `EXCLUDE_TAGS(Tags...)` позволяет исключить полностью варианты из мультимодуля. Эти варианты не будут конфигурироваться и не будут доступны по [`PEERDIR`](./common/macros.md#peerdir)
   из совместимых с ними модулей, вместо этого будет выдаваться ошибка.

- `ICLUDE_TAGS(Tags...)` позволяет включить варианты в мультимодуль если они существуют, но отключены для него по умолчанию.

- `ONLY_TAGS(Tags...)` позволяет оставить только перечисленные набор вариантов в мультимодуле.

{% note warning %}

Рекомендуется писать эти макросы ближе к началу. Макросы интерпретируются на обработке первого варианта мультимодуля. Если первый вариант исключается макросом, то после макроса
интерпретация этого варианта прекращается, но, если до его достижения у интерпретации были внешние эффекты (например, ошибки), они могут быть выданы.

{% endnote %}

#### `MODULE_TAG` и `PEERDIR_TAGS`

Работа мультимодулей в существенной части построена на двух свойствах:

- Тэг варианта модуля. Он позволяет идентифицировать вариант и потому используется в случаях, когда надо на вариант сослаться.
- Набор тэгов для зависимостей — список тэгов вариантов, которые будут выбираться при PEERDIR из модуля (или варианта мультимодуля) на мультимодуль.

Тэг варианта модуля доступен на чтение через переменную `MODULE_TAG`. В частности, на `MODULE_TAG` можно писать условия, чтобы изменить поведение для отдельного варианта

__Пример:__

```
OWNER(user)

PY23_LIBRARY()

   PY_SRCS(soource.py)

   IF ($MODULE_TAG == "PY2")
       PEERDIR(contrib/python/six)
   ENDIF()
END()
```

Многие мультимодули определяют специальные переменные, чтобы упростить такие условия и не думать об именах тэгов. Пример выше можно переписать так:

```
OWNER(user)

PY23_LIBRARY()

   PY_SRCS(soource.py)

   IF (PYTHON2) 
       PEERDIR(contrib/python/six)
   ENDIF()
END()
```
Переменная [`PYTHON2`](./python/vars.md#py_ver) определена во всех модулях на Python 2 включая соответствующие варианты мультимодулей.


{% note alert %}

Технически переменную `MODULE_TAG` можно переопределить макросом [`SET`](#var_macros), но делать этого не рекомендуется: поведение может быть непредсказуемым.

{% endnote %}

Список тэгов для зависимостей определяется переменной `PEERDIR_TAGS`. Эта переменная содержит список имён вариантов, при чём для каждого мультимодуля там должен быть не более чем 1 вариант
(зависеть от нескольких вариантов одного мультимодуля запрещено). Список задан на каждый тип модуля и его можно модифицировать макросом [`SET`](#var_macros). Поскольку такие макросы отрабатывают
раньше, чем [`PEERDIR`](./common/macros.md#peerdir), то изменения будут применены и зависимости будут настроены правильно.

## Как формируется сборка модуля

Чтобы понять, как в итоге будет строиться модуль нужно знать следующее:
1. Макросы могут [описывать команды](../general/how_it_works#macro_conf), в описании любой команды указано какие у неё будут выходы и что она считает своими входами (обычно они формируются из параметров макроса и [резолвятся](../general/how_it_works#resolving) в файлы или выходы других команд)
2. Другим источником команд является [обработка файлов по расширениям](./extensions#srcs). По сути если мы видим файл в макросе [`SRCS`](./common/macros#srcs) или как выход другой команды, не помеченный в соответствующем макросе как `OUT_NOAUTO`, то под капотом вызывается макрос, зарегистрированный на расширение этого файла. Этот макрос также, как и в предыдущем случае, порождает команду. Входом этой команды будет файл, а выходом другой файл с именем, полученным из имени входного файла. Так, например, для файла `x.cpp` вызовется макрос, порождающий команду компиляции с выходом `x.cpp.o`. Если бы для `.o` была обработка по расширению, то для него бы тоже добавилась команда.
3. При анализе зависимостей мы делаем также [резолвинг инклудов](../general/how_it_works#incl_resolve). Через него команда обработки файла получает дополнительные входы - *инклуды* этого файла.
4. Модули [описываются похожим образом](../general/how_it_works#mod_conf). Для них также описываются команды с выходами и входами. Но кроме того, для модулей описывается то, файлы с какими расширениями будут его *автоматическими входами*. Все файлы с такими расщирениями не будут подхватываться командой автоматической обработкой по расщиреням, а попадут входами в команду модуля.

Соответсвенно по описанию ya.make сборка модуля формируется следующим образом:
1. По макросам формируются команды, они связываются в цепочки если вход одной команды ссылается на выход другой (через указание имён в соотвествующих макросах и их [резолвинг](../general/how_it_works#resolving) или если файл, обрабатываемый командой, включает (инклудит) файл, произведённый другой командой.
2. Выстраиваются цепочки команд автоматической обработки файлов по расширениям, пока результат в цепочке не получит расширение, являющееся *автоматическим входом* модуля.
3. Формируется команда модуля, которая получает на вход все файлы с расширенями *автоматических входов*.

Соотвественно чтобы построить модуль надо будет исполнить команду модуля, а перед ней по зависимостям те команды, которые нужны модульной. Команды недостижимые из какой-то модульной будут удалены.

{% note info %}

[Резолвинг](../general/how_it_works#resolving) инпутов и инклудов может приводить к тому, что файлы полученные в одном модуле будут достижимы из команды в другом модуле (как входы или как инклуды). Такие файлы могут быть как подключены к своему модулю, так и нет. В любом случае мы требуем чтобы модуль-потребитель имел [`PEERDIR`](./common/macros.md#peerdir) на модуль в котором генерируется файл. Однако, если файл не подключен к своему модулю, то он не будет строиться при сборке своего модуля, только при сборке потребителя.

Например, если в модуле `A` есть генерация `.h`-файла, но нет его инклуда, а инклуд есть в файле в модуле `B`, то.
- Мы требуем чтобы в `ya.make` модуля `B` было написано `PEERDIR(A)`.
- При сборке `ya make A` генерация файла запущена не будет. В частности он не появится при запуске `ya make A --add-result .h`.
- При сборке `ya make B` будет запущениа генерация файла. В частности он появится при запуске `ya make B --add-result .h`. При этом может не запуститься сборка самого модуля `A`, если, например, `A` и `B` - оба имеют тип `LIBRARY` (почему так описано в [докуменатации по макросу PEERIR](./common/macros.md#peerdir)).

{% endnote %}

{% note info %}

В то время как цепочка обработки по расширениям прерывается на файле с расширением *автоматических входов* модуля, явные цепочки из `RUN_PROGRAM` не прерываются. Т.е. возможна ситуация, когда и промежуточный результат преобразований файла и конечный будут переданы в команду модуля.

{% endnote %}

Посмотрим как работает всё описанное на следующем примере:

```
LIBRARY(myproto)
    RUN_PYTHON3(gen.py OUT_NOAUTO generated.x)
    RUN_PYTHON3(convert.py IN generated.x OUT generated.cpp)
    SRCS(x.proto)
END()
```

`LIBRARY` считает своими входами файлы `.o`, поэтому
- `gen.py` породит `${BINDIR}/generated.x`, котороый с помощью `convert.py` преобразуется в `${BINDIR}/generated.cpp` и обработаетя по расширению с помощью `clang` в `${BINDIR}/generated.cpp.o`
- Для `x.proto` будет следующая цепочка обработки по расширениям:
  `${CURDIR}/x.proto -(protoc)-> ${BINDIR}/x.pb.cc -(clang)-> ${BINDIR}/x.pb.cc.o` — тут цепочка остановится`
- Модульная команда библиотеки `ar` получит себе как автоматические входы `${BINDIR}/generated.cpp` и `${BINDIR}/x.pb.cc.o`

Соотвественно чтобы построить модуль надо будет выполнить все команды по цепочке для всех цепочек и выполнить `ar` в конце.

{% note info %}

В реальности у модуля может быть две отдельных команды для агрегации обычных цепочек и для аггрегации цепочек от [`SRCS(GLOBAL)`](./common/macros.md#srcs).

{% endnote %}

## Откуда берутся модули, макросы и общие переменные { #conf }

Система сборки ya make очень гибко настраивается. Большинство её возможностей, доступных в ya.make-файлов не являются встроенными, а описаны как настройка.
Это обеспечивает расширяемость и возможность использовать её во множестве проектов и для множества различных задач.

Набор доступных в ya.make макросов и модулей постоянно расширяется. Никакая ручная документация не в состоянии поддерживать этот список актуальным,
поэтому каждую ночь по комментариям и описаниям генерируется [автоматическая документация](../generated.md), содержащая описания всех модулей и макросов
доступных в данный момент.

Про то, как настраивается система сборки и как описываются макросы и модули можно прочитать в [соответствующей части](../general/how_it_works#config) раздела [как работает система сборки](../general/how_it_works).

# Обработка файлов по расширениям

Система сборки `ya make` ориентируется на расширения файлов:
- По расширениям она [добавляет команды для файлов](#srcs) в макросе [`SRCS`](common/macros.md#srcs) и при автоматической обработке промежуточных результатов.
- По расширениям [обрабатываются файлы в PY_SRCS и JAVA_SRCS](#py)
- По расширениям файлы [становятся входами модульных команд](#auto)
- По расширениям применяется [анализ зависимостей для исходных файлов](#parsing)


## Автоматические команды обработки файлов по расширениям { #srcs }

Макрос [`SRCS`](common/macros.md#srcs) обрабатывает файлы в соответствии с их расширениями. Более того,
в определённых случаях может меняться его поведение в зависимости от типа модуля, в котором его используют.

Также, если расширение зарегистрировано для [`SRCS`](common/macros.md#srcs), то файлы, появляющиеся в сборке как результаты команд, будут обработаны аналогично.

Макрос [`SRCS`](common/macros.md#srcs) для каждого файла формирует команду. В таблице ниже описано, какая команда будет сформирована и какое расширение будет у её результата.
Контекст — это модули, в которых работает это правило. Общий — это макросы `LIBRARY`, `PROGRAM`, `PYx_LIBRARY`, `PYx_PROGRAM`, `UNION`/`PACKAGE` и многие другие,
примерно все кроме `PROTO_LIBRARY`, `FBS_LIBRARY`, модулей для Java и Go.

Расширения | Обработчик  | Результат | Контекст
:--- | :--- | :--- | :---
`.c`, `.m` | компилятор С | `.o`/`.obj` | Общий
`.cpp`, `.cc`. `.cxx`, `.C` | компилятор C++ | `.o`/`.obj` | Общий
`.rl`, `.rl6` | ragel | `.c` | `LIBRARY`, `PROGRAM`, `PYx_LIBRARY`, `PYx_PROGRAM`,...
`.proto` | protoc | `.pb.cc`, `.pb.h`,... | `LIBRARY`, `PROTO_LIBRARY`/`CPP_PROTO`
`.proto` | protoc | `_pb2.py`, `pb2.pyi`,... | `PYxLIBRARY`, `PROTO_LIBRARY`/`PYx_PROTO`
`.proto` | protoc | `.jsrcs` | `PROTO_LIBRARY`/`JAVA_PROTO`
`.proto` | protoc | `.pb.go`, ... | `GO_LIBRARY`, `PROTO_LIBRARY`/`GO_PROTO`
`.S`, `.s`, `.s79`,  |  компилятор С  | `.o`/`.obj` | Общий
`.mm`  |  компилятор C | `.o`/`.obj` | Общий
`.fml`, | Транслятор формул | `fml.inc` | Общий
`.fml2` | Транслятор формул | `fml.inc`, Общий
`.fml3` | Транслятор формул | `fml.inc`, Общий
`.pln` | Транслятор формул | `pln.cpp` | Общий
`.sdfl` | компилятор C++ и tools/calcstaticopt | .o и.inc | Общий
`.xs` | Perl | `xs.c` или `xs.cpp` | Общий
`.y`, `.ypp` | byacc | `.y.cpp`, `.h` | Общий
`.gperf` | gperf | `.gperf.cpp` | Общий
`.rl`, `.rl5` | Ragel5 | `rl.cpp` | Общий
`.asp` | html2cpp | `asp.cpp` | Общий
`.rl6` | Ragel6 | `rl6.cpp` | Общий
`.l`, `.lex`, `.lpp` | flex | Общий
 `xsyn` | xsyn2ragel | `.rl5` | Общий
`.ev` | protoc | `.ev.pb.cc`, `.ev.pb.h`,... | `LIBRARY`, `PROTO_LIBRARY`/`CPP_PROTO`
`.ev` | protoc | `_ev.py`, `_ev.pyi`,... | `PYxLIBRARY`, `PROTO_LIBRARY`/`PYx_PROTO`
`.ev` | protoc | `.jsrcs` | `PROTO_LIBRARY`/`JAVA_PROTO`
`.gztproto` | dict/gazetteer/converter | `.proto` | Общий
`.cfgproto` | protoc | `.cfgproto.pb.cc`, `.cfgproto.pb.h`,... | Общий
`.pyx` | Cython | `.pyx.cpp` | `SRCS` в `PYMPODULE`, `LIBRARY`, `DLL`, `PY23_NATIVE_LIBRARY`
`.ext.in` | Из `*.ext.in`  получается `*.ext`  путем копирования `*.ext.in`  с заменой `@CONFIG_VAR@` на значение этой переменной в системе сборки | `.ext` | Любой
`.sc` | `tools/domschemec` | `.h` | Общий
`.ssqls` | `metrika/core/tools/ssqls` | `.h`, `.cpp` | Общий
`.f` | Fortran f2c | `.c` | Общий
`.masm` | masm | `.o`/`.obj` | Общий
`.asm`, `.yasm` | yasm | `.o`/`.obj` | Общий
`.lua` | LuaJIT |  `.o` | Общий
`.cu` | CUDA nvcc |  `.o` | Общий
`.fbs` | protoc | `.fbs.h` | `LIBRARY`, `FBS_LIBRARY`/`CPP_FBS`
`.fbs` | protoc | `.pysrcs` | `PYxLIBRARY`, `FBS_LIBRARY`/`PYx_FBS`
`.fbs` | protoc | `.jsrcs` | `FBS_LIBRARY`/`JAVA_FBS`
`.fbs` | protoc | `.gosrcs` | `GO_LIBRARY`, `FBS_LIBRARY`/`GO_FBS`
`.fbs64` | protoc | `.fbs64.h` | Общий

## Автоматические модульные входы { #auto }

Модульная конфигурация определяет файлы с какими расширениями будут её входами. Если в процессе [обработки по расширениям](#ext) появляется файл с таким расширением,
то обработка останавливается и файл становится **автоматическим входом** команды сборки модуля. Все такие входы формируют список имён, и он подаётся в модульную команду. 

Даже если для файла существует дальнейшая обработка, если расширение файла предписано модулю, обработка не будет запущена и файл будет отправлен в модульную команду.


Модули | Расширения
:--- | :--- 
`PROGRAM`, `LIBRARY`, `PYx_PROGRAM`, `PYx_LIBRARY` и т.п. | .o, .obj, .a, .lib
`PACKAGE`, `UNION` | .*
`JAVA_PROGRAM`, `JAVA_LIBRARY` | .*


## Анализ зависимостей по расширениям { #parsing }

Описание сборки в `ya make` очень высокоуровневое, она не требует описания зависимостей файлов от других файлов (например, `#include` в C++ или `import` в Protobuf), 
если исходный файл доступен на файловой системе. Система сборки сама анализирует исходные файлы, основываясь на расширениях и находит зависимости. Более того, система
сборки может выводить межмодульные зависимости (в go), а также *[наведённые](index.md#induced)* зависимости генерируемых файлов от других генерируемых. Так из `import` в .proto система сборки делает вывод не только о зависимости между .proto-файлами, но и о зависимости .pb.cc файла от импортируемого .pb.h.

Ниже в таблице собрана информация о том, какие расширения и как анализируются. Колонки в таблице означают следующее:

- **Расширение** -- список типов файлов, к которым это правило применяется.
- **Зависимости** -- список типов файлов, прямые зависимости от которых, умеет обнаруживать система сборки.
- **Наведённые** -- список типов файлов, для которых выводятся [наведённые зависимости](index.md#induced).
- **Распространение** -- могут ли наведённые зависимости распространяться через такие файлы. Если файл с таким расширением зависит от источника [наведённых зависимостей](index.md#induced),
  должны ли эти зависимости применяться к тем, кто зависит от этого файла.
- **Язык в `ADDINCL`** -- в макросе [`ADDINCL`](common/macros.md#addicl) можно указать, к каким файлам данный путь поиска относится. Это делается указанием *языка* в параметре `FOR`.
  В колонке обозначено, какой язык будет применяться для разрешения имён при обработке файлов в соответствующей строке.

Расширение | Зависимости | Наведённые  | распространение | Язык в `ADDINCL` | Описание
:--- | :--- | :--- | :--- | :--- | :---
`fml`, `fml2`, `fml3`, `pln`, `info`, `a`, `lua`, `sh` | нет | нет | нет | -- | Останавливают распространение зависимостей
`bin`, `py` | нет | нет | да | -- | Пропускают зависимости
`.c`, `.cc`, `cxx`, `.cpp`, `C` | `.h`, `hh`, `hpp`,... | -- | нет | `с`/нет | C/C++
`.h`, `.hh`, `.hpp`, `.cuh`, `.H`, `.hxx`, `.xh` | `.h`, `hh`, `hpp`,... | `.h`, `.cpp`, `.xscpp` | нет | `с`/нет | Заголовочные файлы
`.cu`, `.S`, `.s`, `.sfdl`, `.m`, `.mm` | `.h`, `hh`, `hpp`,... | `.h`, `.cpp` | нет | `с`/нет | Синтаксически похожи на С
`.asm` | `.asm` | нет | нет | `asm` | Ассемблер yasm
`.proto` | `.proto` | `pb.cc`, `pb.h` | нет | `proto` | Protobuf
`.ev` | `.proto` | `.ev.pb.cc`, `.ev.pb.h` | нет | `proto` | Events на основе protobuf
`.gzt`, `.gztproto` | `.proto` | нет | нет | `proto` | Конфиги на основе protobuf
`.cfgproto` | `.proto` | `.cfgproto.pb.cc`, `.cfgproto.pb.h` | нет | `proto` | Схемы для газеттира
`l`, `lex`, `lpp`, `.y`, `.ypp`, `gperf`, `.asp` | нет | `.cpp`  | нет | `c`/нет | lex, yacc, google perf, asp -- все генерируют код на С/C++
`rl`, `rh`, `rli`, `rl6`, `rl5` | `rl`, `rh`, `rli`, `rl6`, `rl5` | `.cpp` | нет | `ragel`  | Ragel
`.f` | нет | `.c` | нет |  `c`/нет | Fortran через f2c
`.xs` | нет  |  `.cpp`, `xscpp` | нет | `xs` | Perl to C биндинги
`.xscpp` | нет | `.cpp` | да  | `xs` | Perl to C++ биндинги
`.xsyn` | `.xsyn` | нет | нет | `xsyn` | XML
`.pyx` | `.pyx`, `.pxd` | `.cpp,`, `.h` | да | Cython
`.swg` |`.swg`, `.i` | `.h` , `.cpp` | нет | `swig` | SWIG биндинги для Python и Java
`.fbs` | `.fbs` | `.fbs.h` | нет | `flatc` | Flatbuffers
`.fbs64` | `.fbs64` | `.fbs64.h` | нет | `flatc` | 64-битный вариант Flatbuffers
`.go` | `.go` | `PEERDIR`, `.C` | нет | `c`/нет | Go
`.ts`, `.js`, `.tsx`, `.jsx` |`.ts`, `.js`, `.tsx`, `.jsx` | нет | нет | нет | Frontend-файлы, только в модулях под сборкой Frontend
`.sc` | `.sc` | нет | нет | `sc` | sc-схемы
`.ydl` | `.ydl` | `.h` | нет | `ydl` | ydl-схемы
`.nlg` | `.nlg` | `.h` | нет | `nlg` | nlg-схемы
`idl` | `idl` | `.h` | нет | `idl` | Mapkit IDL



## Расширения в `PY_SRCS` и `JAVA_SRCS` { #py }

Макросы [`PY_SRCS`](python/macros.md#py_srcs) и [`JAVA_SRCS`](java/macros.md#java_srcs) поддерживают свои наборы расширений, который могу специально обрабатывать.

### `PY_SRCS`

- `.py` -- компилируется с помощью pycc и складывается ресурсом доступным для импорта [программами на Python](python/index.md#python_program)
- `.pyc` -- компилируется с помощью cython и регистрируется, чтобы код был доступным для импорта [программами на Python](python/index.md#python_program)
- `.swg` -- компилируется с помощью swig и регистрируется, чтобы код был доступным для импорта [программами на Python](python/index.md#python_program)
- `.proto` -- генерируется код на Python, затем обрабатывается как `.py`
- `.fbs` -- генерируется код на Python (множество файлов), затем они компилируются и складываются в ресурсы доступные для импорта [программами на Python](python/index.md#python_program)


