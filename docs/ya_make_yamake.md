# Описание сборки в ya.make

## Что такое описание сборки

Система сборки призвана превратить исходные файлы на различных языках по строгим правилам в библиотеки, программы и тесты (результаты сборки), а также запускать тесты по запросу. Желательно, чтобы пересборка была минимальной и затрагивала только изменённые компоненты.

Для достижения этого цели в системе сборки должны быть:

- Описаны правила превращения исходных файлов в результаты.
- Определены зависимости для минимизации пересборок.
- Описаны сборочные свойства для согласованности сборки целей и их зависимостей.
- Указаны дополнительные свойства, такие как владелец кода и лицензия.

## Как описывается сборка для ya.make 

Описание сборки в ya.make модульное: сборка каждого результата описывается в отдельном файле, а код разбивается на модули. Описание сборки включает как сборку собственного кода модуля, так и ссылки на другие модули, от которых он зависит.

Описание сборки в ya.make в основном декларативное:
- Указываются необходимая информация для сборки, а не последовательность действий.
- Используются переменные, которые должны быть объявлены до использования в конструкциях типа IF()/ELSEIF()/ELSE()/ENDIF().
- Некоторые зависимости выводятся из расширений файлов. Подробнее см. ниже.

Описание сборки для ya make находится в ya.make файлах, имена которых зафиксированы. В каждой директории разрешён только один такой файл, указывающий, какие модули будут собраны.

Конструкции в ya.make именуются как макросы и выглядят как вызовы функций с параметрами. Исторически макросы именуются в SCREAMING_SNAKE_CASE. В дополнение к макросам используются комментарии, которые начинаются символом # и продолжаются до конца строки.

- Подробнее про синтаксис ya.make
- Подробнее о том, как интерпретируется ya.make

Каждый ya.make файл описывает сборку не более чем одного модуля. Модуль может быть библиотекой, программой, тестом или группой целей (модули PACKAGE и UNION).

Иногда логический модуль может быть реализован в нескольких вариантах, что называется мультимодулем. Выбор нужного варианта в этом случае определяется самой зависимостью, а не явным указанием.

- Примеры мультимодулей: PY23_LIBRARY и PROTO_LIBRARY

Файлы ya.make могут содержать описание сборки модуля и/или связи с другими файлами. Модуль описывается макросами между макросом типа модуля и END(). Макросы, не относящиеся к сборке модуля, пишутся за пределами.

### Самые первые ya.make

Начальный ya.make для списка проектов содержит список директорий в макросе RECURSE:
```
RECURSE(
commie
core
lib
solver
ut
)
```
При сборке такого ya.make будут собраны все указанные цели и их вложенные зависимости. 

Описание модуля обычно содержит:
 * Указание на владельца модуля — макрос OWNER.
 * Макрос типа модуля: что именно будет строиться.
 * Возможно, макрос для указания зависимостей модуля от других модулей — PEERDIR.
 * Макрос с перечислением исходных файлов модуля SRCS/PY_SRCS/JAVA_SRCS.
 * Макрос END, завершающий скоуп модуля.
 * Возможно, связанные сборочные цели (чаще всего тесты), указанные макросом RECURSE или RECURSE_FOR_TESTS
Система сборки поддерживает различные языки и модули для разнообразных задач.

### Примеры для разных языков

#### C++

Структура директорий:
```
project/program
├── test
│ ├── test.cpp
│ └── ya.make
├── main.cpp
└── ya.make
```
project/program/ya.make:
```
OWNER(username) # Макрос, указывающий владельца модуля

PROGRAM() # Макрос типа модуля: программа (на C++)

PEERDIR( # Макрос зависимостей модуля
util/draft
)

SRCS( # Макрос исходных файлов модуля
main.cpp
)

END() # Закрывающий макрос модуля

RECURSE_FOR_TESTS(test) # Макрос связи - компиляция и запуск тестов из поддиректории test
```
#### Python

Структура директорий:
```
project/program
├── test
│ ├── test.py
│ └── ya.make
├── main.py
└── ya.make
```
project/program/ya.make:
```
OWNER(username) # Макрос, указывающий владельца модуля

PY3_PROGRAM() # Макрос типа модуля: программа на Python 3

PEERDIR( # Макрос зависимостей модуля
contrib/python/requests
)

PY_SRCS( # Макрос исходных файлов модуля
MAIN main.py # Точка входа
)

END() # Закрывающий макрос модуля

RECURSE_FOR_TESTS(test) # Макрос связи - компиляция и запуск тестов из поддиректории test
```
#### Java

Структура директорий:
```
project/program
├── src
│ ├── main
│ │ └── java
│ │ └── ru
│ │ └── local
│ │ └── example
│ │ └── lib
│ │ └── Greet.java
│ └── test
│ ├── java
│ │ └── ru
│ │ └── local
│ │ └── example
│ │ └── lib
│ │ └── test
│ │ └── GreetTest.java
│ └── ya.make
└── ya.make
```
project/program/ya.make:
```
OWNER(username) # Макрос, указывающий владельца модуля

JAVA_PROGRAM() # Макрос типа модуля: программа на Java

PEERDIR( # Макрос зависимостей модуля
contrib/java/org/yaml/snakeyaml
)

DEPENDENCY_MANAGEMENT( # Макрос выбора версии зависимости
contrib/java/org/yaml/snakeyaml/1.27
)

JAVA_SRCS( # Макрос исходных файлов модуля
SRCDIR src/main/java **/*.java # Все .java файлы в указанной директории рекурсивно
)

END() # Закрывающий макрос модуля

RECURSE_FOR_TESTS(test) # Макрос связи - компиляция и запуск тестов из поддиректории test
```
#### Go

Структура директорий:
```
project/library
├── gotest
│ └── ya.make
├── greeting.go
├── greeting_test.go
└── ya.make
```
project/library/ya.make:
```
OWNER(username) # Макрос, указывающий владельца модуля

GO_LIBRARY() # Макрос типа модуля: библиотека на Go

SRCS( # Макрос исходных файлов модуля
greeting.go
)

GO_TEST_SRCS( # Макрос исходных файлов внутренних тестов модуля
greeting_test.go
)

END() # Закрывающий макрос модуля

RECURSE_FOR_TESTS(gotest) # Макрос связи - компиляция и запуск тестов из поддиректории gotest
```
Описание библиотеки будет очень похоже, поменяется только макрос типа модуля (LIBRARY вместо PROGRAM).

Более сложное описание сборки может включать:
 * Дополнительные свойства модуля и его команд
 * Изменение поведения для разных платформ и конфигураций
 * Макросы генерации исходных файлов или специальной обработки данных
 * Более сложные зависимости.
 * У тестов можно задать много свойств, связанных с исполнением этих тестов

### Правила при написании ya.make

- Любое включение из другой библиотеки должно сопровождаться соответствующим PEERDIR.
- Если директория состоит из одних заголовков, в ней должен быть соответствующий ya.make с макросом LIBRARY().
  ```
  LIBRARY()
    PEERDIR(
        # директории, заголовки из которых есть
        # в заголовках данной директории
    )
  END()
  ```
- Программы не могут зависеть от программ без использования PEERDIR.
- Запрещается разбивать библиотеку на части для избежания ложных зависимостей.
- Генерируемые файлы должны быть в каталоге сборки.
- В ya.make проекта запрещено менять глобальные флаги, влияющие на конфигурацию сборки (вызывающие включение / исключение компонент и файлов в компоненты). Такие флаги разрешается устанавливать только глобально, для сборки в целом.
Описание сборки модуля содержит все необходимые для него исходные файлы, включая команды генерации исходных файлов, свойства и опции его сборки, а также необходимые зависимости как ссылки на другие модули. 

Тестовые модули могут также содержать данные, зависимости и свойства, необходимые для запуска теста.

Модули условно делятся на финальные и промежуточные.

Промежуточные модули — это модули, родственные LIBRARY и UNION. На них можно ставить зависимость (PEERDIR) как из аналогичных модулей, так и из соответствующих финальных модулей (для LIBRARY это PROGRAM, DLL, UNITTEST и т.п.). При сборке промежуточных модулей как целей их зависимости не строятся. Не имеет смысл указывать промежуточные модули в макросах BUNDLE и DEPENDS поскольку они не замкнуты по зависимостям. Их также нельзя использовать как инструменты в макросах типа RUN_PROGRAM. 

Единственное исключение - DEPENDS на UNION. Если сослаться на UNION в макросе DEPENDS, то все зависимости UNION транзитивно построятся и будут доступны в build-директории по путям, соответствующим своему размещению в репозитории.

Финальные модули — это программы, тесты и PACKAGE. При сборке они замыкают транзитивно все свои зависимости. На них нельзя ставить зависимость PEERDIR в других модулях кроме PACKAGE. Их можно использовать как артефакты в макросах DEPENDS и BUNDLE. Исполняемые финальные модули могут выступать инструментами в макросе RUN_PROGRAM и аналогичных.

Система сборки ya make предоставляет развитую систему модулей для различных языков и применений.

### Макросы в модуле

Система сборки `ya make` предоставляет огромное количество макросов для различных языков и применений.

Макросы в модуле можно условно подразделить на три категории:

#### Управляющие макросы

Управляющие или условные макросы, такие как INCLUDE, EXCLUDE_TAGS, ONLY_TAGS, а также макросы типа IF(), ELSEIF(), ELSE(), ENDIF(), влияют на то, как интерпретируется файл ya.make. Эти макросы позволяют настроить различную сборку на основе значений переменных, которые могут быть заданы локально (с помощью макроса SET()) или глобально, для определения конфигурации сборки данного модуля. Например, глобальные переменные могут включать OS_WINDOWS при сборке для Windows или PYTHON3 в соответствующих случаях мультимодуля.

#### Макросы, задающие свойства

Эти макросы могут напрямую влиять на встроенные свойства. Например, PEERDIR задаёт зависимости для модуля, SRCDIR или ADDINCL указывают пути для поиска имён. Макрос PY_NAMESPACE определяет пространства имён для импорта файлов, описанных в модуле.

Они также могут формировать значения переменных, использующихся в других макросах или командах модуля. Например, CFLAGS устанавливает флаги для команд компиляции C/C++ файлов. Макрос SET(VAR VALUE) задаёт значение переменной; если переменная присутствует в глобальной конфигурации, её значение изменится для данного модуля, если нет - переменная появится и будет доступна в контексте модуля для последующих макросов.

Макрос OWNER можно использовать вне модуля и даже в файлах ya.make, не описывающих модули. Этот макрос помогает внешним системам определять ответственных за код. 

#### Макросы, описывающие команды

Такие макросы задают команды, которые будут выполнены в процессе сборки. Они формируют команды, интегрируя их в граф сборки модуля путем связывания своих результатов с входами других команд (потребителей) и, возможно, своих входов с результатами других команд (источников).
К примеру, макрос COMPILE_LUA создаёт команду, компилирующую код на Lua в представление, пригодное для LuaJit. Результат этой команды будет ассоциирован с другими командами модуля (например, упаковка в библиотеку), а впоследствии библиотека будет связана по зависимостям с финальной программой.

Макросы, описывающие сборку модуля, могут ссылаться на файлы, директории в репозитории и другие модули.

### Мультимодули

Мультимодуль — это  модуль, который может быть собран в различных вариантах в зависимости от того, как он используется. По своему описанию сборки мультимодуль не отличается от обычного модуля, ссылки на него делаются по имени директории. Выбор нужного варианта осуществляется следующим образом:

1. Зависимость через PEERDIR: Когда мультимодуль используется в качестве зависимости через PEERDIR, выбор варианта производится на основе входящей зависимости. То есть, модуль, который зависит от мультимодуля, определяет, какой вариант ему нужен. Каждый отдельный модуль может зависеть только от одного варианта, но в рамках одной сборки могут быть собраны несколько вариантов для различных зависимостей.
2. Непосредственная цель сборки: Если мультимодуль является непосредственной целью сборки, то собираются все его варианты. 
3. Указание в DEPENDS или BUNDLE: Если мультимодуль указан в DEPENDS или BUNDLE, будет выбран единственный вариант со свойством FINAL_TARGET. Если варианта с таким свойством нет или имеется несколько таких вариантов, будет выдана ошибка конфигурации.

### Как интерпретируется ya.make

К моменту начала интерпретации `ya.make` уже выполнены следующие шаги:

- Зачитана конфигурация с описанием всех макросов, глобальных правил и переменных.
- Переменные, относящиеся к платформе, уже определены.

#### Чтение ya.make

- Файл `ya.make` читается построчно, макросы зачитываются в порядке их появления, но интерпретируются не сразу все.
- При интерпретации макросов известные переменные подставляются, а условные выражения обрабатываются на основе текущих значений переменных.
- Изменения переменных, для которых есть правила в описании модуля, приводят к выполнению этих правил и соответствующему обновлению значений переменных.
- Макросы, изменяющие переменные, срабатывают немедленно. Если макросы содержат вызовы других макросов, эти вызовы также обрабатываются. Переменные в макросах подставляются немедленно.
- Все макросы, за исключением тех, которые изменяют переменные, помещаются в приоритетную очередь. Здесь PEERDIR имеет самый высокий приоритет, а SRCS — один из самых низких. Макросы, реализованные в плагинах, также имеют очень низкий приоритет.
- Для мультимодулей это выполняется для каждого варианта отдельно.

#### Построение графа зависимостей

- Очередь макросов обрабатывается отдельным проходом.
- PEERDIR инициирует переход к обработке `ya.make` по зависимостям для корректного распространения глобальных свойств.
- Определяются входы и выходы команд, а их связывание осуществляется в соответствии с SRCDIR этого модуля.
- Команды макросов помещаются в граф зависимостей согласно зависимостям, а глобальные переменные остаются не подставленными. Формируются глобальные команды, которые может агрегировать другой модуль.
- Все входы команд проверяются на предмет зависимостей в соответствии с их расширениями, а найденные имена файлов превращаются в зависимости в соответствии с ADDINCL данного модуля.
- После добавления всех команд из макросов, добавляется основная команда самого модуля, которая получает входы от других команд как через обычное связывание, так и через модульное связывание.
- Когда граф полностью построен, выполняются макросы, анализирующие граф целиком, такие как DEPENDENCY_MANAGEMENT, CHECK_DEPENDENT_DIRS, LICENSE_RESTRICTION и другие.
- Затем формируется граф команд, в который записываются тексты команд с подстановкой всех переменных, включая глобальные переменные.
- Отдельно формируется информация для последующего обогащения графа, например, для формирования команд запуска тестов. В эту информацию попадают некоторые переменные и свойства модуля.

### Глобальные свойства, переменные и команды

В системе сборки `ya.make` существуют понятия локальных и глобальных свойств, переменных и команд.

#### Локальные свойства, переменные и команды

- Локальные свойства: Свойства, применимые исключительно к текущему модулю.
- Локальные переменные: Переменные, доступные только внутри текущего модуля.
- Локальные команды: Команды, результаты которых (в том числе транзитивные) используются в других командах модуля.

#### Глобальные свойства, переменные и команды

- Глобальные свойства и переменные распространяются на зависимости модуля. Они могут передаваться от библиотек (зависимостей) к программам (потребителям зависимостей).

##### Глобальные свойства

- PEERDIR: В C++, Python и Go: если программа P зависит от библиотеки A, которая в свою очередь зависит от библиотеки B, то программа P также зависит от библиотеки B. В результате библиотека B должна быть включена в команду линковки программы.
- ADDINCL: Если параметр GLOBAL установлен, это свойство применяется не только к самой библиотеке, но и ко всем модулям (библиотекам и программам), зависящим от данной библиотеки. Это особенно важно в случаях, когда заголовочные файлы библиотеки указывают относительный путь при использовании #include. Такой заголовочный файл может быть включён в файлы других модулей, и эти модули должны знать, где искать данный файл.

##### Глобальные переменные

Некоторые переменные распространяют свои значения по зависимостям. Пример:

- LDFLAGS: Если библиотека требует каких-то флагов при линковке, она может добавить их в список переменной LDFLAGS, которая затем будет использоваться в команде линковки программы.
- CFLAGS(GLOBAL …): В этом случае переменная CFLAGS будет использована во всех командах компиляции во всех модулях, зависящих от библиотеки.

Глобальные переменные конфигурируются для каждого типа модуля и не могут быть созданы через синтаксис `ya.make`. Если для решения вашей задачи требуется глобальная переменная, обратитесь в команду`devtools`.

Распространять свойства и переменные в обратном направлении (к зависимостям) нельзя, так как это может привести к конфликтам, когда разные цели требуют от одного модуля различающиеся свойства. В таких случаях следует устанавливать значение переменной на всю сборку с помощью команды `ya make -DVAR`.

#### Исключения

1. Транзитивные межмодульные инварианты: Проверяются на всём подграфе и могут запрещать транзитивные зависимости.
2. Dependency management для Java: Формирует граф зависимостей глобально для узла, учитывая, но не полностью следуя зависимостям своих зависимостей.
3. Связывание по PEERDIR варианта мультимодуля: Позволяет выбрать конфигурацию зависимости из ограниченного набора вариантов.

##### Глобальные команды

В некоторых случаях требуется сделать команду зависимостью не самого модуля (библиотеки), а конечного артефакта (программы). Например, при линковке С++ кода объектные файлы из библиотек могут быть удалены, если они не используются. Однако, если код выполняет какую-либо функцию при статической инициализации, он может быть исключён из программы. Чтобы этого избежать, такой код должен быть непосредственно подан на линковку программе. Для этого служат глобальные команды. Обычно они возникают из вызова макроса SRCS с параметром GLOBAL, хотя есть и другие макросы, порождающие глобальные команды.

Хотя глобальные команды не нужны самому модулю и не включаются в его артефакт (например, библиотеку), для упрощения разработки они собираются вместе с модулем, в котором описаны, но формируют отдельный результат — объектный файл или специальную глобальную библиотеку. Это позволяет проверить компилируемость кода при сборке библиотеки.

### Автоматическая обработка по расширениям

Макросы, задающие исходный код для модуля, такие как SRC, SRCS, PY_SRCS, JAVA_SRCS, являются полиморфными. Они определяют обработку файлов в зависимости от их расширения. Поддерживается широкий спектр расширений.

Если файл с поддерживаемым расширением является результатом работы команды в каком-либо макросе и указан в параметре OUT (присутствует у многих генерирующих макросов), он будет автоматически обработан так, как будто указан в SRCS. Дополнительное указание этого файла в SRCS не требуется. Если автоматическая обработка не нужна или не поддерживается, используйте параметр OUT_NOAUTO вместо OUT.

Конкретные команды обработки по расширениям могут зависеть от типа модуля. Например, в контексте LIBRARY (библиотеки для C++) файл .proto проходит через цепочку обработки `.proto -> .pb.cc/.pb.h -> .pb.cc.o`, после чего все `.o` файлы собираются в библиотеку. В контексте GO_LIBRARY цепочка обработки та же для .proto файла, но дальнейшая обработка будет выглядеть как `.proto -> .pb.go -> .pb.go.o.` Таким образом, команда для обработки `.proto` файла будет разной в зависимости от типа модуля, а команды для компиляции `.cc` и `.go` файлов будут определены системой автоматически на основании их расширений.

Описание сборки в `ya.make` является очень высокоуровневым и не требует явного указания зависимостей файлов (например, #include в C++), если исходный файл доступен на файловой системе. Система сборки сама парсит такие файлы, основываясь на расширениях, и находит зависимости. Более того, система может выявлять межмодульные зависимости (в Go) и вторичные зависимости генерируемых файлов от других генерируемых файлов. Например, исходя из import в `.proto` файле, система делает выводы не только о зависимости между `.` файлами, но и о зависимости `.pb.cc` файла от импортируемого `.pb.h`.

Для информации о том, какие файлы и как они парсятся, вы можете ознакомиться со списком поддерживаемых расширений и соответствующих им команд.

### Зависимости в сборке 

#### Зависимости между модулями

Основная зависимость между модулями - PEERDIR. Она может быть логической или сборочной в зависимости от языка и типа модуля:

- В C++ зависимость между библиотеками логическая — зависящая библиотека не требует сборки зависимой. Программы имеют сборочные зависимости.
- В Python зависимости между библиотеками также логические.
- В Java и Go зависимости сборочные, то есть зависящая библиотека требует сборки зависимой.

Кроме PEERDIR, возможны:
- Инструментальные зависимости через макрос RUN_PROGRAM или TOOL.
- BUNDLE — зависимость на модуль как на файл.
- DEPENDS — зависимость, необходимая для исполнения.

#### Наведённые зависимости 

Такие зависимости добавляются через INDUCED_DEPS, OUTPUT_INCLUDES, или доопределяются в процессе парсинга.

## Исполнение сборки

Подробности в соответствующем [разделе](https://github.com/mtv2000/yatool/blob/newstyle/docs/UIDwork.md).


# Как писать ya.make

Сборка в ya.make-файлах описывается макросами. Использование макроса выглядит как `<ИМЯ>([опциональные параметры через пробел])`. Никаких других конструкций в языке ya.make нет, ELSE(), ENDIF() и END() — тоже макросы. Кроме макросов есть только комментарии. В языке ya.make символом начала комментария является # и комментарий длится до конца строки.

Макросы в ya.make зачитываются последовательно, но не все из них интерпретируются непосредственно при зачитывании.

Сразу интерпретируются:

- Макросы установки переменных SET/SET_APPEND и подобные. Значения переменных доступны в параметрах других макросов ниже по тексту ya.make.
- Условные конструкции. Они видят сложившиеся значения переменных и выбирают ветку для интерпретации в соответствии со значением условия в конкретной точке ya.make.
- INCLUDE выполняет текстовую подстановку сразу при чтении ya.make и в позицию, где встречен макрос.
- Макросы, формирующие списки, такие как PEERDIR и ADDINCL, формируют их в текстуальном порядке. Однако, обрабатываться эти списки могут в произвольном порядке.

Макросы модулей, устанавливающие свойства и формирующие команды, макросы, задающие зависимости и связи, применяются в тот момент, когда соответствующая информация нужна и в порядке, определяемом самой системой сборки. Полагаться на определённый порядок исполнения таких макросов не стоит.

## Скоупы в ya.make

Некоторые макросы называются модульными макросами. Такие макросы определяют начало описания модуля, а также его базовые свойства. Заканчивается описание модуля макросом END(). Между этими макросами содержится собственно всё описание сборки модуля. Таким образом в ya.make-файле выделяется два скоупа:

- Глобальный — до начала описания модуля и после него, если модуль есть. Весь файл, если модуля нет.
- Модульный — от макроса начала модуля (например PROGRAM) до макроса END().

### Глобальный скоуп {#global_scope}

Глобальный скоуп — это то, что относится ко всему ya.make-файлу, а не к модулю, который в нём собирается.

Только в глобальном скоупе пишутся:

- Связи — макросы RECURSE и т.п. Этот макрос говорит, что при сборке данного ya.make как цели надо собирать ещё и другие цели — аргументы макроса.
- Модули и END(). Начало и конец модуля могут быть только в глобальном скоупе. Вложенные модули запрещены.

Также в глобальном скоупе могут быть использованы:

- Информационные макросы OWNER и SUBSCRIBER. Они не интерпретируются системой сборки и нужны другим системам.
- INCLUDE — макрос текстового включения.
- Макросы установки переменных SET/SET_APPEND и подобные. Такие переменные доступны для использования в макросах всего ya.make ниже по тексту, но не влияют на модульные свойства.
- Условные конструкции.

В глобальном скоупе можно использовать только встроенные макросы и макросы начала модуля. Все остальные конфигурируемые макросы могут быть использованы только в модульном скоупе.

Конструкции, указанные в глобальном скоупе, интерпретируются ровно один раз в любом ya.make, даже в описывающем мультимодуль. Исключение составляет сам макрос начала мультимодуля.

Пример ya.make состоящего только из глобального скоупа:
```
OWNER(g:owners)

INCLUDE(my_vars.inc)

RECURSE(lib)
IF (WITH_PROGRAM)
RECURSE(program)
ENDIF()
```
### Модульный скоуп 

В модульном скоупе располагается всё описание сборки модуля.

В нём размещаются все макросы, описывающие как собрать этот модуль, а также какими свойствами этот модуль обладает и какие глобальные свойства, переменные и команды он определяет для тех модулей, которые от него зависят.

Там же могут размещаться макросы выбора вариантов мультимодуля, доступных для сборки этого конкретного модуля.

Также как и в глобальном, в модульном скоупе могут быть использованы:

- Информационные макросы OWNER и SUBSCRIBER. Они не интерпретируются системой сборки и нужны другим системам.
- INCLUDE — макрос текстового включения.
- Макросы установки переменных SET/SET_APPEND и подобные. Такие переменные доступны для использования в макросах в пределах модуля ниже по тексту, и могут влиять на модульные свойства.
- Условные конструкции
```
IF(DYNAMIC)
DLL()
EXPORT_SCRIPT(my.exports)
INCLUDE(module_body.inc)
END()
ELSE()
LIBRARY()
INCLUDE(module_body.inc)
END()
ENDIF()
```
## Макросы

Сборка в ya.make-файлах описывается макросами. Использование макроса выглядит как `<ИМЯ>(параметры)`. Исторически для их именования используется `SCREAMING_SNAKE_CASE`.

Система сборки ya.make предоставляет большое количество макросов для различных языков и применений.

### Передача параметров

Параметры в макросах ya.make разделяются пробелами или переводами строк. Обычно каждое отдельное слово — это отдельный параметр. Макросы с длинным набором параметров можно переносить на несколько строк. Множественные пробелы в отступах считаются одним разделителем.

Поэтому можно так:
```
SET(FILE_LIST x y z)
```
Или так:
```
SET(FILE_LIST
x y z)
```
Или так:
```
SET(
FILE_LIST
x
y
z
)
```
### Типы и виды параметров

Параметры в ya.make бывают всего трёх типов: строки, списки строк и булевы.

Параметры в ya.make бывают именованные и неименованные.

Неименованные параметры участвуют в вызове своим значением, они бывают:

- Скалярные — значением параметра является строка (одно слово). Иногда такой параметр может быть опциональным. Например, имя модуля.
- Свободно-списочные — значением параметра является список всех строк (слов), не отнесённых ни к какому другому параметру.

Именованные параметры участвуют в вызове своим именем и, возможно, значением. Для именования параметров макросов, как и самих макросов, используется SCREAMING_SNAKE_CASE.

Именованные параметры бывают:

- Булевы — значение параметра определяется в описании самого макроса, а в вызове различается факт присутствия параметра в списке (истина) или отсутствия (ложь).
- Скалярные — значением параметра является строка (слово), идущее в вызове сразу после имени параметра.
- Списочные — значением параметра является список строк (слов), идущих после имени параметра и до следующего имени параметра или закрывающей скобки.

### Экранирование значений параметров

Чтобы объединить несколько слов в один параметр, используйте двойные кавычки "..." или, при необходимости, одинарные кавычки внутри двойных кавычек "'...'".

Пример:
`SET(FILE_LIST “a.x b.x c.x”)`

### Интерпретация значений параметров

Параметрами макросов могут быть практически что угодно и интерпретацией параметров могут заниматься разные системы в разные моменты времени:

- Часть значений интерпретирует сама система сборки.
- Часть значений интерпретируют плагины для макросов.
- Многие значения параметров макросов интерпретируются уже сборочными командами во время исполнения.

#### Имена директорий 

Макросы, такие как PEERDIR, ADDINCL, RECURSE и DATA принимают имена директорий.

- ADDINCL и SRCDIR интерпретируют директории просто как пути.
- PEERDIR интерпретирует имена директорий, как ссылки на модули, которые будут там собраны.
- RECURSE интерпретирует имена директорий, как пути до ya.make в этих директориях.
- DATA интерпретирует директории, как зависимость от всех файлов в этой директории.

#### Имена файлов 

Многие макросы принимают имена файлов.

- Некоторые макросы требуют указания полных имён файла, включая корень.
- Основная часть макросов не требует этого и имена файлов отображаются на реальные файлы.

### Условные конструкции 

Система сборки позволяет выполнить часть макросов в ya.make только при определённых условиях. Для этого используются условные конструкции IF, ELSEIF, ELSE и ENDIF.

Пример использования:
```
IF (Expr)
…
ELSEIF (Expr)
…
ELSE()
…
ENDIF()
```
### Макросы установки переменных 

Для работы с переменными предусмотрены макросы SET, SET_APPEND, DEFAULT, ENABLE и DISABLE.

- В глобальном скоупе можно определить новые переменные, которые не описаны в конфигурации.
- В модульном скоупе можно переопределить переменные, описанные в конфигурации.

Для использования переменных их значения подставляются следующим образом:
- `SET(SUFFIX res)`
- `SET(INP xx.scheme)`
- `SET(OUTP доллар(MODDIR)/доллар{INP}.доллар{SUFFIX})`

### INCLUDE 

Макрос INCLUDE(<full_file_name>) выполняет текстовую подстановку. Текст из файла, переданного параметром, будет подставлен вместо INCLUDE и интерпретирован.

### INCLUDE_ONCE

INCLUDE_ONCE([yes|no]) управляет однократной обработкой файла для каждого ya.make-файла. Это предотвращает дублирование значений переменных при многократных включениях.

### Работа с мультимодулями

Мультимодули позволяют описывать сборку нескольких разных модулей. Существует ряд специальных макросов для работы с мультимодулями:

- MODULE_TAG и PEERDIR_TAGS позволяют управлять доступными вариантами мультимодуля.
- EXCLUDE_TAGS, INCLUDE_TAGS и ONLY_TAGS позволяют управлять набором вариантов в мультимодуле.

## Как формируется сборка модуля

Формирование сборки модуля описывается следующим образом:

1. По макросам формируются команды, они связываются в цепочки.
2. Выстраиваются цепочки команд автоматической обработки файлов по расширениям.
3. Формируется команда модуля, которая получает на вход все файлы с расширениями автоматических входов.

## Откуда берутся модули, макросы и общие переменные {#conf}

Система сборки ya make очень гибко настраивается. Большинство её возможностей, доступных в ya.make-файлы, описаны как настройка. Набор доступных макросов и модулей постоянно расширяется и обновляется в автоматической документации.

Про то, как настраивается система сборки и как описываются макросы и модули, можно прочитать в соответствующей части раздела как работает система сборки.


# Обработка файлов по расширениям

Система сборки `ya make` ориентируется на расширения файлов:
- По расширениям она добавляет команды для файлов в макросе `SRCS` и при автоматической обработке промежуточных результатов.
- По расширениям обрабатываются файлы в `PY_SRCS` и `JAVA_SRCS`
- По расширениям файлы становятся входами модульных команд
- По расширениям применяется анализ зависимостей для исходных файлов

## Автоматические команды обработки файлов по расширениям 

Макрос `SRCS` обрабатывает файлы в соответствии с их расширениями. Более того, в определённых случаях может меняться его поведение в зависимости от типа модуля, в котором его используют.

Также, если расширение зарегистрировано для `SRCS`, то файлы, появляющиеся в сборке как результаты команд, будут обработаны аналогично.

Макрос `SRCS` для каждого файла формирует команду. В таблице ниже описано, какая команда будет сформирована и какое расширение будет у её результата.
Контекст — это модули, в которых работает это правило. Общий — это макросы `LIBRARY`, `PROGRAM`, `PYx_LIBRARY`, `PYx_PROGRAM`, `UNION`/`PACKAGE` и многие другие, примерно все кроме `PROTO_LIBRARY`, `FBS_LIBRARY`, модулей для Java и Go.

Расширения | Обработчик  | Результат | Контекст
:--- | :--- | :--- | :---
`.c`, `.m` | компилятор С | `.o`/`.obj` | Общий
`.cpp`, `.cc`. `.cxx`, `.C` | компилятор C++ | `.o`/`.obj` | Общий
`.rl`, `.rl6` | ragel | `.c` | `LIBRARY`, `PROGRAM`, `PYx_LIBRARY`, `PYx_PROGRAM`,...
`.proto` | protoc | `.pb.cc`, `.pb.h`,... | `LIBRARY`, `PROTO_LIBRARY`/`CPP_PROTO`
`.proto` | protoc | `_pb2.py`, `pb2.pyi`,... | `PYxLIBRARY`, `PROTO_LIBRARY`/`PYx_PROTO`
`.proto` | protoc | `.jsrcs` | `PROTO_LIBRARY`/`JAVA_PROTO`
`.proto` | protoc | `.pb.go`, ... | `GO_LIBRARY`, `PROTO_LIBRARY`/`GO_PROTO`
`.S`, `.s`, `.s79`,  |  компилятор С  | `.o`/`.obj` | Общий
`.mm`  |  компилятор C | `.o`/`.obj` | Общий
`.fml`, | Транслятор формул | `fml.inc` | Общий
`.fml2` | Транслятор формул | `fml.inc`, Общий
`.fml3` | Транслятор формул | `fml.inc`, Общий
`.pln` | Транслятор формул | `pln.cpp` | Общий
`.sdfl` | компилятор C++ и tools/calcstaticopt | .o и.inc | Общий
`.xs` | Perl | `xs.c` или `xs.cpp` | Общий
`.y`, `.ypp` | byacc | `.y.cpp`, `.h` | Общий
`.gperf` | gperf | `.gperf.cpp` | Общий
`.rl`, `.rl5` | Ragel5 | `rl.cpp` | Общий
`.asp` | html2cpp | `asp.cpp` | Общий
`.rl6` | Ragel6 | `rl6.cpp` | Общий
`.l`, `.lex`, `.lpp` | flex | Общий
 `xsyn` | xsyn2ragel | `.rl5` | Общий
`.ev` | protoc | `.ev.pb.cc`, `.ev.pb.h`,... | `LIBRARY`, `PROTO_LIBRARY`/`CPP_PROTO`
`.ev` | protoc | `_ev.py`, `_ev.pyi`,... | `PYxLIBRARY`, `PROTO_LIBRARY`/`PYx_PROTO`
`.ev` | protoc | `.jsrcs` | `PROTO_LIBRARY`/`JAVA_PROTO`
`.gztproto` | dict/gazetteer/converter | `.proto` | Общий
`.cfgproto` | protoc | `.cfgproto.pb.cc`, `.cfgproto.pb.h`,... | Общий
`.pyx` | Cython | `.pyx.cpp` | `SRCS` в `PYMPODULE`, `LIBRARY`, `DLL`, `PY23_NATIVE_LIBRARY`
`.ext.in` | Из `*.ext.in`  получается `*.ext`  путем копирования `*.ext.in`  с заменой `@CONFIG_VAR@` на значение этой переменной в системе сборки | `.ext` | Любой
`.sc` | `tools/domschemec` | `.h` | Общий
`.ssqls` | `metrika/core/tools/ssqls` | `.h`, `.cpp` | Общий
`.f` | Fortran f2c | `.c` | Общий
`.masm` | masm | `.o`/`.obj` | Общий
`.asm`, `.yasm` | yasm | `.o`/`.obj` | Общий
`.lua` | LuaJIT |  `.o` | Общий
`.cu` | CUDA nvcc |  `.o` | Общий
`.fbs` | protoc | `.fbs.h` | `LIBRARY`, `FBS_LIBRARY`/`CPP_FBS`
`.fbs` | protoc | `.pysrcs` | `PYxLIBRARY`, `FBS_LIBRARY`/`PYx_FBS`
`.fbs` | protoc | `.jsrcs` | `FBS_LIBRARY`/`JAVA_FBS`
`.fbs` | protoc | `.gosrcs` | `GO_LIBRARY`, `FBS_LIBRARY`/`GO_FBS`
`.fbs64` | protoc | `.fbs64.h` | Общий

## Автоматические модульные входы 

Модульная конфигурация определяет файлы с какими расширениями будут её входами. Если в процессе обработки по расширениям появляется файл с таким расширением, то обработка останавливается и файл становится **автоматическим входом** команды сборки модуля. Все такие входы формируют список имён, и он подаётся в модульную команду. 

Даже если для файла существует дальнейшая обработка, если расширение файла предписано модулю, обработка не будет запущена и файл будет отправлен в модульную команду.

Модули | Расширения
:--- | :--- 
`PROGRAM`, `LIBRARY`, `PYx_PROGRAM`, `PYx_LIBRARY` и т.п. | .o, .obj, .a, .lib
`PACKAGE`, `UNION` | .*
`JAVA_PROGRAM`, `JAVA_LIBRARY` | .*

## Анализ зависимостей по расширениям 

Описание сборки в `ya make` очень высокоуровневое, она не требует описания зависимостей файлов от других файлов (например, `#include` в C++ или `import` в Protobuf), если исходный файл доступен на файловой системе. Система сборки сама анализирует исходные файлы, основываясь на расширениях и находит зависимости. Более того, система сборки может выводить межмодульные зависимости (в go), а также наведённые зависимости генерируемых файлов от других генерируемых. 

Так из `import` в `.proto` система сборки делает вывод не только о зависимости между .proto-файлами, но и о зависимости `.pb.cc` файла от импортируемого `.pb.h`.

Ниже в таблице собрана информация о том, какие расширения и как анализируются. Колонки в таблице означают следующее:

- **Расширение** -- список типов файлов, к которым это правило применяется.
- **Зависимости** -- список типов файлов, прямые зависимости от которых, умеет обнаруживать система сборки.
- **Наведённые** -- список типов файлов, для которых выводятся наведённые зависимости.
- **Распространение** -- могут ли наведённые зависимости распространяться через такие файлы. Если файл с таким расширением зависит от источника наведённых зависимостей, должны ли эти зависимости применяться к тем, кто зависит от этого файла.
- **Язык в `ADDINCL`** -- в макросе `ADDINCL`можно указать, к каким файлам данный путь поиска относится. Это делается указанием *языка* в параметре `FOR`.
  В колонке обозначено, какой язык будет применяться для разрешения имён при обработке файлов в соответствующей строке.

Расширение | Зависимости | Наведённые  | распространение | Язык в `ADDINCL` | Описание
:--- | :--- | :--- | :--- | :--- | :---
`fml`, `fml2`, `fml3`, `pln`, `info`, `a`, `lua`, `sh` | нет | нет | нет | -- | Останавливают распространение зависимостей
`bin`, `py` | нет | нет | да | -- | Пропускают зависимости
`.c`, `.cc`, `cxx`, `.cpp`, `C` | `.h`, `hh`, `hpp`,... | -- | нет | `с`/нет | C/C++
`.h`, `.hh`, `.hpp`, `.cuh`, `.H`, `.hxx`, `.xh` | `.h`, `hh`, `hpp`,... | `.h`, `.cpp`, `.xscpp` | нет | `с`/нет | Заголовочные файлы
`.cu`, `.S`, `.s`, `.sfdl`, `.m`, `.mm` | `.h`, `hh`, `hpp`,... | `.h`, `.cpp` | нет | `с`/нет | Синтаксически похожи на С
`.asm` | `.asm` | нет | нет | `asm` | Ассемблер yasm
`.proto` | `.proto` | `pb.cc`, `pb.h` | нет | `proto` | Protobuf
`.ev` | `.proto` | `.ev.pb.cc`, `.ev.pb.h` | нет | `proto` | Events на основе protobuf
`.gzt`, `.gztproto` | `.proto` | нет | нет | `proto` | Конфиги на основе protobuf
`.cfgproto` | `.proto` | `.cfgproto.pb.cc`, `.cfgproto.pb.h` | нет | `proto` | Схемы для газеттира
`l`, `lex`, `lpp`, `.y`, `.ypp`, `gperf`, `.asp` | нет | `.cpp`  | нет | `c`/нет | lex, yacc, google perf, asp -- все генерируют код на С/C++
`rl`, `rh`, `rli`, `rl6`, `rl5` | `rl`, `rh`, `rli`, `rl6`, `rl5` | `.cpp` | нет | `ragel`  | Ragel
`.f` | нет | `.c` | нет |  `c`/нет | Fortran через f2c
`.xs` | нет  |  `.cpp`, `xscpp` | нет | `xs` | Perl to C биндинги
`.xscpp` | нет | `.cpp` | да  | `xs` | Perl to C++ биндинги
`.xsyn` | `.xsyn` | нет | нет | `xsyn` | XML
`.pyx` | `.pyx`, `.pxd` | `.cpp,`, `.h` | да | Cython
`.swg` |`.swg`, `.i` | `.h` , `.cpp` | нет | `swig` | SWIG биндинги для Python и Java
`.fbs` | `.fbs` | `.fbs.h` | нет | `flatc` | Flatbuffers
`.fbs64` | `.fbs64` | `.fbs64.h` | нет | `flatc` | 64-битный вариант Flatbuffers
`.go` | `.go` | `PEERDIR`, `.C` | нет | `c`/нет | Go
`.ts`, `.js`, `.tsx`, `.jsx` |`.ts`, `.js`, `.tsx`, `.jsx` | нет | нет | нет | Frontend-файлы, только в модулях под сборкой Frontend
`.sc` | `.sc` | нет | нет | `sc` | sc-схемы
`.ydl` | `.ydl` | `.h` | нет | `ydl` | ydl-схемы
`.nlg` | `.nlg` | `.h` | нет | `nlg` | nlg-схемы
`idl` | `idl` | `.h` | нет | `idl` | Mapkit IDL

## Расширения в `PY_SRCS` и `JAVA_SRCS` 

Макросы `PY_SRCS` и `JAVA_SRCS` поддерживают свои наборы расширений, который могу специально обрабатывать.

### `PY_SRCS`

- `.py` -- компилируется с помощью pycc и складывается ресурсом доступным для импорта программами на Python
- `.pyc` -- компилируется с помощью cython и регистрируется, чтобы код был доступным для импорта программами на Python
- `.swg` -- компилируется с помощью swig и регистрируется, чтобы код был доступным для импорта программами на Python
- `.proto` -- генерируется код на Python, затем обрабатывается как `.py`
- `.fbs` -- генерируется код на Python (множество файлов), затем они компилируются и складываются в ресурсы доступные для импорта программами на Python
