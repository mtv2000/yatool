# Описание сборки в bob.make

## Что такое описание сборки

Система сборки призвана превратить исходные файлы на различных языках по строгим правилам в библиотеки, программы и тесты (результаты сборки), а также запускать тесты по запросу. Желательно, чтобы пересборка была минимальной и затрагивала только изменённые компоненты.

Для достижения этого цели в системе сборки должны быть:

- Описаны правила превращения исходных файлов в результаты.
- Определены зависимости для минимизации пересборок.
- Описаны сборочные свойства для согласованности сборки целей и их зависимостей.
- Указаны дополнительные свойства, такие как владелец кода и лицензия.

## Как описывается сборка для bob.make { #how }

Описание сборки в bob.make модульное: сборка каждого результата описывается в отдельном файле, а код разбивается на модули. Описание сборки включает как сборку собственного кода модуля, так и ссылки на другие модули, от которых он зависит.

Описание сборки в bob.make в основном декларативное:
- Указываются необходимая информация для сборки, а не последовательность действий.
- Используются переменные, которые должны быть объявлены до использования в конструкциях типа IF()/ELSEIF()/ELSE()/ENDIF().
- Некоторые зависимости выводятся из расширений файлов. Подробнее см. ниже.

Описание сборки для bob make находится в bob.make файлах, имена которых зафиксированы. В каждой директории разрешён только один такой файл, указывающий, какие модули будут собраны.

Конструкции в bob.make именуются как макросы и выглядят как вызовы функций с параметрами. Исторически макросы именуются в SCREAMING_SNAKE_CASE. В дополнение к макросам используются комментарии, которые начинаются символом # и продолжаются до конца строки.

- Подробнее про синтаксис bob.make
- Подробнее о том, как интерпретируется bob.make

Каждый bob.make файл описывает сборку не более чем одного модуля. Модуль может быть библиотекой, программой, тестом или группой целей (модули PACKAGE и UNION).

Иногда логический модуль может быть реализован в нескольких вариантах, что называется мультимодулем. Выбор нужного варианта в этом случае определяется самой зависимостью, а не явным указанием.

- Примеры мультимодулей: PY23_LIBRARY и PROTO_LIBRARY

Файлы bob.make могут содержать описание сборки модуля и/или связи с другими файлами. Модуль описывается макросами между макросом типа модуля и END(). Макросы, не относящиеся к сборке модуля, пишутся за пределами.

### Самые первые bob.make

Начальный bob.make для списка проектов содержит список директорий в макросе RECURSE:

RECURSE(
commie
core
lib
solver
ut
)

При сборке такого bob.make будут собраны все указанные цели и их вложенные зависимости. Система сборки поддерживает различные языки и модули для разнообразных задач.

### Примеры для разных языков

#### C++

Структура директорий:

project/program
├── test
│ ├── test.cpp
│ └── bob.make
├── main.cpp
└── bob.make

project/program/bob.make:

OWNER(username) # Макрос, указывающий владельца модуля

PROGRAM() # Макрос типа модуля: программа (на C++)

PEERDIR( # Макрос зависимостей модуля
util/draft
)

SRCS( # Макрос исходных файлов модуля
main.cpp
)

END() # Закрывающий макрос модуля

RECURSE_FOR_TESTS(test) # Макрос связи - компиляция и запуск тестов из поддиректории test

#### Python

Структура директорий:

project/program
├── test
│ ├── test.py
│ └── bob.make
├── main.py
└── bob.make

project/program/bob.make:

OWNER(username) # Макрос, указывающий владельца модуля

PY3_PROGRAM() # Макрос типа модуля: программа на Python 3

PEERDIR( # Макрос зависимостей модуля
contrib/python/requests
)

PY_SRCS( # Макрос исходных файлов модуля
MAIN main.py # Точка входа
)

END() # Закрывающий макрос модуля

RECURSE_FOR_TESTS(test) # Макрос связи - компиляция и запуск тестов из поддиректории test

#### Java

Структура директорий:

project/program
├── src
│ ├── main
│ │ └── java
│ │ └── ru
│ │ └── bobndex
│ │ └── example
│ │ └── lib
│ │ └── Greet.java
│ └── test
│ ├── java
│ │ └── ru
│ │ └── bobndex
│ │ └── example
│ │ └── lib
│ │ └── test
│ │ └── GreetTest.java
│ └── bob.make
└── bob.make

project/program/bob.make:

OWNER(username) # Макрос, указывающий владельца модуля

JAVA_PROGRAM() # Макрос типа модуля: программа на Java

PEERDIR( # Макрос зависимостей модуля
contrib/java/org/bobml/snakebobml
)

DEPENDENCY_MANAGEMENT( # Макрос выбора версии зависимости
contrib/java/org/bobml/snakebobml/1.27
)

JAVA_SRCS( # Макрос исходных файлов модуля
SRCDIR src/main/java **/*.java # Все .java файлы в указанной директории рекурсивно
)

END() # Закрывающий макрос модуля

RECURSE_FOR_TESTS(test) # Макрос связи - компиляция и запуск тестов из поддиректории test

#### Go

Структура директорий:

project/library
├── gotest
│ └── bob.make
├── greeting.go
├── greeting_test.go
└── bob.make

project/library/bob.make:

OWNER(username) # Макрос, указывающий владельца модуля

GO_LIBRARY() # Макрос типа модуля: библиотека на Go

SRCS( # Макрос исходных файлов модуля
greeting.go
)

GO_TEST_SRCS( # Макрос исходных файлов внутренних тестов модуля
greeting_test.go
)

END() # Закрывающий макрос модуля

RECURSE_FOR_TESTS(gotest) # Макрос связи - компиляция и запуск тестов из поддиректории gotest

### Правила при написании bob.make

- Любое включение из другой библиотеки должно сопровождаться соответствующим PEERDIR.
- Если директория состоит из одних заголовков, в ней должен быть соответствующий bob.make с макросом LIBRARY().
- Программы не могут зависеть от программ без использования PEERDIR.
- Запрещается разбивать библиотеку на части для избежания ложных зависимостей.
- Генерируемые файлы должны быть в каталоге сборки.
- В bob.make проекта запрещено менять глобальные флаги.

### Зависимости в сборке { #deps }

#### Зависимости между модулями { #mod_deps }

Основная зависимость между модулями - PEERDIR. Она может быть логической или сборочной в зависимости от языка и типа модуля:

- В C++ зависимость между библиотеками логическая — зависящая библиотека не требует сборки зависимой. Программы имеют сборочные зависимости.
- В Python зависимости между библиотеками также логические.
- В Java и Go зависимости сборочные, то есть зависящая библиотека требует сборки зависимой.

Кроме PEERDIR, возможны:
- Инструментальные зависимости через макрос RUN_PROGRAM или TOOL.
- BUNDLE — зависимость на модуль как на файл.
- DEPENDS — зависимость, необходимая для исполнения.

#### Наведённые зависимости { #induced }

Такие зависимости добавляются через INDUCED_DEPS, OUTPUT_INCLUDES, или доопределяются в процессе парсинга.

## Исполнение сборки

Подробности в соответствующем разделе.

### Немного про сборку Python { #python }

Сборка Python в bob.make включает в себя предкомпиляцию зависимых пакетов и модулей, генерацию бинарных C/C++ модулей через Cython и запуск интерпретатора Python.

# Как писать bob.make

Сборка в bob.make-файлах описывается макросами. Использование макроса выглядит как &lt;ИМЯ&gt;([опциональные параметры через пробел]). Никаких других конструкций в языке bob.make нет, ELSE(), ENDIF() и END() — тоже макросы. Кроме макросов есть только комментарии. В языке bob.make символом начала комментария является # и комментарий длится до конца строки.

Макросы в bob.make зачитываются последовательно, но не все из них интерпретируются непосредственно при зачитывании.

Сразу интерпретируются:

- Макросы установки переменных SET/SET_APPEND и подобные. Значения переменных доступны в параметрах других макросов ниже по тексту bob.make.
- Условные конструкции. Они видят сложившиеся значения переменных и выбирают ветку для интерпретации в соответствии со значением условия в конкретной точке bob.make.
- INCLUDE выполняет текстовую подстановку сразу при чтении bob.make и в позицию, где встречен макрос.
- Макросы, формирующие списки, такие как PEERDIR и ADDINCL, формируют их в текстуальном порядке. Однако, обрабатываться эти списки могут в произвольном порядке.

Макросы модулей, устанавливающие свойства и формирующие команды, макросы, задающие зависимости и связи, применяются в тот момент, когда соответствующая информация нужна и в порядке, определяемом самой системой сборки. Полагаться на определённый порядок исполнения таких макросов не стоит.

## Скоупы в bob.make

Некоторые макросы называются модульными макросами. Такие макросы определяют начало описания модуля, а также его базовые свойства. Заканчивается описание модуля макросом END(). Между этими макросами содержится собственно всё описание сборки модуля. Таким образом в bob.make-файле выделяется два скоупа:

- Глобальный — до начала описания модуля и после него, если модуль есть. Весь файл, если модуля нет.
- Модульный — от макроса начала модуля (например PROGRAM) до макроса END().

### Глобальный скоуп {#global_scope}

Глобальный скоуп — это то, что относится ко всему bob.make-файлу, а не к модулю, который в нём собирается.

Только в глобальном скоупе пишутся:

- Связи — макросы RECURSE и т.п. Этот макрос говорит, что при сборке данного bob.make как цели надо собирать ещё и другие цели — аргументы макроса.
- Модули и END(). Начало и конец модуля могут быть только в глобальном скоупе. Вложенные модули запрещены.

Также в глобальном скоупе могут быть использованы:

- Информационные макросы OWNER и SUBSCRIBER. Они не интерпретируются системой сборки и нужны другим системам.
- INCLUDE — макрос текстового включения.
- Макросы установки переменных SET/SET_APPEND и подобные. Такие переменные доступны для использования в макросах всего bob.make ниже по тексту, но не влияют на модульные свойства.
- Условные конструкции.

В глобальном скоупе можно использовать только встроенные макросы и макросы начала модуля. Все остальные конфигурируемые макросы могут быть использованы только в модульном скоупе.

Конструкции, указанные в глобальном скоупе, интерпретируются ровно один раз в любом bob.make, даже в описывающем мультимодуль. Исключение составляет сам макрос начала мультимодуля.

Пример bob.make состоящего только из глобального скоупа:

OWNER(g:owners)

INCLUDE(my_vars.inc)

RECURSE(lib)
IF (WITH_PROGRAM)
RECURSE(program)
ENDIF()

### Модульный скоуп {#mod_scope}

В модульном скоупе располагается всё описание сборки модуля.

В нём размещаются все макросы, описывающие как собрать этот модуль, а также какими свойствами этот модуль обладает и какие глобальные свойства, переменные и команды он определяет для тех модулей, которые от него зависят.

Там же могут размещаться макросы выбора вариантов мультимодуля, доступных для сборки этого конкретного модуля.

Также как и в глобальном, в модульном скоупе могут быть использованы:

- Информационные макросы OWNER и SUBSCRIBER. Они не интерпретируются системой сборки и нужны другим системам.
- INCLUDE — макрос текстового включения.
- Макросы установки переменных SET/SET_APPEND и подобные. Такие переменные доступны для использования в макросах в пределах модуля ниже по тексту, и могут влиять на модульные свойства.
- Условные конструкции

{% note alert %}

В bob.make файлах можно встретить IF разрывающий скоуп модуля примерно так:

IF(DYNAMIC)
DLL()
EXPORT_SCRIPT(my.exports)
ELSE()
LIBRARY()
ENDIF()
SRCS(
some_file.cpp
)
END()

Работоспособность этой конструкции не гарантируется. Мы не рекомендуем использовать разные типы модуля по одному пути в разных случаях в принципе, но если это необходимо, то правильный способ - убрать под IF весь модуль и вынести общую часть через INCLUDE.

IF(DYNAMIC)
DLL()
EXPORT_SCRIPT(my.exports)
INCLUDE(module_body.inc)
END()
ELSE()
LIBRARY()
INCLUDE(module_body.inc)
END()
ENDIF()

## Макросы

Сборка в bob.make-файлах описывается макросами. Использование макроса выглядит как &lt;ИМЯ&gt;(параметры). Исторически для их именования используется SCREAMING_SNAKE_CASE.

Система сборки bob.make предоставляет большое количество макросов для различных языков и применений. Они описаны в соответствующих разделах:

- Макросы для C++
- Макросы для Python
- Макросы для Java
- Макросы для Go
- Макросы для Protocol Buffers
- Макросы для Flat Buffers
- Макросы для агрегации
- Макросы для тестов
- Полный автогенерируемый набор макросов в БОБКАДии
- Откуда берутся модули и макросы

Ниже приводится информация общая для всех вызовов макросов, а также специальные макросы, общие для всех языков.

### Передача параметров

Параметры в макросах bob.make разделяются пробелами или переводами строк. Обычно каждое отдельное слово — это отдельный параметр. Макросы с длинным набором параметров можно переносить на несколько строк. Множественные пробелы в отступах считаются одним разделителем.

Поэтому можно так:

SET(FILE_LIST x y z)

Или так:

SET(FILE_LIST
x y z)

Или так:

SET(
FILE_LIST
x
y
z
)

### Типы и виды параметров

Параметры в bob.make бывают всего трёх типов: строки, списки строк и булевы (по признаку наличия, см. ниже).

Параметры в bob.make бывают именованные и неименованные.

Неименованные параметры участвуют в вызове своим значением, они бывают:

- Скалярные — значением параметра является строка (одно слово). Иногда такой параметр может быть опциональным. Например, имя модуля.
- Свободно-списочные — значением параметра является список всех строк (слов), не отнесённых ни к какому другому параметру.

Именованные параметры участвуют в вызове своим именем и, возможно, значением. Исторически для именования параметров макросов, как и самих макросов, используется SCREAMING_SNAKE_CASE.

Именованные параметры бывают:

- Булевы — значение параметра определяется в описании самого макроса, а в вызове различается факт присутствия параметра в списке (истина) или отсутствия (ложь).
- Скалярные — значением параметра является строка (слово), идущее в вызове сразу после имени параметра.
- Списочные — значением параметра является список строк (слов), идущих после имени параметра и до следующего имени параметра или закрывающей скобки.

### Экранирование значений параметров

Чтобы объединить несколько слов в один параметр, используйте двойные кавычки "..." или, при необходимости, одинарные кавычки внутри двойных кавычек "'...'".

Пример:
SET(FILE_LIST “a.x b.x c.x”)

### Интерпретация значений параметров

Параметрами макросов могут быть практически что угодно и интерпретацией параметров могут заниматься разные системы в разные моменты времени:

- Часть значений интерпретирует сама система сборки.
- Часть значений интерпретируют плагины для макросов.
- Многие значения параметров макросов интерпретируются уже сборочными командами во время исполнения.

#### Имена директорий {#dirs}

Макросы, такие как PEERDIR, ADDINCL, RECURSE и DATA принимают имена директорий.

- ADDINCL и SRCDIR интерпретируют директории просто как пути.
- PEERDIR интерпретирует имена директорий, как ссылки на модули, которые будут там собраны.
- RECURSE интерпретирует имена директорий, как пути до bob.make в этих директориях.
- DATA интерпретирует директории, как зависимость от всех файлов в этой директории.

#### Имена файлов {#files}

Многие макросы принимают имена файлов.

- Некоторые макросы требуют указания полных имён файла, включая корень.
- Основная часть макросов не требует этого и имена файлов отображаются на реальные файлы.

### Условные конструкции {#if}

Система сборки позволяет выполнить часть макросов в bob.make только при определённых условиях. Для этого используются условные конструкции IF, ELSEIF, ELSE и ENDIF.

Пример использования:
IF (Expr)
…
ELSEIF (Expr)
…
ELSE()
…
ENDIF()

### Макросы установки переменных {#var_macros}

Для работы с переменными предусмотрены макросы SET, SET_APPEND, DEFAULT,
ENABLE и DISABLE.

- В глобальном скоупе можно определить новые переменные, которые не описаны в конфигурации.
- В модульном скоупе можно переопределить переменные, описанные в конфигурации.

Для использования переменных их значения подставляются следующим образом:
SET(SUFFIX res)
SET(INP xx.scheme)
SET(OUTP доллар(MODDIR)/доллар{INP}.доллар{SUFFIX})

### INCLUDE {#include}

Макрос INCLUDE(&lt;full_file_name&gt;) выполняет текстовую подстановку. Текст из файла, переданного параметром, будет подставлен вместо INCLUDE и интерпретирован.

### INCLUDE_ONCE

INCLUDE_ONCE([yes|no]) управляет однократной обработкой файла для каждого bob.make-файла. Это предотвращает дублирование значений переменных при многократных включениях.

### Работа с мультимодулями

Мультимодули позволяют описывать сборку нескольких разных модулей. Существует ряд специальных макросов для работы с мультимодулями:

- MODULE_TAG и PEERDIR_TAGS позволяют управлять доступными вариантами мультимодуля.
- EXCLUDE_TAGS, INCLUDE_TAGS и ONLY_TAGS позволяют управлять набором вариантов в мультимодуле.

## Как формируется сборка модуля

Формирование сборки модуля описывается следующим образом:

1. По макросам формируются команды, они связываются в цепочки.
2. Выстраиваются цепочки команд автоматической обработки файлов по расширениям.
3. Формируется команда модуля, которая получает на вход все файлы с расширениями автоматических входов.

## Откуда берутся модули, макросы и общие переменные {#conf}

Система сборки bob make очень гибко настраивается. Большинство её возможностей, доступных в bob.make-файлы, описаны как настройка. Набор доступных макросов и модулей постоянно расширяется и обновляется в автоматической документации.

Про то, как настраивается система сборки и как описываются макросы и модули, можно прочитать в соответствующей части раздела как работает система сборки.


# Обработка файлов по расширениям

Система сборки `ya make` ориентируется на расширения файлов:
- По расширениям она [добавляет команды для файлов](#srcs) в макросе [`SRCS`](common/macros.md#srcs) и при автоматической обработке промежуточных результатов.
- По расширениям [обрабатываются файлы в PY_SRCS и JAVA_SRCS](#py)
- По расширениям файлы [становятся входами модульных команд](#auto)
- По расширениям применяется [анализ зависимостей для исходных файлов](#parsing)


## Автоматические команды обработки файлов по расширениям { #srcs }

Макрос [`SRCS`](common/macros.md#srcs) обрабатывает файлы в соответствии с их расширениями. Более того,
в определённых случаях может меняться его поведение в зависимости от типа модуля, в котором его используют.

Также, если расширение зарегистрировано для [`SRCS`](common/macros.md#srcs), то файлы, появляющиеся в сборке как результаты команд, будут обработаны аналогично.

Макрос [`SRCS`](common/macros.md#srcs) для каждого файла формирует команду. В таблице ниже описано, какая команда будет сформирована и какое расширение будет у её результата.
Контекст — это модули, в которых работает это правило. Общий — это макросы `LIBRARY`, `PROGRAM`, `PYx_LIBRARY`, `PYx_PROGRAM`, `UNION`/`PACKAGE` и многие другие,
примерно все кроме `PROTO_LIBRARY`, `FBS_LIBRARY`, модулей для Java и Go.

Расширения | Обработчик  | Результат | Контекст
:--- | :--- | :--- | :---
`.c`, `.m` | компилятор С | `.o`/`.obj` | Общий
`.cpp`, `.cc`. `.cxx`, `.C` | компилятор C++ | `.o`/`.obj` | Общий
`.rl`, `.rl6` | ragel | `.c` | `LIBRARY`, `PROGRAM`, `PYx_LIBRARY`, `PYx_PROGRAM`,...
`.proto` | protoc | `.pb.cc`, `.pb.h`,... | `LIBRARY`, `PROTO_LIBRARY`/`CPP_PROTO`
`.proto` | protoc | `_pb2.py`, `pb2.pyi`,... | `PYxLIBRARY`, `PROTO_LIBRARY`/`PYx_PROTO`
`.proto` | protoc | `.jsrcs` | `PROTO_LIBRARY`/`JAVA_PROTO`
`.proto` | protoc | `.pb.go`, ... | `GO_LIBRARY`, `PROTO_LIBRARY`/`GO_PROTO`
`.S`, `.s`, `.s79`,  |  компилятор С  | `.o`/`.obj` | Общий
`.mm`  |  компилятор C | `.o`/`.obj` | Общий
`.fml`, | Транслятор формул | `fml.inc` | Общий
`.fml2` | Транслятор формул | `fml.inc`, Общий
`.fml3` | Транслятор формул | `fml.inc`, Общий
`.pln` | Транслятор формул | `pln.cpp` | Общий
`.sdfl` | компилятор C++ и tools/calcstaticopt | .o и.inc | Общий
`.xs` | Perl | `xs.c` или `xs.cpp` | Общий
`.y`, `.ypp` | byacc | `.y.cpp`, `.h` | Общий
`.gperf` | gperf | `.gperf.cpp` | Общий
`.rl`, `.rl5` | Ragel5 | `rl.cpp` | Общий
`.asp` | html2cpp | `asp.cpp` | Общий
`.rl6` | Ragel6 | `rl6.cpp` | Общий
`.l`, `.lex`, `.lpp` | flex | Общий
 `xsyn` | xsyn2ragel | `.rl5` | Общий
`.ev` | protoc | `.ev.pb.cc`, `.ev.pb.h`,... | `LIBRARY`, `PROTO_LIBRARY`/`CPP_PROTO`
`.ev` | protoc | `_ev.py`, `_ev.pyi`,... | `PYxLIBRARY`, `PROTO_LIBRARY`/`PYx_PROTO`
`.ev` | protoc | `.jsrcs` | `PROTO_LIBRARY`/`JAVA_PROTO`
`.gztproto` | dict/gazetteer/converter | `.proto` | Общий
`.cfgproto` | protoc | `.cfgproto.pb.cc`, `.cfgproto.pb.h`,... | Общий
`.pyx` | Cython | `.pyx.cpp` | `SRCS` в `PYMPODULE`, `LIBRARY`, `DLL`, `PY23_NATIVE_LIBRARY`
`.ext.in` | Из `*.ext.in`  получается `*.ext`  путем копирования `*.ext.in`  с заменой `@CONFIG_VAR@` на значение этой переменной в системе сборки | `.ext` | Любой
`.sc` | `tools/domschemec` | `.h` | Общий
`.ssqls` | `metrika/core/tools/ssqls` | `.h`, `.cpp` | Общий
`.f` | Fortran f2c | `.c` | Общий
`.masm` | masm | `.o`/`.obj` | Общий
`.asm`, `.yasm` | yasm | `.o`/`.obj` | Общий
`.lua` | LuaJIT |  `.o` | Общий
`.cu` | CUDA nvcc |  `.o` | Общий
`.fbs` | protoc | `.fbs.h` | `LIBRARY`, `FBS_LIBRARY`/`CPP_FBS`
`.fbs` | protoc | `.pysrcs` | `PYxLIBRARY`, `FBS_LIBRARY`/`PYx_FBS`
`.fbs` | protoc | `.jsrcs` | `FBS_LIBRARY`/`JAVA_FBS`
`.fbs` | protoc | `.gosrcs` | `GO_LIBRARY`, `FBS_LIBRARY`/`GO_FBS`
`.fbs64` | protoc | `.fbs64.h` | Общий

## Автоматические модульные входы { #auto }

Модульная конфигурация определяет файлы с какими расширениями будут её входами. Если в процессе [обработки по расширениям](#ext) появляется файл с таким расширением,
то обработка останавливается и файл становится **автоматическим входом** команды сборки модуля. Все такие входы формируют список имён, и он подаётся в модульную команду. 

Даже если для файла существует дальнейшая обработка, если расширение файла предписано модулю, обработка не будет запущена и файл будет отправлен в модульную команду.


Модули | Расширения
:--- | :--- 
`PROGRAM`, `LIBRARY`, `PYx_PROGRAM`, `PYx_LIBRARY` и т.п. | .o, .obj, .a, .lib
`PACKAGE`, `UNION` | .*
`JAVA_PROGRAM`, `JAVA_LIBRARY` | .*


## Анализ зависимостей по расширениям { #parsing }

Описание сборки в `ya make` очень высокоуровневое, она не требует описания зависимостей файлов от других файлов (например, `#include` в C++ или `import` в Protobuf), 
если исходный файл доступен на файловой системе. Система сборки сама анализирует исходные файлы, основываясь на расширениях и находит зависимости. Более того, система
сборки может выводить межмодульные зависимости (в go), а также *[наведённые](index.md#induced)* зависимости генерируемых файлов от других генерируемых. Так из `import` в .proto система сборки делает вывод не только о зависимости между .proto-файлами, но и о зависимости .pb.cc файла от импортируемого .pb.h.

Ниже в таблице собрана информация о том, какие расширения и как анализируются. Колонки в таблице означают следующее:

- **Расширение** -- список типов файлов, к которым это правило применяется.
- **Зависимости** -- список типов файлов, прямые зависимости от которых, умеет обнаруживать система сборки.
- **Наведённые** -- список типов файлов, для которых выводятся [наведённые зависимости](index.md#induced).
- **Распространение** -- могут ли наведённые зависимости распространяться через такие файлы. Если файл с таким расширением зависит от источника [наведённых зависимостей](index.md#induced),
  должны ли эти зависимости применяться к тем, кто зависит от этого файла.
- **Язык в `ADDINCL`** -- в макросе [`ADDINCL`](common/macros.md#addicl) можно указать, к каким файлам данный путь поиска относится. Это делается указанием *языка* в параметре `FOR`.
  В колонке обозначено, какой язык будет применяться для разрешения имён при обработке файлов в соответствующей строке.

Расширение | Зависимости | Наведённые  | распространение | Язык в `ADDINCL` | Описание
:--- | :--- | :--- | :--- | :--- | :---
`fml`, `fml2`, `fml3`, `pln`, `info`, `a`, `lua`, `sh` | нет | нет | нет | -- | Останавливают распространение зависимостей
`bin`, `py` | нет | нет | да | -- | Пропускают зависимости
`.c`, `.cc`, `cxx`, `.cpp`, `C` | `.h`, `hh`, `hpp`,... | -- | нет | `с`/нет | C/C++
`.h`, `.hh`, `.hpp`, `.cuh`, `.H`, `.hxx`, `.xh` | `.h`, `hh`, `hpp`,... | `.h`, `.cpp`, `.xscpp` | нет | `с`/нет | Заголовочные файлы
`.cu`, `.S`, `.s`, `.sfdl`, `.m`, `.mm` | `.h`, `hh`, `hpp`,... | `.h`, `.cpp` | нет | `с`/нет | Синтаксически похожи на С
`.asm` | `.asm` | нет | нет | `asm` | Ассемблер yasm
`.proto` | `.proto` | `pb.cc`, `pb.h` | нет | `proto` | Protobuf
`.ev` | `.proto` | `.ev.pb.cc`, `.ev.pb.h` | нет | `proto` | Events на основе protobuf
`.gzt`, `.gztproto` | `.proto` | нет | нет | `proto` | Конфиги на основе protobuf
`.cfgproto` | `.proto` | `.cfgproto.pb.cc`, `.cfgproto.pb.h` | нет | `proto` | Схемы для газеттира
`l`, `lex`, `lpp`, `.y`, `.ypp`, `gperf`, `.asp` | нет | `.cpp`  | нет | `c`/нет | lex, yacc, google perf, asp -- все генерируют код на С/C++
`rl`, `rh`, `rli`, `rl6`, `rl5` | `rl`, `rh`, `rli`, `rl6`, `rl5` | `.cpp` | нет | `ragel`  | Ragel
`.f` | нет | `.c` | нет |  `c`/нет | Fortran через f2c
`.xs` | нет  |  `.cpp`, `xscpp` | нет | `xs` | Perl to C биндинги
`.xscpp` | нет | `.cpp` | да  | `xs` | Perl to C++ биндинги
`.xsyn` | `.xsyn` | нет | нет | `xsyn` | XML
`.pyx` | `.pyx`, `.pxd` | `.cpp,`, `.h` | да | Cython
`.swg` |`.swg`, `.i` | `.h` , `.cpp` | нет | `swig` | SWIG биндинги для Python и Java
`.fbs` | `.fbs` | `.fbs.h` | нет | `flatc` | Flatbuffers
`.fbs64` | `.fbs64` | `.fbs64.h` | нет | `flatc` | 64-битный вариант Flatbuffers
`.go` | `.go` | `PEERDIR`, `.C` | нет | `c`/нет | Go
`.ts`, `.js`, `.tsx`, `.jsx` |`.ts`, `.js`, `.tsx`, `.jsx` | нет | нет | нет | Frontend-файлы, только в модулях под сборкой Frontend
`.sc` | `.sc` | нет | нет | `sc` | sc-схемы
`.ydl` | `.ydl` | `.h` | нет | `ydl` | ydl-схемы
`.nlg` | `.nlg` | `.h` | нет | `nlg` | nlg-схемы
`idl` | `idl` | `.h` | нет | `idl` | Mapkit IDL



## Расширения в `PY_SRCS` и `JAVA_SRCS` { #py }

Макросы [`PY_SRCS`](python/macros.md#py_srcs) и [`JAVA_SRCS`](java/macros.md#java_srcs) поддерживают свои наборы расширений, который могу специально обрабатывать.

### `PY_SRCS`

- `.py` -- компилируется с помощью pycc и складывается ресурсом доступным для импорта [программами на Python](python/index.md#python_program)
- `.pyc` -- компилируется с помощью cython и регистрируется, чтобы код был доступным для импорта [программами на Python](python/index.md#python_program)
- `.swg` -- компилируется с помощью swig и регистрируется, чтобы код был доступным для импорта [программами на Python](python/index.md#python_program)
- `.proto` -- генерируется код на Python, затем обрабатывается как `.py`
- `.fbs` -- генерируется код на Python (множество файлов), затем они компилируются и складываются в ресурсы доступные для импорта [программами на Python](python/index.md#python_program)


